/*****************************************************************************
# Copyright 2019 AT&T Intellectual Property                                  *
#                                                                            *
# Licensed under the Apache License, Version 2.0 (the "License");            *
# you may not use this file except in compliance with the License.           *
# You may obtain a copy of the License at                                    *
#                                                                            *
#      http://www.apache.org/licenses/LICENSE-2.0                            *
#                                                                            *
# Unless required by applicable law or agreed to in writing, software        *
# distributed under the License is distributed on an "AS IS" BASIS,          *
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   *
# See the License for the specific language governing permissions and        *
# limitations under the License.                                             *
#                                                                            *
******************************************************************************/

#pragma once

#include "asn/asn.hpp"
static_assert(ASN_API_VERSION_MAJOR == 5, "re-generate the ASN parser's code using 'make regen-asn' (do not use -j option)");

#include "X2AP-IEs.hpp"
#include "X2AP-Containers.hpp"
#include "X2AP-Constants.hpp"

/*
ActivatedCellList-Item-ExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct ActivatedCellList_Item_ExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
ActivatedCellList-Item::= SEQUENCE {
	ecgi								ECGI,
	iE-Extensions						ProtocolExtensionContainer { {ActivatedCellList-Item-ExtIEs} } OPTIONAL,
	...
}
*/

struct ActivatedCellList_Item : asn::sequence<2, 0, true, 1>
{
	static constexpr const char* name() {return "ActivatedCellList-Item";}
	using parent_t = asn::sequence<2, 0, true, 1>;
	struct ecgi_t : ECGI
	{
		static constexpr const char* name() {return "ecgi_t";}
		using parent_t = ECGI;

	};
	ecgi_t& ref_ecgi() {return ecgi;}
	ecgi_t const& ref_ecgi() const {return ecgi;}
	struct iE_Extensions_t : ProtocolExtensionContainer<ActivatedCellList_Item_ExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<ActivatedCellList_Item_ExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(ecgi);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(ecgi);
		v(iE_Extensions);

	};
	void clear()
	{
		ecgi.clear();
		iE_Extensions.clear();

	};
	private:
	ecgi_t	ecgi;
	iE_Extensions_t	iE_Extensions;

};
/*
ActivatedCellList ::= SEQUENCE (SIZE (1..maxCellineNB)) OF ActivatedCellList-Item
*/

struct ActivatedCellList_elm : ActivatedCellList_Item
{
	static constexpr const char* name() {return "ActivatedCellList_elm";}
	using parent_t = ActivatedCellList_Item;

};
struct ActivatedCellList : asn::sequenceof<ActivatedCellList_elm>
{
	static constexpr const char* name() {return "ActivatedCellList";}
	using parent_t = asn::sequenceof<ActivatedCellList_elm>;
	using constraint_t = asn::constraints<false,asn::span<1,  maxCellineNB >>;

};
/*
ActivatedNRCellList-Item-ExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct ActivatedNRCellList_Item_ExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
ActivatedNRCellList-Item::= SEQUENCE {
	nrCellID						NRCGI,
	iE-Extensions						ProtocolExtensionContainer { {ActivatedNRCellList-Item-ExtIEs} } OPTIONAL,
	...
}
*/

struct ActivatedNRCellList_Item : asn::sequence<2, 0, true, 1>
{
	static constexpr const char* name() {return "ActivatedNRCellList-Item";}
	using parent_t = asn::sequence<2, 0, true, 1>;
	struct nrCellID_t : NRCGI
	{
		static constexpr const char* name() {return "nrCellID_t";}
		using parent_t = NRCGI;

	};
	nrCellID_t& ref_nrCellID() {return nrCellID;}
	nrCellID_t const& ref_nrCellID() const {return nrCellID;}
	struct iE_Extensions_t : ProtocolExtensionContainer<ActivatedNRCellList_Item_ExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<ActivatedNRCellList_Item_ExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(nrCellID);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(nrCellID);
		v(iE_Extensions);

	};
	void clear()
	{
		nrCellID.clear();
		iE_Extensions.clear();

	};
	private:
	nrCellID_t	nrCellID;
	iE_Extensions_t	iE_Extensions;

};
/*
ActivatedNRCellList ::= SEQUENCE (SIZE (1.. maxCellinengNB)) OF ActivatedNRCellList-Item
*/

struct ActivatedNRCellList_elm : ActivatedNRCellList_Item
{
	static constexpr const char* name() {return "ActivatedNRCellList_elm";}
	using parent_t = ActivatedNRCellList_Item;

};
struct ActivatedNRCellList : asn::sequenceof<ActivatedNRCellList_elm>
{
	static constexpr const char* name() {return "ActivatedNRCellList";}
	using parent_t = asn::sequenceof<ActivatedNRCellList_elm>;
	using constraint_t = asn::constraints<false,asn::span<1,  maxCellinengNB >>;

};
/*
CellActivationFailure-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-Cause						CRITICALITY ignore	TYPE Cause						PRESENCE mandatory }|
	{ ID id-CriticalityDiagnostics		CRITICALITY ignore	TYPE CriticalityDiagnostics		PRESENCE optional },
	...
}
*/

struct CellActivationFailure_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 3; }
		void clear() {type = 0;}
		void select_id_Cause() { set(id_Cause); type=1;}
		void select_id_CriticalityDiagnostics() { set(id_CriticalityDiagnostics); type=2;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_Cause)) { type = 1; return true; }
			else if(equal(id_CriticalityDiagnostics)) { type = 2; return true; }
			else { type = 3; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_Cause);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_CriticalityDiagnostics);} return false;
			case 3: type = 3; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 3; }
		void clear() {type = 0;}
		void select_id_Cause() { set(ignore); type=1;}
		void select_id_CriticalityDiagnostics() { set(ignore); type=2;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else if(equal(ignore)) { type = 2; return true; }
			else { type = 3; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(ignore);} return false;
			case 3: type = 3; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		Cause& select_id_Cause() { return set<Cause>(1); }
		Cause const* get_id_Cause() const { return get<Cause>(1); }
		CriticalityDiagnostics& select_id_CriticalityDiagnostics() { return set<CriticalityDiagnostics>(2); }
		CriticalityDiagnostics const* get_id_CriticalityDiagnostics() const { return get<CriticalityDiagnostics>(2); }
		bool is_unknown() const { return type == 3; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<Cause>(); break;
			case 2: var.destroy<CriticalityDiagnostics>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<Cause>(1);
			v.template operator()<CriticalityDiagnostics>(2);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_Cause()); return true;
			case 2: v(select_id_CriticalityDiagnostics()); return true;
			case 3: if(type != 3) {clear(); asn::base::set();} type = 3; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<Cause>()); return true;
			case 2: v(var.as<CriticalityDiagnostics>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(Cause)];
			char dummy2[sizeof(CriticalityDiagnostics)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 3; }
		void clear() {type = 0;}
		void select_id_Cause() { set(mandatory); type=1;}
		void select_id_CriticalityDiagnostics() { set(optional); type=2;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(optional)) { type = 2; return true; }
			else { type = 3; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(optional);} return false;
			case 3: type = 3; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
CellActivationFailure ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{CellActivationFailure-IEs}},
	...
}
*/

struct CellActivationFailure : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "CellActivationFailure";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<CellActivationFailure_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<CellActivationFailure_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
ServedCellsToActivate-Item-ExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct ServedCellsToActivate_Item_ExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
ServedCellsToActivate-Item::= SEQUENCE {
	ecgi						ECGI,
	iE-Extensions					ProtocolExtensionContainer { {ServedCellsToActivate-Item-ExtIEs} } OPTIONAL,
	...
}
*/

struct ServedCellsToActivate_Item : asn::sequence<2, 0, true, 1>
{
	static constexpr const char* name() {return "ServedCellsToActivate-Item";}
	using parent_t = asn::sequence<2, 0, true, 1>;
	struct ecgi_t : ECGI
	{
		static constexpr const char* name() {return "ecgi_t";}
		using parent_t = ECGI;

	};
	ecgi_t& ref_ecgi() {return ecgi;}
	ecgi_t const& ref_ecgi() const {return ecgi;}
	struct iE_Extensions_t : ProtocolExtensionContainer<ServedCellsToActivate_Item_ExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<ServedCellsToActivate_Item_ExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(ecgi);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(ecgi);
		v(iE_Extensions);

	};
	void clear()
	{
		ecgi.clear();
		iE_Extensions.clear();

	};
	private:
	ecgi_t	ecgi;
	iE_Extensions_t	iE_Extensions;

};
/*
ServedCellsToActivate::= SEQUENCE (SIZE (1..maxCellineNB)) OF ServedCellsToActivate-Item
*/

struct ServedCellsToActivate_elm : ServedCellsToActivate_Item
{
	static constexpr const char* name() {return "ServedCellsToActivate_elm";}
	using parent_t = ServedCellsToActivate_Item;

};
struct ServedCellsToActivate : asn::sequenceof<ServedCellsToActivate_elm>
{
	static constexpr const char* name() {return "ServedCellsToActivate";}
	using parent_t = asn::sequenceof<ServedCellsToActivate_elm>;
	using constraint_t = asn::constraints<false,asn::span<1,  maxCellineNB >>;

};
/*
CellActivationRequest-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-ServedCellsToActivate 	CRITICALITY reject	TYPE ServedCellsToActivate		PRESENCE mandatory},
	...
}
*/

struct CellActivationRequest_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_ServedCellsToActivate() { set(id_ServedCellsToActivate); type=1;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_ServedCellsToActivate)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_ServedCellsToActivate);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_ServedCellsToActivate() { set(reject); type=1;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		ServedCellsToActivate& select_id_ServedCellsToActivate() { return set<ServedCellsToActivate>(1); }
		ServedCellsToActivate const* get_id_ServedCellsToActivate() const { return get<ServedCellsToActivate>(1); }
		bool is_unknown() const { return type == 2; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<ServedCellsToActivate>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<ServedCellsToActivate>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_ServedCellsToActivate()); return true;
			case 2: if(type != 2) {clear(); asn::base::set();} type = 2; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<ServedCellsToActivate>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(ServedCellsToActivate)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_ServedCellsToActivate() { set(mandatory); type=1;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
CellActivationRequest ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{CellActivationRequest-IEs}},
	...
}
*/

struct CellActivationRequest : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "CellActivationRequest";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<CellActivationRequest_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<CellActivationRequest_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
CellActivationResponse-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-ActivatedCellList		CRITICALITY ignore	TYPE ActivatedCellList				PRESENCE mandatory}|
	{ ID id-CriticalityDiagnostics	CRITICALITY ignore	TYPE CriticalityDiagnostics			PRESENCE optional},
	...
}
*/

struct CellActivationResponse_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 3; }
		void clear() {type = 0;}
		void select_id_ActivatedCellList() { set(id_ActivatedCellList); type=1;}
		void select_id_CriticalityDiagnostics() { set(id_CriticalityDiagnostics); type=2;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_ActivatedCellList)) { type = 1; return true; }
			else if(equal(id_CriticalityDiagnostics)) { type = 2; return true; }
			else { type = 3; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_ActivatedCellList);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_CriticalityDiagnostics);} return false;
			case 3: type = 3; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 3; }
		void clear() {type = 0;}
		void select_id_ActivatedCellList() { set(ignore); type=1;}
		void select_id_CriticalityDiagnostics() { set(ignore); type=2;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else if(equal(ignore)) { type = 2; return true; }
			else { type = 3; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(ignore);} return false;
			case 3: type = 3; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		ActivatedCellList& select_id_ActivatedCellList() { return set<ActivatedCellList>(1); }
		ActivatedCellList const* get_id_ActivatedCellList() const { return get<ActivatedCellList>(1); }
		CriticalityDiagnostics& select_id_CriticalityDiagnostics() { return set<CriticalityDiagnostics>(2); }
		CriticalityDiagnostics const* get_id_CriticalityDiagnostics() const { return get<CriticalityDiagnostics>(2); }
		bool is_unknown() const { return type == 3; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<ActivatedCellList>(); break;
			case 2: var.destroy<CriticalityDiagnostics>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<ActivatedCellList>(1);
			v.template operator()<CriticalityDiagnostics>(2);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_ActivatedCellList()); return true;
			case 2: v(select_id_CriticalityDiagnostics()); return true;
			case 3: if(type != 3) {clear(); asn::base::set();} type = 3; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<ActivatedCellList>()); return true;
			case 2: v(var.as<CriticalityDiagnostics>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(ActivatedCellList)];
			char dummy2[sizeof(CriticalityDiagnostics)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 3; }
		void clear() {type = 0;}
		void select_id_ActivatedCellList() { set(mandatory); type=1;}
		void select_id_CriticalityDiagnostics() { set(optional); type=2;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(optional)) { type = 2; return true; }
			else { type = 3; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(optional);} return false;
			case 3: type = 3; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
CellActivationResponse ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{CellActivationResponse-IEs}},
	...
}
*/

struct CellActivationResponse : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "CellActivationResponse";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<CellActivationResponse_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<CellActivationResponse_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
Limited-list-ExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct Limited_list_ExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
Limited-list 	::= SEQUENCE (SIZE (1..maxCellinengNB)) OF SEQUENCE {
	nrCellID			NRCGI,
		iE-Extensions						ProtocolExtensionContainer { {Limited-list-ExtIEs} } OPTIONAL,
	...
}
*/

struct Limited_list_elm : asn::sequence<2, 0, true, 1>
{
	static constexpr const char* name() {return "Limited_list_elm";}
	using parent_t = asn::sequence<2, 0, true, 1>;
	struct nrCellID_t : NRCGI
	{
		static constexpr const char* name() {return "nrCellID_t";}
		using parent_t = NRCGI;

	};
	nrCellID_t& ref_nrCellID() {return nrCellID;}
	nrCellID_t const& ref_nrCellID() const {return nrCellID;}
	struct iE_Extensions_t : ProtocolExtensionContainer<Limited_list_ExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<Limited_list_ExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(nrCellID);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(nrCellID);
		v(iE_Extensions);

	};
	void clear()
	{
		nrCellID.clear();
		iE_Extensions.clear();

	};
	private:
	nrCellID_t	nrCellID;
	iE_Extensions_t	iE_Extensions;

};
struct Limited_list : asn::sequenceof<Limited_list_elm>
{
	static constexpr const char* name() {return "Limited-list";}
	using parent_t = asn::sequenceof<Limited_list_elm>;
	using constraint_t = asn::constraints<false,asn::span<1,  maxCellinengNB >>;

};
/*
CellAssistanceInformation ::= CHOICE {
	limited-list				Limited-list,
	full-list				ENUMERATED {allServedNRcells, ...},
	...
}
*/

struct CellAssistanceInformation : asn::choice<2, 0, true>
{
	static constexpr const char* name() {return "CellAssistanceInformation";}
	using parent_t = asn::choice<2, 0, true>;
	index_type get_index() const {return index;}
	bool is_unknown() const {return index == 3;}
	void set_unknown() { set_index(3);  }
	~CellAssistanceInformation() {clear();}
	struct limited_list_t : Limited_list
	{
		static constexpr const char* name() {return "limited_list_t";}
		using parent_t = Limited_list;

	};
	struct full_list_t : asn::enumerated<1, 0, true>
	{
		static constexpr const char* name() {return "full_list_t";}
		using parent_t = asn::enumerated<1, 0, true>;
		typedef enum {
			allServedNRcells
		} index_t;

	};

	void clear()
	{
		switch(get_index())
		{
		case 1: var.destroy<limited_list_t>(); break;
		case 2: var.destroy<full_list_t>(); break;
		}
		index = 0;
		base::clear();
	}
	template<typename V> bool decode(size_t idx, V& v)
	{
		clear();
		switch(idx)
		{
		case 1: set_index(1); return v(var.build<limited_list_t>());
		case 2: set_index(2); return v(var.build<full_list_t>());
		}
		return false;

	}
	template<typename V> bool encode(V& v) const
	{
		switch(get_index())
		{
		case 1: return v(var.as<limited_list_t>());
		case 2: return v(var.as<full_list_t>());
		}
		return false;
	}
	template<typename V> static inline void enumerate(V& v)
	{
		v.template operator()<limited_list_t>(1);
		v.template operator()<full_list_t>(2);

	}
	limited_list_t& select_limited_list() { if(get_index() != 1) { clear(); set_index(1); return var.build<limited_list_t>();} return var.as<limited_list_t>();}
	limited_list_t const* get_limited_list() const { if(get_index() == 1) { return &var.as<limited_list_t>();} return nullptr; }
	full_list_t& select_full_list() { if(get_index() != 2) { clear(); set_index(2); return var.build<full_list_t>();} return var.as<full_list_t>();}
	full_list_t const* get_full_list() const { if(get_index() == 2) { return &var.as<full_list_t>();} return nullptr; }
	private:
	void set_index(index_type i) {index = i; base::set();}
	union union_type
	{
		char dummy1[sizeof(limited_list_t)];
		char dummy2[sizeof(full_list_t)];

	};
	asn::variant<sizeof(union_type)>	var;
	index_type	index {0};
};
/*
CellInformation-Item-ExtIEs X2AP-PROTOCOL-EXTENSION ::= {
{ ID id-ABSInformation						CRITICALITY ignore	EXTENSION ABSInformation							PRESENCE optional }|
{ ID id-InvokeIndication					CRITICALITY ignore	EXTENSION InvokeIndication							PRESENCE optional }|
{ ID id-IntendedULDLConfiguration			CRITICALITY ignore	EXTENSION SubframeAssignment						PRESENCE optional }|
{ ID id-ExtendedULInterferenceOverloadInfo	CRITICALITY ignore	EXTENSION ExtendedULInterferenceOverloadInfo	PRESENCE optional }|
{ ID id-CoMPInformation						CRITICALITY ignore	EXTENSION CoMPInformation							PRESENCE optional }|
{ ID id-DynamicDLTransmissionInformation	CRITICALITY ignore	EXTENSION DynamicDLTransmissionInformation		PRESENCE optional },
	...
}
*/

struct CellInformation_Item_ExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 7; }
		void clear() {type = 0;}
		void select_id_ABSInformation() { set(id_ABSInformation); type=1;}
		void select_id_InvokeIndication() { set(id_InvokeIndication); type=2;}
		void select_id_IntendedULDLConfiguration() { set(id_IntendedULDLConfiguration); type=3;}
		void select_id_ExtendedULInterferenceOverloadInfo() { set(id_ExtendedULInterferenceOverloadInfo); type=4;}
		void select_id_CoMPInformation() { set(id_CoMPInformation); type=5;}
		void select_id_DynamicDLTransmissionInformation() { set(id_DynamicDLTransmissionInformation); type=6;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_ABSInformation)) { type = 1; return true; }
			else if(equal(id_InvokeIndication)) { type = 2; return true; }
			else if(equal(id_IntendedULDLConfiguration)) { type = 3; return true; }
			else if(equal(id_ExtendedULInterferenceOverloadInfo)) { type = 4; return true; }
			else if(equal(id_CoMPInformation)) { type = 5; return true; }
			else if(equal(id_DynamicDLTransmissionInformation)) { type = 6; return true; }
			else { type = 7; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_ABSInformation);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_InvokeIndication);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_IntendedULDLConfiguration);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(id_ExtendedULInterferenceOverloadInfo);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(id_CoMPInformation);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(id_DynamicDLTransmissionInformation);} return false;
			case 7: type = 7; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 7; }
		void clear() {type = 0;}
		void select_id_ABSInformation() { set(ignore); type=1;}
		void select_id_InvokeIndication() { set(ignore); type=2;}
		void select_id_IntendedULDLConfiguration() { set(ignore); type=3;}
		void select_id_ExtendedULInterferenceOverloadInfo() { set(ignore); type=4;}
		void select_id_CoMPInformation() { set(ignore); type=5;}
		void select_id_DynamicDLTransmissionInformation() { set(ignore); type=6;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else if(equal(ignore)) { type = 2; return true; }
			else if(equal(ignore)) { type = 3; return true; }
			else if(equal(ignore)) { type = 4; return true; }
			else if(equal(ignore)) { type = 5; return true; }
			else if(equal(ignore)) { type = 6; return true; }
			else { type = 7; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(ignore);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(ignore);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(ignore);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(ignore);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(ignore);} return false;
			case 7: type = 7; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		ABSInformation& select_id_ABSInformation() { return set<ABSInformation>(1); }
		ABSInformation const* get_id_ABSInformation() const { return get<ABSInformation>(1); }
		InvokeIndication& select_id_InvokeIndication() { return set<InvokeIndication>(2); }
		InvokeIndication const* get_id_InvokeIndication() const { return get<InvokeIndication>(2); }
		SubframeAssignment& select_id_IntendedULDLConfiguration() { return set<SubframeAssignment>(3); }
		SubframeAssignment const* get_id_IntendedULDLConfiguration() const { return get<SubframeAssignment>(3); }
		ExtendedULInterferenceOverloadInfo& select_id_ExtendedULInterferenceOverloadInfo() { return set<ExtendedULInterferenceOverloadInfo>(4); }
		ExtendedULInterferenceOverloadInfo const* get_id_ExtendedULInterferenceOverloadInfo() const { return get<ExtendedULInterferenceOverloadInfo>(4); }
		CoMPInformation& select_id_CoMPInformation() { return set<CoMPInformation>(5); }
		CoMPInformation const* get_id_CoMPInformation() const { return get<CoMPInformation>(5); }
		DynamicDLTransmissionInformation& select_id_DynamicDLTransmissionInformation() { return set<DynamicDLTransmissionInformation>(6); }
		DynamicDLTransmissionInformation const* get_id_DynamicDLTransmissionInformation() const { return get<DynamicDLTransmissionInformation>(6); }
		bool is_unknown() const { return type == 7; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<ABSInformation>(); break;
			case 2: var.destroy<InvokeIndication>(); break;
			case 3: var.destroy<SubframeAssignment>(); break;
			case 4: var.destroy<ExtendedULInterferenceOverloadInfo>(); break;
			case 5: var.destroy<CoMPInformation>(); break;
			case 6: var.destroy<DynamicDLTransmissionInformation>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<ABSInformation>(1);
			v.template operator()<InvokeIndication>(2);
			v.template operator()<SubframeAssignment>(3);
			v.template operator()<ExtendedULInterferenceOverloadInfo>(4);
			v.template operator()<CoMPInformation>(5);
			v.template operator()<DynamicDLTransmissionInformation>(6);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_ABSInformation()); return true;
			case 2: v(select_id_InvokeIndication()); return true;
			case 3: v(select_id_IntendedULDLConfiguration()); return true;
			case 4: v(select_id_ExtendedULInterferenceOverloadInfo()); return true;
			case 5: v(select_id_CoMPInformation()); return true;
			case 6: v(select_id_DynamicDLTransmissionInformation()); return true;
			case 7: if(type != 7) {clear(); asn::base::set();} type = 7; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<ABSInformation>()); return true;
			case 2: v(var.as<InvokeIndication>()); return true;
			case 3: v(var.as<SubframeAssignment>()); return true;
			case 4: v(var.as<ExtendedULInterferenceOverloadInfo>()); return true;
			case 5: v(var.as<CoMPInformation>()); return true;
			case 6: v(var.as<DynamicDLTransmissionInformation>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(ABSInformation)];
			char dummy2[sizeof(CoMPInformation)];
			char dummy3[sizeof(DynamicDLTransmissionInformation)];
			char dummy4[sizeof(ExtendedULInterferenceOverloadInfo)];
			char dummy5[sizeof(InvokeIndication)];
			char dummy6[sizeof(SubframeAssignment)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 7; }
		void clear() {type = 0;}
		void select_id_ABSInformation() { set(optional); type=1;}
		void select_id_InvokeIndication() { set(optional); type=2;}
		void select_id_IntendedULDLConfiguration() { set(optional); type=3;}
		void select_id_ExtendedULInterferenceOverloadInfo() { set(optional); type=4;}
		void select_id_CoMPInformation() { set(optional); type=5;}
		void select_id_DynamicDLTransmissionInformation() { set(optional); type=6;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(optional)) { type = 1; return true; }
			else if(equal(optional)) { type = 2; return true; }
			else if(equal(optional)) { type = 3; return true; }
			else if(equal(optional)) { type = 4; return true; }
			else if(equal(optional)) { type = 5; return true; }
			else if(equal(optional)) { type = 6; return true; }
			else { type = 7; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(optional);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(optional);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(optional);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(optional);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(optional);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(optional);} return false;
			case 7: type = 7; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
CellInformation-Item ::= SEQUENCE {
	cell-ID							ECGI,
	ul-InterferenceOverloadIndication		UL-InterferenceOverloadIndication		OPTIONAL,
	ul-HighInterferenceIndicationInfo		UL-HighInterferenceIndicationInfo		OPTIONAL,
	relativeNarrowbandTxPower				RelativeNarrowbandTxPower				OPTIONAL,
	iE-Extensions							ProtocolExtensionContainer { {CellInformation-Item-ExtIEs} }	OPTIONAL,
	...
}
*/

struct CellInformation_Item : asn::sequence<5, 0, true, 4>
{
	static constexpr const char* name() {return "CellInformation-Item";}
	using parent_t = asn::sequence<5, 0, true, 4>;
	struct cell_ID_t : ECGI
	{
		static constexpr const char* name() {return "cell_ID_t";}
		using parent_t = ECGI;

	};
	cell_ID_t& ref_cell_ID() {return cell_ID;}
	cell_ID_t const& ref_cell_ID() const {return cell_ID;}
	struct ul_InterferenceOverloadIndication_t : UL_InterferenceOverloadIndication
	{
		static constexpr const char* name() {return "ul_InterferenceOverloadIndication_t";}
		using parent_t = UL_InterferenceOverloadIndication;
		static constexpr bool optional = true;

	};
	ul_InterferenceOverloadIndication_t& set_ul_InterferenceOverloadIndication() { ul_InterferenceOverloadIndication.setpresent(true); return ul_InterferenceOverloadIndication;}
	ul_InterferenceOverloadIndication_t const* get_ul_InterferenceOverloadIndication() const {return ul_InterferenceOverloadIndication.is_valid() ? &ul_InterferenceOverloadIndication : nullptr;}
	struct ul_HighInterferenceIndicationInfo_t : UL_HighInterferenceIndicationInfo
	{
		static constexpr const char* name() {return "ul_HighInterferenceIndicationInfo_t";}
		using parent_t = UL_HighInterferenceIndicationInfo;
		static constexpr bool optional = true;

	};
	ul_HighInterferenceIndicationInfo_t& set_ul_HighInterferenceIndicationInfo() { ul_HighInterferenceIndicationInfo.setpresent(true); return ul_HighInterferenceIndicationInfo;}
	ul_HighInterferenceIndicationInfo_t const* get_ul_HighInterferenceIndicationInfo() const {return ul_HighInterferenceIndicationInfo.is_valid() ? &ul_HighInterferenceIndicationInfo : nullptr;}
	struct relativeNarrowbandTxPower_t : RelativeNarrowbandTxPower
	{
		static constexpr const char* name() {return "relativeNarrowbandTxPower_t";}
		using parent_t = RelativeNarrowbandTxPower;
		static constexpr bool optional = true;

	};
	relativeNarrowbandTxPower_t& set_relativeNarrowbandTxPower() { relativeNarrowbandTxPower.setpresent(true); return relativeNarrowbandTxPower;}
	relativeNarrowbandTxPower_t const* get_relativeNarrowbandTxPower() const {return relativeNarrowbandTxPower.is_valid() ? &relativeNarrowbandTxPower : nullptr;}
	struct iE_Extensions_t : ProtocolExtensionContainer<CellInformation_Item_ExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<CellInformation_Item_ExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(cell_ID);
		v(ul_InterferenceOverloadIndication);
		v(ul_HighInterferenceIndicationInfo);
		v(relativeNarrowbandTxPower);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(cell_ID);
		v(ul_InterferenceOverloadIndication);
		v(ul_HighInterferenceIndicationInfo);
		v(relativeNarrowbandTxPower);
		v(iE_Extensions);

	};
	void clear()
	{
		cell_ID.clear();
		ul_InterferenceOverloadIndication.clear();
		ul_HighInterferenceIndicationInfo.clear();
		relativeNarrowbandTxPower.clear();
		iE_Extensions.clear();

	};
	private:
	cell_ID_t	cell_ID;
	ul_InterferenceOverloadIndication_t	ul_InterferenceOverloadIndication;
	ul_HighInterferenceIndicationInfo_t	ul_HighInterferenceIndicationInfo;
	relativeNarrowbandTxPower_t	relativeNarrowbandTxPower;
	iE_Extensions_t	iE_Extensions;

};
/*
CellInformation-ItemIEs X2AP-PROTOCOL-IES ::= {
	{ ID id-CellInformation-Item	CRITICALITY ignore	TYPE CellInformation-Item 	PRESENCE mandatory	}
}
*/

struct CellInformation_ItemIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, false>
	{
		size_t get_index() const {return type;}
		void clear() {type = 0;}
		void select_id_CellInformation_Item() { set(id_CellInformation_Item); type=1;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_CellInformation_Item)) { type = 1; return true; }
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_CellInformation_Item);} return false;
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, false>
	{
		size_t get_index() const {return type;}
		void clear() {type = 0;}
		void select_id_CellInformation_Item() { set(ignore); type=1;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<false>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		CellInformation_Item& select_id_CellInformation_Item() { return set<CellInformation_Item>(1); }
		CellInformation_Item const* get_id_CellInformation_Item() const { return get<CellInformation_Item>(1); }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<CellInformation_Item>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<CellInformation_Item>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_CellInformation_Item()); return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<CellInformation_Item>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(CellInformation_Item)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, false>
	{
		size_t get_index() const {return type;}
		void clear() {type = 0;}
		void select_id_CellInformation_Item() { set(mandatory); type=1;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
CellInformation-List ::= SEQUENCE (SIZE (1..maxCellineNB)) OF ProtocolIE-Single-Container { {CellInformation-ItemIEs} }
*/

struct CellInformation_List_elm : ProtocolIE_Single_Container<CellInformation_ItemIEs>
{
	static constexpr const char* name() {return "CellInformation_List_elm";}
	using parent_t = ProtocolIE_Single_Container<CellInformation_ItemIEs>;

};
struct CellInformation_List : asn::sequenceof<CellInformation_List_elm>
{
	static constexpr const char* name() {return "CellInformation-List";}
	using parent_t = asn::sequenceof<CellInformation_List_elm>;
	using constraint_t = asn::constraints<false,asn::span<1,  maxCellineNB >>;

};
/*
CellMeasurementResult-Item-ExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	{ ID id-CompositeAvailableCapacityGroup	CRITICALITY ignore	EXTENSION CompositeAvailableCapacityGroup		PRESENCE optional}|
	{ ID id-ABS-Status						CRITICALITY ignore	EXTENSION ABS-Status								PRESENCE optional}|
	{ ID id-RSRPMRList						CRITICALITY ignore	EXTENSION RSRPMRList								PRESENCE optional}|
	{ ID id-CSIReportList					CRITICALITY ignore	EXTENSION CSIReportList								PRESENCE optional}|
	{ ID id-CellReportingIndicator			CRITICALITY ignore	EXTENSION CellReportingIndicator					PRESENCE optional},
	...
}
*/

struct CellMeasurementResult_Item_ExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 6; }
		void clear() {type = 0;}
		void select_id_CompositeAvailableCapacityGroup() { set(id_CompositeAvailableCapacityGroup); type=1;}
		void select_id_ABS_Status() { set(id_ABS_Status); type=2;}
		void select_id_RSRPMRList() { set(id_RSRPMRList); type=3;}
		void select_id_CSIReportList() { set(id_CSIReportList); type=4;}
		void select_id_CellReportingIndicator() { set(id_CellReportingIndicator); type=5;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_CompositeAvailableCapacityGroup)) { type = 1; return true; }
			else if(equal(id_ABS_Status)) { type = 2; return true; }
			else if(equal(id_RSRPMRList)) { type = 3; return true; }
			else if(equal(id_CSIReportList)) { type = 4; return true; }
			else if(equal(id_CellReportingIndicator)) { type = 5; return true; }
			else { type = 6; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_CompositeAvailableCapacityGroup);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_ABS_Status);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_RSRPMRList);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(id_CSIReportList);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(id_CellReportingIndicator);} return false;
			case 6: type = 6; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 6; }
		void clear() {type = 0;}
		void select_id_CompositeAvailableCapacityGroup() { set(ignore); type=1;}
		void select_id_ABS_Status() { set(ignore); type=2;}
		void select_id_RSRPMRList() { set(ignore); type=3;}
		void select_id_CSIReportList() { set(ignore); type=4;}
		void select_id_CellReportingIndicator() { set(ignore); type=5;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else if(equal(ignore)) { type = 2; return true; }
			else if(equal(ignore)) { type = 3; return true; }
			else if(equal(ignore)) { type = 4; return true; }
			else if(equal(ignore)) { type = 5; return true; }
			else { type = 6; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(ignore);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(ignore);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(ignore);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(ignore);} return false;
			case 6: type = 6; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		CompositeAvailableCapacityGroup& select_id_CompositeAvailableCapacityGroup() { return set<CompositeAvailableCapacityGroup>(1); }
		CompositeAvailableCapacityGroup const* get_id_CompositeAvailableCapacityGroup() const { return get<CompositeAvailableCapacityGroup>(1); }
		ABS_Status& select_id_ABS_Status() { return set<ABS_Status>(2); }
		ABS_Status const* get_id_ABS_Status() const { return get<ABS_Status>(2); }
		RSRPMRList& select_id_RSRPMRList() { return set<RSRPMRList>(3); }
		RSRPMRList const* get_id_RSRPMRList() const { return get<RSRPMRList>(3); }
		CSIReportList& select_id_CSIReportList() { return set<CSIReportList>(4); }
		CSIReportList const* get_id_CSIReportList() const { return get<CSIReportList>(4); }
		CellReportingIndicator& select_id_CellReportingIndicator() { return set<CellReportingIndicator>(5); }
		CellReportingIndicator const* get_id_CellReportingIndicator() const { return get<CellReportingIndicator>(5); }
		bool is_unknown() const { return type == 6; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<CompositeAvailableCapacityGroup>(); break;
			case 2: var.destroy<ABS_Status>(); break;
			case 3: var.destroy<RSRPMRList>(); break;
			case 4: var.destroy<CSIReportList>(); break;
			case 5: var.destroy<CellReportingIndicator>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<CompositeAvailableCapacityGroup>(1);
			v.template operator()<ABS_Status>(2);
			v.template operator()<RSRPMRList>(3);
			v.template operator()<CSIReportList>(4);
			v.template operator()<CellReportingIndicator>(5);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_CompositeAvailableCapacityGroup()); return true;
			case 2: v(select_id_ABS_Status()); return true;
			case 3: v(select_id_RSRPMRList()); return true;
			case 4: v(select_id_CSIReportList()); return true;
			case 5: v(select_id_CellReportingIndicator()); return true;
			case 6: if(type != 6) {clear(); asn::base::set();} type = 6; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<CompositeAvailableCapacityGroup>()); return true;
			case 2: v(var.as<ABS_Status>()); return true;
			case 3: v(var.as<RSRPMRList>()); return true;
			case 4: v(var.as<CSIReportList>()); return true;
			case 5: v(var.as<CellReportingIndicator>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(ABS_Status)];
			char dummy2[sizeof(CSIReportList)];
			char dummy3[sizeof(CellReportingIndicator)];
			char dummy4[sizeof(CompositeAvailableCapacityGroup)];
			char dummy5[sizeof(RSRPMRList)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 6; }
		void clear() {type = 0;}
		void select_id_CompositeAvailableCapacityGroup() { set(optional); type=1;}
		void select_id_ABS_Status() { set(optional); type=2;}
		void select_id_RSRPMRList() { set(optional); type=3;}
		void select_id_CSIReportList() { set(optional); type=4;}
		void select_id_CellReportingIndicator() { set(optional); type=5;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(optional)) { type = 1; return true; }
			else if(equal(optional)) { type = 2; return true; }
			else if(equal(optional)) { type = 3; return true; }
			else if(equal(optional)) { type = 4; return true; }
			else if(equal(optional)) { type = 5; return true; }
			else { type = 6; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(optional);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(optional);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(optional);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(optional);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(optional);} return false;
			case 6: type = 6; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
CellMeasurementResult-Item ::= SEQUENCE {
	cell-ID						ECGI,
	hWLoadIndicator				HWLoadIndicator		OPTIONAL,
	s1TNLLoadIndicator			S1TNLLoadIndicator	OPTIONAL,
	radioResourceStatus			RadioResourceStatus	OPTIONAL,
	iE-Extensions				ProtocolExtensionContainer { {CellMeasurementResult-Item-ExtIEs} }	OPTIONAL,
	...
}
*/

struct CellMeasurementResult_Item : asn::sequence<5, 0, true, 4>
{
	static constexpr const char* name() {return "CellMeasurementResult-Item";}
	using parent_t = asn::sequence<5, 0, true, 4>;
	struct cell_ID_t : ECGI
	{
		static constexpr const char* name() {return "cell_ID_t";}
		using parent_t = ECGI;

	};
	cell_ID_t& ref_cell_ID() {return cell_ID;}
	cell_ID_t const& ref_cell_ID() const {return cell_ID;}
	struct hWLoadIndicator_t : HWLoadIndicator
	{
		static constexpr const char* name() {return "hWLoadIndicator_t";}
		using parent_t = HWLoadIndicator;
		static constexpr bool optional = true;

	};
	hWLoadIndicator_t& set_hWLoadIndicator() { hWLoadIndicator.setpresent(true); return hWLoadIndicator;}
	hWLoadIndicator_t const* get_hWLoadIndicator() const {return hWLoadIndicator.is_valid() ? &hWLoadIndicator : nullptr;}
	struct s1TNLLoadIndicator_t : S1TNLLoadIndicator
	{
		static constexpr const char* name() {return "s1TNLLoadIndicator_t";}
		using parent_t = S1TNLLoadIndicator;
		static constexpr bool optional = true;

	};
	s1TNLLoadIndicator_t& set_s1TNLLoadIndicator() { s1TNLLoadIndicator.setpresent(true); return s1TNLLoadIndicator;}
	s1TNLLoadIndicator_t const* get_s1TNLLoadIndicator() const {return s1TNLLoadIndicator.is_valid() ? &s1TNLLoadIndicator : nullptr;}
	struct radioResourceStatus_t : RadioResourceStatus
	{
		static constexpr const char* name() {return "radioResourceStatus_t";}
		using parent_t = RadioResourceStatus;
		static constexpr bool optional = true;

	};
	radioResourceStatus_t& set_radioResourceStatus() { radioResourceStatus.setpresent(true); return radioResourceStatus;}
	radioResourceStatus_t const* get_radioResourceStatus() const {return radioResourceStatus.is_valid() ? &radioResourceStatus : nullptr;}
	struct iE_Extensions_t : ProtocolExtensionContainer<CellMeasurementResult_Item_ExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<CellMeasurementResult_Item_ExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(cell_ID);
		v(hWLoadIndicator);
		v(s1TNLLoadIndicator);
		v(radioResourceStatus);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(cell_ID);
		v(hWLoadIndicator);
		v(s1TNLLoadIndicator);
		v(radioResourceStatus);
		v(iE_Extensions);

	};
	void clear()
	{
		cell_ID.clear();
		hWLoadIndicator.clear();
		s1TNLLoadIndicator.clear();
		radioResourceStatus.clear();
		iE_Extensions.clear();

	};
	private:
	cell_ID_t	cell_ID;
	hWLoadIndicator_t	hWLoadIndicator;
	s1TNLLoadIndicator_t	s1TNLLoadIndicator;
	radioResourceStatus_t	radioResourceStatus;
	iE_Extensions_t	iE_Extensions;

};
/*
CellMeasurementResult-ItemIEs X2AP-PROTOCOL-IES ::= {
	{ ID id-CellMeasurementResult-Item	CRITICALITY ignore	TYPE CellMeasurementResult-Item	PRESENCE mandatory}
}
*/

struct CellMeasurementResult_ItemIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, false>
	{
		size_t get_index() const {return type;}
		void clear() {type = 0;}
		void select_id_CellMeasurementResult_Item() { set(id_CellMeasurementResult_Item); type=1;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_CellMeasurementResult_Item)) { type = 1; return true; }
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_CellMeasurementResult_Item);} return false;
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, false>
	{
		size_t get_index() const {return type;}
		void clear() {type = 0;}
		void select_id_CellMeasurementResult_Item() { set(ignore); type=1;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<false>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		CellMeasurementResult_Item& select_id_CellMeasurementResult_Item() { return set<CellMeasurementResult_Item>(1); }
		CellMeasurementResult_Item const* get_id_CellMeasurementResult_Item() const { return get<CellMeasurementResult_Item>(1); }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<CellMeasurementResult_Item>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<CellMeasurementResult_Item>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_CellMeasurementResult_Item()); return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<CellMeasurementResult_Item>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(CellMeasurementResult_Item)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, false>
	{
		size_t get_index() const {return type;}
		void clear() {type = 0;}
		void select_id_CellMeasurementResult_Item() { set(mandatory); type=1;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
CellMeasurementResult-List ::= SEQUENCE (SIZE (1..maxCellineNB)) OF ProtocolIE-Single-Container { {CellMeasurementResult-ItemIEs} }
*/

struct CellMeasurementResult_List_elm : ProtocolIE_Single_Container<CellMeasurementResult_ItemIEs>
{
	static constexpr const char* name() {return "CellMeasurementResult_List_elm";}
	using parent_t = ProtocolIE_Single_Container<CellMeasurementResult_ItemIEs>;

};
struct CellMeasurementResult_List : asn::sequenceof<CellMeasurementResult_List_elm>
{
	static constexpr const char* name() {return "CellMeasurementResult-List";}
	using parent_t = asn::sequenceof<CellMeasurementResult_List_elm>;
	using constraint_t = asn::constraints<false,asn::span<1,  maxCellineNB >>;

};
/*
CellToReport-Item-ExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct CellToReport_Item_ExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
CellToReport-Item ::= SEQUENCE {
	cell-ID									ECGI,
	iE-Extensions							ProtocolExtensionContainer { {CellToReport-Item-ExtIEs} } OPTIONAL,
	...
}
*/

struct CellToReport_Item : asn::sequence<2, 0, true, 1>
{
	static constexpr const char* name() {return "CellToReport-Item";}
	using parent_t = asn::sequence<2, 0, true, 1>;
	struct cell_ID_t : ECGI
	{
		static constexpr const char* name() {return "cell_ID_t";}
		using parent_t = ECGI;

	};
	cell_ID_t& ref_cell_ID() {return cell_ID;}
	cell_ID_t const& ref_cell_ID() const {return cell_ID;}
	struct iE_Extensions_t : ProtocolExtensionContainer<CellToReport_Item_ExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<CellToReport_Item_ExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(cell_ID);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(cell_ID);
		v(iE_Extensions);

	};
	void clear()
	{
		cell_ID.clear();
		iE_Extensions.clear();

	};
	private:
	cell_ID_t	cell_ID;
	iE_Extensions_t	iE_Extensions;

};
/*
CellToReport-ItemIEs X2AP-PROTOCOL-IES ::= {
	{ ID id-CellToReport-Item	CRITICALITY ignore	TYPE CellToReport-Item 	PRESENCE mandatory}
}
*/

struct CellToReport_ItemIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, false>
	{
		size_t get_index() const {return type;}
		void clear() {type = 0;}
		void select_id_CellToReport_Item() { set(id_CellToReport_Item); type=1;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_CellToReport_Item)) { type = 1; return true; }
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_CellToReport_Item);} return false;
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, false>
	{
		size_t get_index() const {return type;}
		void clear() {type = 0;}
		void select_id_CellToReport_Item() { set(ignore); type=1;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<false>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		CellToReport_Item& select_id_CellToReport_Item() { return set<CellToReport_Item>(1); }
		CellToReport_Item const* get_id_CellToReport_Item() const { return get<CellToReport_Item>(1); }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<CellToReport_Item>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<CellToReport_Item>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_CellToReport_Item()); return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<CellToReport_Item>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(CellToReport_Item)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, false>
	{
		size_t get_index() const {return type;}
		void clear() {type = 0;}
		void select_id_CellToReport_Item() { set(mandatory); type=1;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
CellToReport-List 		::= SEQUENCE (SIZE (1..maxCellineNB)) OF ProtocolIE-Single-Container { {CellToReport-ItemIEs} }
*/

struct CellToReport_List_elm : ProtocolIE_Single_Container<CellToReport_ItemIEs>
{
	static constexpr const char* name() {return "CellToReport_List_elm";}
	using parent_t = ProtocolIE_Single_Container<CellToReport_ItemIEs>;

};
struct CellToReport_List : asn::sequenceof<CellToReport_List_elm>
{
	static constexpr const char* name() {return "CellToReport-List";}
	using parent_t = asn::sequenceof<CellToReport_List_elm>;
	using constraint_t = asn::constraints<false,asn::span<1,  maxCellineNB >>;

};
/*
MeasurementFailureCause-Item-ExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct MeasurementFailureCause_Item_ExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
MeasurementFailureCause-Item ::= SEQUENCE {
	measurementFailedReportCharacteristics			ReportCharacteristics,
	cause											Cause,
	iE-Extensions									ProtocolExtensionContainer { {MeasurementFailureCause-Item-ExtIEs} }	OPTIONAL,
	...
}
*/

struct MeasurementFailureCause_Item : asn::sequence<3, 0, true, 1>
{
	static constexpr const char* name() {return "MeasurementFailureCause-Item";}
	using parent_t = asn::sequence<3, 0, true, 1>;
	struct measurementFailedReportCharacteristics_t : ReportCharacteristics
	{
		static constexpr const char* name() {return "measurementFailedReportCharacteristics_t";}
		using parent_t = ReportCharacteristics;

	};
	measurementFailedReportCharacteristics_t& ref_measurementFailedReportCharacteristics() {return measurementFailedReportCharacteristics;}
	measurementFailedReportCharacteristics_t const& ref_measurementFailedReportCharacteristics() const {return measurementFailedReportCharacteristics;}
	struct cause_t : Cause
	{
		static constexpr const char* name() {return "cause_t";}
		using parent_t = Cause;

	};
	cause_t& ref_cause() {return cause;}
	cause_t const& ref_cause() const {return cause;}
	struct iE_Extensions_t : ProtocolExtensionContainer<MeasurementFailureCause_Item_ExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<MeasurementFailureCause_Item_ExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(measurementFailedReportCharacteristics);
		v(cause);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(measurementFailedReportCharacteristics);
		v(cause);
		v(iE_Extensions);

	};
	void clear()
	{
		measurementFailedReportCharacteristics.clear();
		cause.clear();
		iE_Extensions.clear();

	};
	private:
	measurementFailedReportCharacteristics_t	measurementFailedReportCharacteristics;
	cause_t	cause;
	iE_Extensions_t	iE_Extensions;

};
/*
MeasurementFailureCause-ItemIEs X2AP-PROTOCOL-IES ::= {
	{ ID id-MeasurementFailureCause-Item	CRITICALITY ignore	TYPE MeasurementFailureCause-Item		PRESENCE mandatory}
}
*/

struct MeasurementFailureCause_ItemIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, false>
	{
		size_t get_index() const {return type;}
		void clear() {type = 0;}
		void select_id_MeasurementFailureCause_Item() { set(id_MeasurementFailureCause_Item); type=1;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_MeasurementFailureCause_Item)) { type = 1; return true; }
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_MeasurementFailureCause_Item);} return false;
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, false>
	{
		size_t get_index() const {return type;}
		void clear() {type = 0;}
		void select_id_MeasurementFailureCause_Item() { set(ignore); type=1;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<false>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		MeasurementFailureCause_Item& select_id_MeasurementFailureCause_Item() { return set<MeasurementFailureCause_Item>(1); }
		MeasurementFailureCause_Item const* get_id_MeasurementFailureCause_Item() const { return get<MeasurementFailureCause_Item>(1); }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<MeasurementFailureCause_Item>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<MeasurementFailureCause_Item>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_MeasurementFailureCause_Item()); return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<MeasurementFailureCause_Item>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(MeasurementFailureCause_Item)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, false>
	{
		size_t get_index() const {return type;}
		void clear() {type = 0;}
		void select_id_MeasurementFailureCause_Item() { set(mandatory); type=1;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
MeasurementFailureCause-List ::= SEQUENCE (SIZE (1..maxFailedMeasObjects)) OF ProtocolIE-Single-Container { {MeasurementFailureCause-ItemIEs} }
*/

struct MeasurementFailureCause_List_elm : ProtocolIE_Single_Container<MeasurementFailureCause_ItemIEs>
{
	static constexpr const char* name() {return "MeasurementFailureCause_List_elm";}
	using parent_t = ProtocolIE_Single_Container<MeasurementFailureCause_ItemIEs>;

};
struct MeasurementFailureCause_List : asn::sequenceof<MeasurementFailureCause_List_elm>
{
	static constexpr const char* name() {return "MeasurementFailureCause-List";}
	using parent_t = asn::sequenceof<MeasurementFailureCause_List_elm>;
	using constraint_t = asn::constraints<false,asn::span<1,  maxFailedMeasObjects >>;

};
/*
CompleteFailureCauseInformation-Item-ExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct CompleteFailureCauseInformation_Item_ExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
CompleteFailureCauseInformation-Item ::= SEQUENCE {
	cell-ID											ECGI,
	measurementFailureCause-List					MeasurementFailureCause-List,
	iE-Extensions									ProtocolExtensionContainer { {CompleteFailureCauseInformation-Item-ExtIEs} }	OPTIONAL,
	...
}
*/

struct CompleteFailureCauseInformation_Item : asn::sequence<3, 0, true, 1>
{
	static constexpr const char* name() {return "CompleteFailureCauseInformation-Item";}
	using parent_t = asn::sequence<3, 0, true, 1>;
	struct cell_ID_t : ECGI
	{
		static constexpr const char* name() {return "cell_ID_t";}
		using parent_t = ECGI;

	};
	cell_ID_t& ref_cell_ID() {return cell_ID;}
	cell_ID_t const& ref_cell_ID() const {return cell_ID;}
	struct measurementFailureCause_List_t : MeasurementFailureCause_List
	{
		static constexpr const char* name() {return "measurementFailureCause_List_t";}
		using parent_t = MeasurementFailureCause_List;

	};
	measurementFailureCause_List_t& ref_measurementFailureCause_List() {return measurementFailureCause_List;}
	measurementFailureCause_List_t const& ref_measurementFailureCause_List() const {return measurementFailureCause_List;}
	struct iE_Extensions_t : ProtocolExtensionContainer<CompleteFailureCauseInformation_Item_ExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<CompleteFailureCauseInformation_Item_ExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(cell_ID);
		v(measurementFailureCause_List);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(cell_ID);
		v(measurementFailureCause_List);
		v(iE_Extensions);

	};
	void clear()
	{
		cell_ID.clear();
		measurementFailureCause_List.clear();
		iE_Extensions.clear();

	};
	private:
	cell_ID_t	cell_ID;
	measurementFailureCause_List_t	measurementFailureCause_List;
	iE_Extensions_t	iE_Extensions;

};
/*
CompleteFailureCauseInformation-ItemIEs X2AP-PROTOCOL-IES ::= {
	{ ID id-CompleteFailureCauseInformation-Item	CRITICALITY ignore	TYPE CompleteFailureCauseInformation-Item	PRESENCE mandatory}
}
*/

struct CompleteFailureCauseInformation_ItemIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, false>
	{
		size_t get_index() const {return type;}
		void clear() {type = 0;}
		void select_id_CompleteFailureCauseInformation_Item() { set(id_CompleteFailureCauseInformation_Item); type=1;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_CompleteFailureCauseInformation_Item)) { type = 1; return true; }
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_CompleteFailureCauseInformation_Item);} return false;
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, false>
	{
		size_t get_index() const {return type;}
		void clear() {type = 0;}
		void select_id_CompleteFailureCauseInformation_Item() { set(ignore); type=1;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<false>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		CompleteFailureCauseInformation_Item& select_id_CompleteFailureCauseInformation_Item() { return set<CompleteFailureCauseInformation_Item>(1); }
		CompleteFailureCauseInformation_Item const* get_id_CompleteFailureCauseInformation_Item() const { return get<CompleteFailureCauseInformation_Item>(1); }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<CompleteFailureCauseInformation_Item>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<CompleteFailureCauseInformation_Item>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_CompleteFailureCauseInformation_Item()); return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<CompleteFailureCauseInformation_Item>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(CompleteFailureCauseInformation_Item)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, false>
	{
		size_t get_index() const {return type;}
		void clear() {type = 0;}
		void select_id_CompleteFailureCauseInformation_Item() { set(mandatory); type=1;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
CompleteFailureCauseInformation-List ::= SEQUENCE (SIZE (1..maxCellineNB)) OF ProtocolIE-Single-Container { {CompleteFailureCauseInformation-ItemIEs} }
*/

struct CompleteFailureCauseInformation_List_elm : ProtocolIE_Single_Container<CompleteFailureCauseInformation_ItemIEs>
{
	static constexpr const char* name() {return "CompleteFailureCauseInformation_List_elm";}
	using parent_t = ProtocolIE_Single_Container<CompleteFailureCauseInformation_ItemIEs>;

};
struct CompleteFailureCauseInformation_List : asn::sequenceof<CompleteFailureCauseInformation_List_elm>
{
	static constexpr const char* name() {return "CompleteFailureCauseInformation-List";}
	using parent_t = asn::sequenceof<CompleteFailureCauseInformation_List_elm>;
	using constraint_t = asn::constraints<false,asn::span<1,  maxCellineNB >>;

};
/*
E-RABs-DataForwardingAddress-ItemExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct E_RABs_DataForwardingAddress_ItemExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-DataForwardingAddress-Item ::= SEQUENCE {
	e-RAB-ID						E-RAB-ID,
	dl-GTPtunnelEndpoint			GTPtunnelEndpoint,
	iE-Extensions					ProtocolExtensionContainer { {E-RABs-DataForwardingAddress-ItemExtIEs} } OPTIONAL,
	...
}
*/

struct E_RABs_DataForwardingAddress_Item : asn::sequence<3, 0, true, 1>
{
	static constexpr const char* name() {return "E-RABs-DataForwardingAddress-Item";}
	using parent_t = asn::sequence<3, 0, true, 1>;
	struct e_RAB_ID_t : E_RAB_ID
	{
		static constexpr const char* name() {return "e_RAB_ID_t";}
		using parent_t = E_RAB_ID;

	};
	e_RAB_ID_t& ref_e_RAB_ID() {return e_RAB_ID;}
	e_RAB_ID_t const& ref_e_RAB_ID() const {return e_RAB_ID;}
	struct dl_GTPtunnelEndpoint_t : GTPtunnelEndpoint
	{
		static constexpr const char* name() {return "dl_GTPtunnelEndpoint_t";}
		using parent_t = GTPtunnelEndpoint;

	};
	dl_GTPtunnelEndpoint_t& ref_dl_GTPtunnelEndpoint() {return dl_GTPtunnelEndpoint;}
	dl_GTPtunnelEndpoint_t const& ref_dl_GTPtunnelEndpoint() const {return dl_GTPtunnelEndpoint;}
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_DataForwardingAddress_ItemExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_DataForwardingAddress_ItemExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(e_RAB_ID);
		v(dl_GTPtunnelEndpoint);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(e_RAB_ID);
		v(dl_GTPtunnelEndpoint);
		v(iE_Extensions);

	};
	void clear()
	{
		e_RAB_ID.clear();
		dl_GTPtunnelEndpoint.clear();
		iE_Extensions.clear();

	};
	private:
	e_RAB_ID_t	e_RAB_ID;
	dl_GTPtunnelEndpoint_t	dl_GTPtunnelEndpoint;
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-DataForwardingAddress-ItemIEs	X2AP-PROTOCOL-IES ::= {
	{ ID id-E-RABs-DataForwardingAddress-Item	CRITICALITY ignore	TYPE E-RABs-DataForwardingAddress-Item	PRESENCE mandatory},
	...
}
*/

struct E_RABs_DataForwardingAddress_ItemIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_DataForwardingAddress_Item() { set(id_E_RABs_DataForwardingAddress_Item); type=1;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_E_RABs_DataForwardingAddress_Item)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_E_RABs_DataForwardingAddress_Item);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_DataForwardingAddress_Item() { set(ignore); type=1;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		E_RABs_DataForwardingAddress_Item& select_id_E_RABs_DataForwardingAddress_Item() { return set<E_RABs_DataForwardingAddress_Item>(1); }
		E_RABs_DataForwardingAddress_Item const* get_id_E_RABs_DataForwardingAddress_Item() const { return get<E_RABs_DataForwardingAddress_Item>(1); }
		bool is_unknown() const { return type == 2; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<E_RABs_DataForwardingAddress_Item>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<E_RABs_DataForwardingAddress_Item>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_E_RABs_DataForwardingAddress_Item()); return true;
			case 2: if(type != 2) {clear(); asn::base::set();} type = 2; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<E_RABs_DataForwardingAddress_Item>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(E_RABs_DataForwardingAddress_Item)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_DataForwardingAddress_Item() { set(mandatory); type=1;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-DataForwardingAddress-List ::= SEQUENCE (SIZE(1..maxnoofBearers)) OF ProtocolIE-Single-Container { {E-RABs-DataForwardingAddress-ItemIEs} }
*/

struct E_RABs_DataForwardingAddress_List_elm : ProtocolIE_Single_Container<E_RABs_DataForwardingAddress_ItemIEs>
{
	static constexpr const char* name() {return "E_RABs_DataForwardingAddress_List_elm";}
	using parent_t = ProtocolIE_Single_Container<E_RABs_DataForwardingAddress_ItemIEs>;

};
struct E_RABs_DataForwardingAddress_List : asn::sequenceof<E_RABs_DataForwardingAddress_List_elm>
{
	static constexpr const char* name() {return "E-RABs-DataForwardingAddress-List";}
	using parent_t = asn::sequenceof<E_RABs_DataForwardingAddress_List_elm>;
	using constraint_t = asn::constraints<false,asn::span<1,  maxnoofBearers >>;

};
/*
DataForwardingAddressIndication-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-New-eNB-UE-X2AP-ID-Extension		CRITICALITY ignore	TYPE UE-X2AP-ID-Extension						PRESENCE optional }|
	{ ID id-Old-eNB-UE-X2AP-ID					CRITICALITY ignore	TYPE UE-X2AP-ID									PRESENCE mandatory}|
	{ ID id-Old-eNB-UE-X2AP-ID-Extension		CRITICALITY ignore	TYPE UE-X2AP-ID-Extension						PRESENCE optional }|
	{ ID id-E-RABs-DataForwardingAddress-List	CRITICALITY ignore	TYPE E-RABs-DataForwardingAddress-List		PRESENCE mandatory},
	...
}
*/

struct DataForwardingAddressIndication_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 5; }
		void clear() {type = 0;}
		void select_id_New_eNB_UE_X2AP_ID_Extension() { set(id_New_eNB_UE_X2AP_ID_Extension); type=1;}
		void select_id_Old_eNB_UE_X2AP_ID() { set(id_Old_eNB_UE_X2AP_ID); type=2;}
		void select_id_Old_eNB_UE_X2AP_ID_Extension() { set(id_Old_eNB_UE_X2AP_ID_Extension); type=3;}
		void select_id_E_RABs_DataForwardingAddress_List() { set(id_E_RABs_DataForwardingAddress_List); type=4;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_New_eNB_UE_X2AP_ID_Extension)) { type = 1; return true; }
			else if(equal(id_Old_eNB_UE_X2AP_ID)) { type = 2; return true; }
			else if(equal(id_Old_eNB_UE_X2AP_ID_Extension)) { type = 3; return true; }
			else if(equal(id_E_RABs_DataForwardingAddress_List)) { type = 4; return true; }
			else { type = 5; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_New_eNB_UE_X2AP_ID_Extension);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_Old_eNB_UE_X2AP_ID);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_Old_eNB_UE_X2AP_ID_Extension);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(id_E_RABs_DataForwardingAddress_List);} return false;
			case 5: type = 5; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 5; }
		void clear() {type = 0;}
		void select_id_New_eNB_UE_X2AP_ID_Extension() { set(ignore); type=1;}
		void select_id_Old_eNB_UE_X2AP_ID() { set(ignore); type=2;}
		void select_id_Old_eNB_UE_X2AP_ID_Extension() { set(ignore); type=3;}
		void select_id_E_RABs_DataForwardingAddress_List() { set(ignore); type=4;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else if(equal(ignore)) { type = 2; return true; }
			else if(equal(ignore)) { type = 3; return true; }
			else if(equal(ignore)) { type = 4; return true; }
			else { type = 5; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(ignore);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(ignore);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(ignore);} return false;
			case 5: type = 5; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		UE_X2AP_ID_Extension& select_id_New_eNB_UE_X2AP_ID_Extension() { return set<UE_X2AP_ID_Extension>(1); }
		UE_X2AP_ID_Extension const* get_id_New_eNB_UE_X2AP_ID_Extension() const { return get<UE_X2AP_ID_Extension>(1); }
		UE_X2AP_ID& select_id_Old_eNB_UE_X2AP_ID() { return set<UE_X2AP_ID>(2); }
		UE_X2AP_ID const* get_id_Old_eNB_UE_X2AP_ID() const { return get<UE_X2AP_ID>(2); }
		UE_X2AP_ID_Extension& select_id_Old_eNB_UE_X2AP_ID_Extension() { return set<UE_X2AP_ID_Extension>(3); }
		UE_X2AP_ID_Extension const* get_id_Old_eNB_UE_X2AP_ID_Extension() const { return get<UE_X2AP_ID_Extension>(3); }
		E_RABs_DataForwardingAddress_List& select_id_E_RABs_DataForwardingAddress_List() { return set<E_RABs_DataForwardingAddress_List>(4); }
		E_RABs_DataForwardingAddress_List const* get_id_E_RABs_DataForwardingAddress_List() const { return get<E_RABs_DataForwardingAddress_List>(4); }
		bool is_unknown() const { return type == 5; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<UE_X2AP_ID_Extension>(); break;
			case 2: var.destroy<UE_X2AP_ID>(); break;
			case 3: var.destroy<UE_X2AP_ID_Extension>(); break;
			case 4: var.destroy<E_RABs_DataForwardingAddress_List>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<UE_X2AP_ID_Extension>(1);
			v.template operator()<UE_X2AP_ID>(2);
			v.template operator()<UE_X2AP_ID_Extension>(3);
			v.template operator()<E_RABs_DataForwardingAddress_List>(4);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_New_eNB_UE_X2AP_ID_Extension()); return true;
			case 2: v(select_id_Old_eNB_UE_X2AP_ID()); return true;
			case 3: v(select_id_Old_eNB_UE_X2AP_ID_Extension()); return true;
			case 4: v(select_id_E_RABs_DataForwardingAddress_List()); return true;
			case 5: if(type != 5) {clear(); asn::base::set();} type = 5; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<UE_X2AP_ID_Extension>()); return true;
			case 2: v(var.as<UE_X2AP_ID>()); return true;
			case 3: v(var.as<UE_X2AP_ID_Extension>()); return true;
			case 4: v(var.as<E_RABs_DataForwardingAddress_List>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(E_RABs_DataForwardingAddress_List)];
			char dummy2[sizeof(UE_X2AP_ID)];
			char dummy3[sizeof(UE_X2AP_ID_Extension)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 5; }
		void clear() {type = 0;}
		void select_id_New_eNB_UE_X2AP_ID_Extension() { set(optional); type=1;}
		void select_id_Old_eNB_UE_X2AP_ID() { set(mandatory); type=2;}
		void select_id_Old_eNB_UE_X2AP_ID_Extension() { set(optional); type=3;}
		void select_id_E_RABs_DataForwardingAddress_List() { set(mandatory); type=4;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(optional)) { type = 1; return true; }
			else if(equal(mandatory)) { type = 2; return true; }
			else if(equal(optional)) { type = 3; return true; }
			else if(equal(mandatory)) { type = 4; return true; }
			else { type = 5; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(optional);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(optional);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 5: type = 5; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
DataForwardingAddressIndication ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{DataForwardingAddressIndication-IEs}},
	...
}
*/

struct DataForwardingAddressIndication : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "DataForwardingAddressIndication";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<DataForwardingAddressIndication_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<DataForwardingAddressIndication_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
E-RABs-Admitted-Item-ExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct E_RABs_Admitted_Item_ExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-Admitted-Item ::= SEQUENCE {
	e-RAB-ID					E-RAB-ID,
	uL-GTP-TunnelEndpoint			GTPtunnelEndpoint	OPTIONAL,
	dL-GTP-TunnelEndpoint			GTPtunnelEndpoint	OPTIONAL,
	iE-Extensions					ProtocolExtensionContainer { {E-RABs-Admitted-Item-ExtIEs} }	OPTIONAL,
	...
}
*/

struct E_RABs_Admitted_Item : asn::sequence<4, 0, true, 3>
{
	static constexpr const char* name() {return "E-RABs-Admitted-Item";}
	using parent_t = asn::sequence<4, 0, true, 3>;
	struct e_RAB_ID_t : E_RAB_ID
	{
		static constexpr const char* name() {return "e_RAB_ID_t";}
		using parent_t = E_RAB_ID;

	};
	e_RAB_ID_t& ref_e_RAB_ID() {return e_RAB_ID;}
	e_RAB_ID_t const& ref_e_RAB_ID() const {return e_RAB_ID;}
	struct uL_GTP_TunnelEndpoint_t : GTPtunnelEndpoint
	{
		static constexpr const char* name() {return "uL_GTP_TunnelEndpoint_t";}
		using parent_t = GTPtunnelEndpoint;
		static constexpr bool optional = true;

	};
	uL_GTP_TunnelEndpoint_t& set_uL_GTP_TunnelEndpoint() { uL_GTP_TunnelEndpoint.setpresent(true); return uL_GTP_TunnelEndpoint;}
	uL_GTP_TunnelEndpoint_t const* get_uL_GTP_TunnelEndpoint() const {return uL_GTP_TunnelEndpoint.is_valid() ? &uL_GTP_TunnelEndpoint : nullptr;}
	struct dL_GTP_TunnelEndpoint_t : GTPtunnelEndpoint
	{
		static constexpr const char* name() {return "dL_GTP_TunnelEndpoint_t";}
		using parent_t = GTPtunnelEndpoint;
		static constexpr bool optional = true;

	};
	dL_GTP_TunnelEndpoint_t& set_dL_GTP_TunnelEndpoint() { dL_GTP_TunnelEndpoint.setpresent(true); return dL_GTP_TunnelEndpoint;}
	dL_GTP_TunnelEndpoint_t const* get_dL_GTP_TunnelEndpoint() const {return dL_GTP_TunnelEndpoint.is_valid() ? &dL_GTP_TunnelEndpoint : nullptr;}
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_Admitted_Item_ExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_Admitted_Item_ExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(e_RAB_ID);
		v(uL_GTP_TunnelEndpoint);
		v(dL_GTP_TunnelEndpoint);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(e_RAB_ID);
		v(uL_GTP_TunnelEndpoint);
		v(dL_GTP_TunnelEndpoint);
		v(iE_Extensions);

	};
	void clear()
	{
		e_RAB_ID.clear();
		uL_GTP_TunnelEndpoint.clear();
		dL_GTP_TunnelEndpoint.clear();
		iE_Extensions.clear();

	};
	private:
	e_RAB_ID_t	e_RAB_ID;
	uL_GTP_TunnelEndpoint_t	uL_GTP_TunnelEndpoint;
	dL_GTP_TunnelEndpoint_t	dL_GTP_TunnelEndpoint;
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-Admitted-ItemIEs X2AP-PROTOCOL-IES ::= {
	{ ID id-E-RABs-Admitted-Item	CRITICALITY ignore	TYPE E-RABs-Admitted-Item 	PRESENCE mandatory	}
}
*/

struct E_RABs_Admitted_ItemIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, false>
	{
		size_t get_index() const {return type;}
		void clear() {type = 0;}
		void select_id_E_RABs_Admitted_Item() { set(id_E_RABs_Admitted_Item); type=1;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_E_RABs_Admitted_Item)) { type = 1; return true; }
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_E_RABs_Admitted_Item);} return false;
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, false>
	{
		size_t get_index() const {return type;}
		void clear() {type = 0;}
		void select_id_E_RABs_Admitted_Item() { set(ignore); type=1;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<false>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		E_RABs_Admitted_Item& select_id_E_RABs_Admitted_Item() { return set<E_RABs_Admitted_Item>(1); }
		E_RABs_Admitted_Item const* get_id_E_RABs_Admitted_Item() const { return get<E_RABs_Admitted_Item>(1); }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<E_RABs_Admitted_Item>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<E_RABs_Admitted_Item>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_E_RABs_Admitted_Item()); return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<E_RABs_Admitted_Item>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(E_RABs_Admitted_Item)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, false>
	{
		size_t get_index() const {return type;}
		void clear() {type = 0;}
		void select_id_E_RABs_Admitted_Item() { set(mandatory); type=1;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-Admitted-List 		::= SEQUENCE (SIZE (1..maxnoofBearers)) OF ProtocolIE-Single-Container { {E-RABs-Admitted-ItemIEs} }
*/

struct E_RABs_Admitted_List_elm : ProtocolIE_Single_Container<E_RABs_Admitted_ItemIEs>
{
	static constexpr const char* name() {return "E_RABs_Admitted_List_elm";}
	using parent_t = ProtocolIE_Single_Container<E_RABs_Admitted_ItemIEs>;

};
struct E_RABs_Admitted_List : asn::sequenceof<E_RABs_Admitted_List_elm>
{
	static constexpr const char* name() {return "E-RABs-Admitted-List";}
	using parent_t = asn::sequenceof<E_RABs_Admitted_List_elm>;
	using constraint_t = asn::constraints<false,asn::span<1,  maxnoofBearers >>;

};
/*
E-RABs-Admitted-ToBeAdded-Item-SCG-BearerExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct E_RABs_Admitted_ToBeAdded_Item_SCG_BearerExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-Admitted-ToBeAdded-Item-SCG-Bearer ::= SEQUENCE {
	e-RAB-ID								E-RAB-ID,
	s1-DL-GTPtunnelEndpoint					GTPtunnelEndpoint,
	dL-Forwarding-GTPtunnelEndpoint			GTPtunnelEndpoint																	OPTIONAL,
	uL-Forwarding-GTPtunnelEndpoint			GTPtunnelEndpoint																	OPTIONAL,
	iE-Extensions					ProtocolExtensionContainer { {E-RABs-Admitted-ToBeAdded-Item-SCG-BearerExtIEs} }	OPTIONAL,
	...
}
*/

struct E_RABs_Admitted_ToBeAdded_Item_SCG_Bearer : asn::sequence<5, 0, true, 3>
{
	static constexpr const char* name() {return "E-RABs-Admitted-ToBeAdded-Item-SCG-Bearer";}
	using parent_t = asn::sequence<5, 0, true, 3>;
	struct e_RAB_ID_t : E_RAB_ID
	{
		static constexpr const char* name() {return "e_RAB_ID_t";}
		using parent_t = E_RAB_ID;

	};
	e_RAB_ID_t& ref_e_RAB_ID() {return e_RAB_ID;}
	e_RAB_ID_t const& ref_e_RAB_ID() const {return e_RAB_ID;}
	struct s1_DL_GTPtunnelEndpoint_t : GTPtunnelEndpoint
	{
		static constexpr const char* name() {return "s1_DL_GTPtunnelEndpoint_t";}
		using parent_t = GTPtunnelEndpoint;

	};
	s1_DL_GTPtunnelEndpoint_t& ref_s1_DL_GTPtunnelEndpoint() {return s1_DL_GTPtunnelEndpoint;}
	s1_DL_GTPtunnelEndpoint_t const& ref_s1_DL_GTPtunnelEndpoint() const {return s1_DL_GTPtunnelEndpoint;}
	struct dL_Forwarding_GTPtunnelEndpoint_t : GTPtunnelEndpoint
	{
		static constexpr const char* name() {return "dL_Forwarding_GTPtunnelEndpoint_t";}
		using parent_t = GTPtunnelEndpoint;
		static constexpr bool optional = true;

	};
	dL_Forwarding_GTPtunnelEndpoint_t& set_dL_Forwarding_GTPtunnelEndpoint() { dL_Forwarding_GTPtunnelEndpoint.setpresent(true); return dL_Forwarding_GTPtunnelEndpoint;}
	dL_Forwarding_GTPtunnelEndpoint_t const* get_dL_Forwarding_GTPtunnelEndpoint() const {return dL_Forwarding_GTPtunnelEndpoint.is_valid() ? &dL_Forwarding_GTPtunnelEndpoint : nullptr;}
	struct uL_Forwarding_GTPtunnelEndpoint_t : GTPtunnelEndpoint
	{
		static constexpr const char* name() {return "uL_Forwarding_GTPtunnelEndpoint_t";}
		using parent_t = GTPtunnelEndpoint;
		static constexpr bool optional = true;

	};
	uL_Forwarding_GTPtunnelEndpoint_t& set_uL_Forwarding_GTPtunnelEndpoint() { uL_Forwarding_GTPtunnelEndpoint.setpresent(true); return uL_Forwarding_GTPtunnelEndpoint;}
	uL_Forwarding_GTPtunnelEndpoint_t const* get_uL_Forwarding_GTPtunnelEndpoint() const {return uL_Forwarding_GTPtunnelEndpoint.is_valid() ? &uL_Forwarding_GTPtunnelEndpoint : nullptr;}
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_Admitted_ToBeAdded_Item_SCG_BearerExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_Admitted_ToBeAdded_Item_SCG_BearerExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(e_RAB_ID);
		v(s1_DL_GTPtunnelEndpoint);
		v(dL_Forwarding_GTPtunnelEndpoint);
		v(uL_Forwarding_GTPtunnelEndpoint);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(e_RAB_ID);
		v(s1_DL_GTPtunnelEndpoint);
		v(dL_Forwarding_GTPtunnelEndpoint);
		v(uL_Forwarding_GTPtunnelEndpoint);
		v(iE_Extensions);

	};
	void clear()
	{
		e_RAB_ID.clear();
		s1_DL_GTPtunnelEndpoint.clear();
		dL_Forwarding_GTPtunnelEndpoint.clear();
		uL_Forwarding_GTPtunnelEndpoint.clear();
		iE_Extensions.clear();

	};
	private:
	e_RAB_ID_t	e_RAB_ID;
	s1_DL_GTPtunnelEndpoint_t	s1_DL_GTPtunnelEndpoint;
	dL_Forwarding_GTPtunnelEndpoint_t	dL_Forwarding_GTPtunnelEndpoint;
	uL_Forwarding_GTPtunnelEndpoint_t	uL_Forwarding_GTPtunnelEndpoint;
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-Admitted-ToBeAdded-Item-Split-BearerExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct E_RABs_Admitted_ToBeAdded_Item_Split_BearerExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-Admitted-ToBeAdded-Item-Split-Bearer ::= SEQUENCE {
	e-RAB-ID						E-RAB-ID,
	seNB-GTPtunnelEndpoint			GTPtunnelEndpoint,
	iE-Extensions					ProtocolExtensionContainer { {E-RABs-Admitted-ToBeAdded-Item-Split-BearerExtIEs} } OPTIONAL,
	...
}
*/

struct E_RABs_Admitted_ToBeAdded_Item_Split_Bearer : asn::sequence<3, 0, true, 1>
{
	static constexpr const char* name() {return "E-RABs-Admitted-ToBeAdded-Item-Split-Bearer";}
	using parent_t = asn::sequence<3, 0, true, 1>;
	struct e_RAB_ID_t : E_RAB_ID
	{
		static constexpr const char* name() {return "e_RAB_ID_t";}
		using parent_t = E_RAB_ID;

	};
	e_RAB_ID_t& ref_e_RAB_ID() {return e_RAB_ID;}
	e_RAB_ID_t const& ref_e_RAB_ID() const {return e_RAB_ID;}
	struct seNB_GTPtunnelEndpoint_t : GTPtunnelEndpoint
	{
		static constexpr const char* name() {return "seNB_GTPtunnelEndpoint_t";}
		using parent_t = GTPtunnelEndpoint;

	};
	seNB_GTPtunnelEndpoint_t& ref_seNB_GTPtunnelEndpoint() {return seNB_GTPtunnelEndpoint;}
	seNB_GTPtunnelEndpoint_t const& ref_seNB_GTPtunnelEndpoint() const {return seNB_GTPtunnelEndpoint;}
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_Admitted_ToBeAdded_Item_Split_BearerExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_Admitted_ToBeAdded_Item_Split_BearerExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(e_RAB_ID);
		v(seNB_GTPtunnelEndpoint);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(e_RAB_ID);
		v(seNB_GTPtunnelEndpoint);
		v(iE_Extensions);

	};
	void clear()
	{
		e_RAB_ID.clear();
		seNB_GTPtunnelEndpoint.clear();
		iE_Extensions.clear();

	};
	private:
	e_RAB_ID_t	e_RAB_ID;
	seNB_GTPtunnelEndpoint_t	seNB_GTPtunnelEndpoint;
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-Admitted-ToBeAdded-Item ::= CHOICE {
	sCG-Bearer		E-RABs-Admitted-ToBeAdded-Item-SCG-Bearer,
	split-Bearer	E-RABs-Admitted-ToBeAdded-Item-Split-Bearer,
	...
}
*/

struct E_RABs_Admitted_ToBeAdded_Item : asn::choice<2, 0, true>
{
	static constexpr const char* name() {return "E-RABs-Admitted-ToBeAdded-Item";}
	using parent_t = asn::choice<2, 0, true>;
	index_type get_index() const {return index;}
	bool is_unknown() const {return index == 3;}
	void set_unknown() { set_index(3);  }
	~E_RABs_Admitted_ToBeAdded_Item() {clear();}
	struct sCG_Bearer_t : E_RABs_Admitted_ToBeAdded_Item_SCG_Bearer
	{
		static constexpr const char* name() {return "sCG_Bearer_t";}
		using parent_t = E_RABs_Admitted_ToBeAdded_Item_SCG_Bearer;

	};
	struct split_Bearer_t : E_RABs_Admitted_ToBeAdded_Item_Split_Bearer
	{
		static constexpr const char* name() {return "split_Bearer_t";}
		using parent_t = E_RABs_Admitted_ToBeAdded_Item_Split_Bearer;

	};
	void clear()
	{
		switch(get_index())
		{
		case 1: var.destroy<sCG_Bearer_t>(); break;
		case 2: var.destroy<split_Bearer_t>(); break;
		}
		index = 0;
		base::clear();
	}
	template<typename V> bool decode(size_t idx, V& v)
	{
		clear();
		switch(idx)
		{
		case 1: set_index(1); return v(var.build<sCG_Bearer_t>());
		case 2: set_index(2); return v(var.build<split_Bearer_t>());
		}
		return false;

	}
	template<typename V> bool encode(V& v) const
	{
		switch(get_index())
		{
		case 1: return v(var.as<sCG_Bearer_t>());
		case 2: return v(var.as<split_Bearer_t>());
		}
		return false;
	}
	template<typename V> static inline void enumerate(V& v)
	{
		v.template operator()<sCG_Bearer_t>(1);
		v.template operator()<split_Bearer_t>(2);

	}
	sCG_Bearer_t& select_sCG_Bearer() { if(get_index() != 1) { clear(); set_index(1); return var.build<sCG_Bearer_t>();} return var.as<sCG_Bearer_t>();}
	sCG_Bearer_t const* get_sCG_Bearer() const { if(get_index() == 1) { return &var.as<sCG_Bearer_t>();} return nullptr; }
	split_Bearer_t& select_split_Bearer() { if(get_index() != 2) { clear(); set_index(2); return var.build<split_Bearer_t>();} return var.as<split_Bearer_t>();}
	split_Bearer_t const* get_split_Bearer() const { if(get_index() == 2) { return &var.as<split_Bearer_t>();} return nullptr; }
	private:
	void set_index(index_type i) {index = i; base::set();}
	union union_type
	{
		char dummy1[sizeof(sCG_Bearer_t)];
		char dummy2[sizeof(split_Bearer_t)];

	};
	asn::variant<sizeof(union_type)>	var;
	index_type	index {0};
};
/*
E-RABs-Admitted-ToBeAdded-ItemIEs X2AP-PROTOCOL-IES ::= {
	{ ID id-E-RABs-Admitted-ToBeAdded-Item	CRITICALITY ignore	TYPE E-RABs-Admitted-ToBeAdded-Item 		PRESENCE mandatory}
}
*/

struct E_RABs_Admitted_ToBeAdded_ItemIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, false>
	{
		size_t get_index() const {return type;}
		void clear() {type = 0;}
		void select_id_E_RABs_Admitted_ToBeAdded_Item() { set(id_E_RABs_Admitted_ToBeAdded_Item); type=1;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_E_RABs_Admitted_ToBeAdded_Item)) { type = 1; return true; }
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_E_RABs_Admitted_ToBeAdded_Item);} return false;
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, false>
	{
		size_t get_index() const {return type;}
		void clear() {type = 0;}
		void select_id_E_RABs_Admitted_ToBeAdded_Item() { set(ignore); type=1;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<false>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		E_RABs_Admitted_ToBeAdded_Item& select_id_E_RABs_Admitted_ToBeAdded_Item() { return set<E_RABs_Admitted_ToBeAdded_Item>(1); }
		E_RABs_Admitted_ToBeAdded_Item const* get_id_E_RABs_Admitted_ToBeAdded_Item() const { return get<E_RABs_Admitted_ToBeAdded_Item>(1); }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<E_RABs_Admitted_ToBeAdded_Item>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<E_RABs_Admitted_ToBeAdded_Item>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_E_RABs_Admitted_ToBeAdded_Item()); return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<E_RABs_Admitted_ToBeAdded_Item>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(E_RABs_Admitted_ToBeAdded_Item)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, false>
	{
		size_t get_index() const {return type;}
		void clear() {type = 0;}
		void select_id_E_RABs_Admitted_ToBeAdded_Item() { set(mandatory); type=1;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-Admitted-ToBeAdded-List ::= SEQUENCE (SIZE (1..maxnoofBearers)) OF ProtocolIE-Single-Container { {E-RABs-Admitted-ToBeAdded-ItemIEs} }
*/

struct E_RABs_Admitted_ToBeAdded_List_elm : ProtocolIE_Single_Container<E_RABs_Admitted_ToBeAdded_ItemIEs>
{
	static constexpr const char* name() {return "E_RABs_Admitted_ToBeAdded_List_elm";}
	using parent_t = ProtocolIE_Single_Container<E_RABs_Admitted_ToBeAdded_ItemIEs>;

};
struct E_RABs_Admitted_ToBeAdded_List : asn::sequenceof<E_RABs_Admitted_ToBeAdded_List_elm>
{
	static constexpr const char* name() {return "E-RABs-Admitted-ToBeAdded-List";}
	using parent_t = asn::sequenceof<E_RABs_Admitted_ToBeAdded_List_elm>;
	using constraint_t = asn::constraints<false,asn::span<1,  maxnoofBearers >>;

};
/*
E-RABs-Admitted-ToBeAdded-ModAckItem-SCG-BearerExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct E_RABs_Admitted_ToBeAdded_ModAckItem_SCG_BearerExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-Admitted-ToBeAdded-ModAckItem-SCG-Bearer ::= SEQUENCE {
	e-RAB-ID								E-RAB-ID,
	s1-DL-GTPtunnelEndpoint					GTPtunnelEndpoint,
	dL-Forwarding-GTPtunnelEndpoint			GTPtunnelEndpoint																	OPTIONAL,
	uL-Forwarding-GTPtunnelEndpoint			GTPtunnelEndpoint																	OPTIONAL,
	iE-Extensions					ProtocolExtensionContainer { {E-RABs-Admitted-ToBeAdded-ModAckItem-SCG-BearerExtIEs} }	OPTIONAL,
	...
}
*/

struct E_RABs_Admitted_ToBeAdded_ModAckItem_SCG_Bearer : asn::sequence<5, 0, true, 3>
{
	static constexpr const char* name() {return "E-RABs-Admitted-ToBeAdded-ModAckItem-SCG-Bearer";}
	using parent_t = asn::sequence<5, 0, true, 3>;
	struct e_RAB_ID_t : E_RAB_ID
	{
		static constexpr const char* name() {return "e_RAB_ID_t";}
		using parent_t = E_RAB_ID;

	};
	e_RAB_ID_t& ref_e_RAB_ID() {return e_RAB_ID;}
	e_RAB_ID_t const& ref_e_RAB_ID() const {return e_RAB_ID;}
	struct s1_DL_GTPtunnelEndpoint_t : GTPtunnelEndpoint
	{
		static constexpr const char* name() {return "s1_DL_GTPtunnelEndpoint_t";}
		using parent_t = GTPtunnelEndpoint;

	};
	s1_DL_GTPtunnelEndpoint_t& ref_s1_DL_GTPtunnelEndpoint() {return s1_DL_GTPtunnelEndpoint;}
	s1_DL_GTPtunnelEndpoint_t const& ref_s1_DL_GTPtunnelEndpoint() const {return s1_DL_GTPtunnelEndpoint;}
	struct dL_Forwarding_GTPtunnelEndpoint_t : GTPtunnelEndpoint
	{
		static constexpr const char* name() {return "dL_Forwarding_GTPtunnelEndpoint_t";}
		using parent_t = GTPtunnelEndpoint;
		static constexpr bool optional = true;

	};
	dL_Forwarding_GTPtunnelEndpoint_t& set_dL_Forwarding_GTPtunnelEndpoint() { dL_Forwarding_GTPtunnelEndpoint.setpresent(true); return dL_Forwarding_GTPtunnelEndpoint;}
	dL_Forwarding_GTPtunnelEndpoint_t const* get_dL_Forwarding_GTPtunnelEndpoint() const {return dL_Forwarding_GTPtunnelEndpoint.is_valid() ? &dL_Forwarding_GTPtunnelEndpoint : nullptr;}
	struct uL_Forwarding_GTPtunnelEndpoint_t : GTPtunnelEndpoint
	{
		static constexpr const char* name() {return "uL_Forwarding_GTPtunnelEndpoint_t";}
		using parent_t = GTPtunnelEndpoint;
		static constexpr bool optional = true;

	};
	uL_Forwarding_GTPtunnelEndpoint_t& set_uL_Forwarding_GTPtunnelEndpoint() { uL_Forwarding_GTPtunnelEndpoint.setpresent(true); return uL_Forwarding_GTPtunnelEndpoint;}
	uL_Forwarding_GTPtunnelEndpoint_t const* get_uL_Forwarding_GTPtunnelEndpoint() const {return uL_Forwarding_GTPtunnelEndpoint.is_valid() ? &uL_Forwarding_GTPtunnelEndpoint : nullptr;}
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_Admitted_ToBeAdded_ModAckItem_SCG_BearerExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_Admitted_ToBeAdded_ModAckItem_SCG_BearerExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(e_RAB_ID);
		v(s1_DL_GTPtunnelEndpoint);
		v(dL_Forwarding_GTPtunnelEndpoint);
		v(uL_Forwarding_GTPtunnelEndpoint);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(e_RAB_ID);
		v(s1_DL_GTPtunnelEndpoint);
		v(dL_Forwarding_GTPtunnelEndpoint);
		v(uL_Forwarding_GTPtunnelEndpoint);
		v(iE_Extensions);

	};
	void clear()
	{
		e_RAB_ID.clear();
		s1_DL_GTPtunnelEndpoint.clear();
		dL_Forwarding_GTPtunnelEndpoint.clear();
		uL_Forwarding_GTPtunnelEndpoint.clear();
		iE_Extensions.clear();

	};
	private:
	e_RAB_ID_t	e_RAB_ID;
	s1_DL_GTPtunnelEndpoint_t	s1_DL_GTPtunnelEndpoint;
	dL_Forwarding_GTPtunnelEndpoint_t	dL_Forwarding_GTPtunnelEndpoint;
	uL_Forwarding_GTPtunnelEndpoint_t	uL_Forwarding_GTPtunnelEndpoint;
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-Admitted-ToBeAdded-ModAckItem-Split-BearerExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct E_RABs_Admitted_ToBeAdded_ModAckItem_Split_BearerExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-Admitted-ToBeAdded-ModAckItem-Split-Bearer ::= SEQUENCE {
	e-RAB-ID						E-RAB-ID,
	seNB-GTPtunnelEndpoint			GTPtunnelEndpoint,
	iE-Extensions					ProtocolExtensionContainer { {E-RABs-Admitted-ToBeAdded-ModAckItem-Split-BearerExtIEs} } OPTIONAL,
	...
}
*/

struct E_RABs_Admitted_ToBeAdded_ModAckItem_Split_Bearer : asn::sequence<3, 0, true, 1>
{
	static constexpr const char* name() {return "E-RABs-Admitted-ToBeAdded-ModAckItem-Split-Bearer";}
	using parent_t = asn::sequence<3, 0, true, 1>;
	struct e_RAB_ID_t : E_RAB_ID
	{
		static constexpr const char* name() {return "e_RAB_ID_t";}
		using parent_t = E_RAB_ID;

	};
	e_RAB_ID_t& ref_e_RAB_ID() {return e_RAB_ID;}
	e_RAB_ID_t const& ref_e_RAB_ID() const {return e_RAB_ID;}
	struct seNB_GTPtunnelEndpoint_t : GTPtunnelEndpoint
	{
		static constexpr const char* name() {return "seNB_GTPtunnelEndpoint_t";}
		using parent_t = GTPtunnelEndpoint;

	};
	seNB_GTPtunnelEndpoint_t& ref_seNB_GTPtunnelEndpoint() {return seNB_GTPtunnelEndpoint;}
	seNB_GTPtunnelEndpoint_t const& ref_seNB_GTPtunnelEndpoint() const {return seNB_GTPtunnelEndpoint;}
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_Admitted_ToBeAdded_ModAckItem_Split_BearerExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_Admitted_ToBeAdded_ModAckItem_Split_BearerExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(e_RAB_ID);
		v(seNB_GTPtunnelEndpoint);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(e_RAB_ID);
		v(seNB_GTPtunnelEndpoint);
		v(iE_Extensions);

	};
	void clear()
	{
		e_RAB_ID.clear();
		seNB_GTPtunnelEndpoint.clear();
		iE_Extensions.clear();

	};
	private:
	e_RAB_ID_t	e_RAB_ID;
	seNB_GTPtunnelEndpoint_t	seNB_GTPtunnelEndpoint;
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-Admitted-ToBeAdded-ModAckItem ::= CHOICE {
	sCG-Bearer		E-RABs-Admitted-ToBeAdded-ModAckItem-SCG-Bearer,
	split-Bearer	E-RABs-Admitted-ToBeAdded-ModAckItem-Split-Bearer,
	...
}
*/

struct E_RABs_Admitted_ToBeAdded_ModAckItem : asn::choice<2, 0, true>
{
	static constexpr const char* name() {return "E-RABs-Admitted-ToBeAdded-ModAckItem";}
	using parent_t = asn::choice<2, 0, true>;
	index_type get_index() const {return index;}
	bool is_unknown() const {return index == 3;}
	void set_unknown() { set_index(3);  }
	~E_RABs_Admitted_ToBeAdded_ModAckItem() {clear();}
	struct sCG_Bearer_t : E_RABs_Admitted_ToBeAdded_ModAckItem_SCG_Bearer
	{
		static constexpr const char* name() {return "sCG_Bearer_t";}
		using parent_t = E_RABs_Admitted_ToBeAdded_ModAckItem_SCG_Bearer;

	};
	struct split_Bearer_t : E_RABs_Admitted_ToBeAdded_ModAckItem_Split_Bearer
	{
		static constexpr const char* name() {return "split_Bearer_t";}
		using parent_t = E_RABs_Admitted_ToBeAdded_ModAckItem_Split_Bearer;

	};
	void clear()
	{
		switch(get_index())
		{
		case 1: var.destroy<sCG_Bearer_t>(); break;
		case 2: var.destroy<split_Bearer_t>(); break;
		}
		index = 0;
		base::clear();
	}
	template<typename V> bool decode(size_t idx, V& v)
	{
		clear();
		switch(idx)
		{
		case 1: set_index(1); return v(var.build<sCG_Bearer_t>());
		case 2: set_index(2); return v(var.build<split_Bearer_t>());
		}
		return false;

	}
	template<typename V> bool encode(V& v) const
	{
		switch(get_index())
		{
		case 1: return v(var.as<sCG_Bearer_t>());
		case 2: return v(var.as<split_Bearer_t>());
		}
		return false;
	}
	template<typename V> static inline void enumerate(V& v)
	{
		v.template operator()<sCG_Bearer_t>(1);
		v.template operator()<split_Bearer_t>(2);

	}
	sCG_Bearer_t& select_sCG_Bearer() { if(get_index() != 1) { clear(); set_index(1); return var.build<sCG_Bearer_t>();} return var.as<sCG_Bearer_t>();}
	sCG_Bearer_t const* get_sCG_Bearer() const { if(get_index() == 1) { return &var.as<sCG_Bearer_t>();} return nullptr; }
	split_Bearer_t& select_split_Bearer() { if(get_index() != 2) { clear(); set_index(2); return var.build<split_Bearer_t>();} return var.as<split_Bearer_t>();}
	split_Bearer_t const* get_split_Bearer() const { if(get_index() == 2) { return &var.as<split_Bearer_t>();} return nullptr; }
	private:
	void set_index(index_type i) {index = i; base::set();}
	union union_type
	{
		char dummy1[sizeof(sCG_Bearer_t)];
		char dummy2[sizeof(split_Bearer_t)];

	};
	asn::variant<sizeof(union_type)>	var;
	index_type	index {0};
};
/*
E-RABs-Admitted-ToBeAdded-ModAckItemIEs X2AP-PROTOCOL-IES ::= {
	{ ID id-E-RABs-Admitted-ToBeAdded-ModAckItem	CRITICALITY ignore	TYPE E-RABs-Admitted-ToBeAdded-ModAckItem		PRESENCE mandatory}
}
*/

struct E_RABs_Admitted_ToBeAdded_ModAckItemIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, false>
	{
		size_t get_index() const {return type;}
		void clear() {type = 0;}
		void select_id_E_RABs_Admitted_ToBeAdded_ModAckItem() { set(id_E_RABs_Admitted_ToBeAdded_ModAckItem); type=1;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_E_RABs_Admitted_ToBeAdded_ModAckItem)) { type = 1; return true; }
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_E_RABs_Admitted_ToBeAdded_ModAckItem);} return false;
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, false>
	{
		size_t get_index() const {return type;}
		void clear() {type = 0;}
		void select_id_E_RABs_Admitted_ToBeAdded_ModAckItem() { set(ignore); type=1;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<false>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		E_RABs_Admitted_ToBeAdded_ModAckItem& select_id_E_RABs_Admitted_ToBeAdded_ModAckItem() { return set<E_RABs_Admitted_ToBeAdded_ModAckItem>(1); }
		E_RABs_Admitted_ToBeAdded_ModAckItem const* get_id_E_RABs_Admitted_ToBeAdded_ModAckItem() const { return get<E_RABs_Admitted_ToBeAdded_ModAckItem>(1); }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<E_RABs_Admitted_ToBeAdded_ModAckItem>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<E_RABs_Admitted_ToBeAdded_ModAckItem>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_E_RABs_Admitted_ToBeAdded_ModAckItem()); return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<E_RABs_Admitted_ToBeAdded_ModAckItem>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(E_RABs_Admitted_ToBeAdded_ModAckItem)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, false>
	{
		size_t get_index() const {return type;}
		void clear() {type = 0;}
		void select_id_E_RABs_Admitted_ToBeAdded_ModAckItem() { set(mandatory); type=1;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-Admitted-ToBeAdded-ModAckList ::= SEQUENCE (SIZE (1..maxnoofBearers)) OF ProtocolIE-Single-Container { {E-RABs-Admitted-ToBeAdded-ModAckItemIEs} }
*/

struct E_RABs_Admitted_ToBeAdded_ModAckList_elm : ProtocolIE_Single_Container<E_RABs_Admitted_ToBeAdded_ModAckItemIEs>
{
	static constexpr const char* name() {return "E_RABs_Admitted_ToBeAdded_ModAckList_elm";}
	using parent_t = ProtocolIE_Single_Container<E_RABs_Admitted_ToBeAdded_ModAckItemIEs>;

};
struct E_RABs_Admitted_ToBeAdded_ModAckList : asn::sequenceof<E_RABs_Admitted_ToBeAdded_ModAckList_elm>
{
	static constexpr const char* name() {return "E-RABs-Admitted-ToBeAdded-ModAckList";}
	using parent_t = asn::sequenceof<E_RABs_Admitted_ToBeAdded_ModAckList_elm>;
	using constraint_t = asn::constraints<false,asn::span<1,  maxnoofBearers >>;

};
/*
E-RABs-Admitted-ToBeAdded-SgNBAddReqAck-Item-SgNBPDCPpresentExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	{ ID id-uLpDCPSnLength							CRITICALITY ignore	EXTENSION PDCPSnLength					PRESENCE optional}|
	{ ID id-dLPDCPSnLength							CRITICALITY ignore	EXTENSION PDCPSnLength					PRESENCE optional},
	...
}
*/

struct E_RABs_Admitted_ToBeAdded_SgNBAddReqAck_Item_SgNBPDCPpresentExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 3; }
		void clear() {type = 0;}
		void select_id_uLpDCPSnLength() { set(id_uLpDCPSnLength); type=1;}
		void select_id_dLPDCPSnLength() { set(id_dLPDCPSnLength); type=2;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_uLpDCPSnLength)) { type = 1; return true; }
			else if(equal(id_dLPDCPSnLength)) { type = 2; return true; }
			else { type = 3; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_uLpDCPSnLength);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_dLPDCPSnLength);} return false;
			case 3: type = 3; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 3; }
		void clear() {type = 0;}
		void select_id_uLpDCPSnLength() { set(ignore); type=1;}
		void select_id_dLPDCPSnLength() { set(ignore); type=2;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else if(equal(ignore)) { type = 2; return true; }
			else { type = 3; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(ignore);} return false;
			case 3: type = 3; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		PDCPSnLength& select_id_uLpDCPSnLength() { return set<PDCPSnLength>(1); }
		PDCPSnLength const* get_id_uLpDCPSnLength() const { return get<PDCPSnLength>(1); }
		PDCPSnLength& select_id_dLPDCPSnLength() { return set<PDCPSnLength>(2); }
		PDCPSnLength const* get_id_dLPDCPSnLength() const { return get<PDCPSnLength>(2); }
		bool is_unknown() const { return type == 3; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<PDCPSnLength>(); break;
			case 2: var.destroy<PDCPSnLength>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<PDCPSnLength>(1);
			v.template operator()<PDCPSnLength>(2);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_uLpDCPSnLength()); return true;
			case 2: v(select_id_dLPDCPSnLength()); return true;
			case 3: if(type != 3) {clear(); asn::base::set();} type = 3; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<PDCPSnLength>()); return true;
			case 2: v(var.as<PDCPSnLength>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(PDCPSnLength)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 3; }
		void clear() {type = 0;}
		void select_id_uLpDCPSnLength() { set(optional); type=1;}
		void select_id_dLPDCPSnLength() { set(optional); type=2;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(optional)) { type = 1; return true; }
			else if(equal(optional)) { type = 2; return true; }
			else { type = 3; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(optional);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(optional);} return false;
			case 3: type = 3; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-Admitted-ToBeAdded-SgNBAddReqAck-Item-SgNBPDCPpresent ::= SEQUENCE {
	s1-DL-GTPtunnelEndpoint					GTPtunnelEndpoint,
	sgNB-UL-GTP-TEIDatPDCP					GTPtunnelEndpoint																						OPTIONAL,
-- This IE shall be present if MCG resource IE in the the EN-DC Resource Configuration IE is set to present --
	rlc-Mode								RLCMode																									OPTIONAL,
-- This IE shall be present if MCG resource IE in the the EN-DC Resource Configuration IE is set to present --
	dL-Forwarding-GTPtunnelEndpoint			GTPtunnelEndpoint																						OPTIONAL,
	uL-Forwarding-GTPtunnelEndpoint			GTPtunnelEndpoint																						OPTIONAL,
	mCG-E-RAB-Level-QoS-Parameters			E-RAB-Level-QoS-Parameters																				OPTIONAL,
-- This IE shall be present if MCG resource and SCG resource IEs in the the EN-DC Resource Configuration IE are set to present and the GBR QoS Information IE is present in the Requested MCG E-RAB Level QoS Parameters IE --
	uL-Configuration							ULConfiguration																							OPTIONAL,
-- This IE shall be present if MCG resource and SCG resources IEs in the the EN-DC Resource Configuration IE are set to present --
	iE-Extensions							ProtocolExtensionContainer { {E-RABs-Admitted-ToBeAdded-SgNBAddReqAck-Item-SgNBPDCPpresentExtIEs} }			OPTIONAL,
	...
}
*/

struct E_RABs_Admitted_ToBeAdded_SgNBAddReqAck_Item_SgNBPDCPpresent : asn::sequence<8, 0, true, 7>
{
	static constexpr const char* name() {return "E-RABs-Admitted-ToBeAdded-SgNBAddReqAck-Item-SgNBPDCPpresent";}
	using parent_t = asn::sequence<8, 0, true, 7>;
	struct s1_DL_GTPtunnelEndpoint_t : GTPtunnelEndpoint
	{
		static constexpr const char* name() {return "s1_DL_GTPtunnelEndpoint_t";}
		using parent_t = GTPtunnelEndpoint;

	};
	s1_DL_GTPtunnelEndpoint_t& ref_s1_DL_GTPtunnelEndpoint() {return s1_DL_GTPtunnelEndpoint;}
	s1_DL_GTPtunnelEndpoint_t const& ref_s1_DL_GTPtunnelEndpoint() const {return s1_DL_GTPtunnelEndpoint;}
	struct sgNB_UL_GTP_TEIDatPDCP_t : GTPtunnelEndpoint
	{
		static constexpr const char* name() {return "sgNB_UL_GTP_TEIDatPDCP_t";}
		using parent_t = GTPtunnelEndpoint;
		static constexpr bool optional = true;

	};
	sgNB_UL_GTP_TEIDatPDCP_t& set_sgNB_UL_GTP_TEIDatPDCP() { sgNB_UL_GTP_TEIDatPDCP.setpresent(true); return sgNB_UL_GTP_TEIDatPDCP;}
	sgNB_UL_GTP_TEIDatPDCP_t const* get_sgNB_UL_GTP_TEIDatPDCP() const {return sgNB_UL_GTP_TEIDatPDCP.is_valid() ? &sgNB_UL_GTP_TEIDatPDCP : nullptr;}
	struct rlc_Mode_t : RLCMode
	{
		static constexpr const char* name() {return "rlc_Mode_t";}
		using parent_t = RLCMode;
		static constexpr bool optional = true;

	};
	rlc_Mode_t& set_rlc_Mode() { rlc_Mode.setpresent(true); return rlc_Mode;}
	rlc_Mode_t const* get_rlc_Mode() const {return rlc_Mode.is_valid() ? &rlc_Mode : nullptr;}
	struct dL_Forwarding_GTPtunnelEndpoint_t : GTPtunnelEndpoint
	{
		static constexpr const char* name() {return "dL_Forwarding_GTPtunnelEndpoint_t";}
		using parent_t = GTPtunnelEndpoint;
		static constexpr bool optional = true;

	};
	dL_Forwarding_GTPtunnelEndpoint_t& set_dL_Forwarding_GTPtunnelEndpoint() { dL_Forwarding_GTPtunnelEndpoint.setpresent(true); return dL_Forwarding_GTPtunnelEndpoint;}
	dL_Forwarding_GTPtunnelEndpoint_t const* get_dL_Forwarding_GTPtunnelEndpoint() const {return dL_Forwarding_GTPtunnelEndpoint.is_valid() ? &dL_Forwarding_GTPtunnelEndpoint : nullptr;}
	struct uL_Forwarding_GTPtunnelEndpoint_t : GTPtunnelEndpoint
	{
		static constexpr const char* name() {return "uL_Forwarding_GTPtunnelEndpoint_t";}
		using parent_t = GTPtunnelEndpoint;
		static constexpr bool optional = true;

	};
	uL_Forwarding_GTPtunnelEndpoint_t& set_uL_Forwarding_GTPtunnelEndpoint() { uL_Forwarding_GTPtunnelEndpoint.setpresent(true); return uL_Forwarding_GTPtunnelEndpoint;}
	uL_Forwarding_GTPtunnelEndpoint_t const* get_uL_Forwarding_GTPtunnelEndpoint() const {return uL_Forwarding_GTPtunnelEndpoint.is_valid() ? &uL_Forwarding_GTPtunnelEndpoint : nullptr;}
	struct mCG_E_RAB_Level_QoS_Parameters_t : E_RAB_Level_QoS_Parameters
	{
		static constexpr const char* name() {return "mCG_E_RAB_Level_QoS_Parameters_t";}
		using parent_t = E_RAB_Level_QoS_Parameters;
		static constexpr bool optional = true;

	};
	mCG_E_RAB_Level_QoS_Parameters_t& set_mCG_E_RAB_Level_QoS_Parameters() { mCG_E_RAB_Level_QoS_Parameters.setpresent(true); return mCG_E_RAB_Level_QoS_Parameters;}
	mCG_E_RAB_Level_QoS_Parameters_t const* get_mCG_E_RAB_Level_QoS_Parameters() const {return mCG_E_RAB_Level_QoS_Parameters.is_valid() ? &mCG_E_RAB_Level_QoS_Parameters : nullptr;}
	struct uL_Configuration_t : ULConfiguration
	{
		static constexpr const char* name() {return "uL_Configuration_t";}
		using parent_t = ULConfiguration;
		static constexpr bool optional = true;

	};
	uL_Configuration_t& set_uL_Configuration() { uL_Configuration.setpresent(true); return uL_Configuration;}
	uL_Configuration_t const* get_uL_Configuration() const {return uL_Configuration.is_valid() ? &uL_Configuration : nullptr;}
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_Admitted_ToBeAdded_SgNBAddReqAck_Item_SgNBPDCPpresentExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_Admitted_ToBeAdded_SgNBAddReqAck_Item_SgNBPDCPpresentExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(s1_DL_GTPtunnelEndpoint);
		v(sgNB_UL_GTP_TEIDatPDCP);
		v(rlc_Mode);
		v(dL_Forwarding_GTPtunnelEndpoint);
		v(uL_Forwarding_GTPtunnelEndpoint);
		v(mCG_E_RAB_Level_QoS_Parameters);
		v(uL_Configuration);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(s1_DL_GTPtunnelEndpoint);
		v(sgNB_UL_GTP_TEIDatPDCP);
		v(rlc_Mode);
		v(dL_Forwarding_GTPtunnelEndpoint);
		v(uL_Forwarding_GTPtunnelEndpoint);
		v(mCG_E_RAB_Level_QoS_Parameters);
		v(uL_Configuration);
		v(iE_Extensions);

	};
	void clear()
	{
		s1_DL_GTPtunnelEndpoint.clear();
		sgNB_UL_GTP_TEIDatPDCP.clear();
		rlc_Mode.clear();
		dL_Forwarding_GTPtunnelEndpoint.clear();
		uL_Forwarding_GTPtunnelEndpoint.clear();
		mCG_E_RAB_Level_QoS_Parameters.clear();
		uL_Configuration.clear();
		iE_Extensions.clear();

	};
	private:
	s1_DL_GTPtunnelEndpoint_t	s1_DL_GTPtunnelEndpoint;
	sgNB_UL_GTP_TEIDatPDCP_t	sgNB_UL_GTP_TEIDatPDCP;
	rlc_Mode_t	rlc_Mode;
	dL_Forwarding_GTPtunnelEndpoint_t	dL_Forwarding_GTPtunnelEndpoint;
	uL_Forwarding_GTPtunnelEndpoint_t	uL_Forwarding_GTPtunnelEndpoint;
	mCG_E_RAB_Level_QoS_Parameters_t	mCG_E_RAB_Level_QoS_Parameters;
	uL_Configuration_t	uL_Configuration;
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-Admitted-ToBeAdded-SgNBAddReqAck-Item-SgNBPDCPnotpresentExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	{ ID id-lCID				CRITICALITY ignore	EXTENSION LCID			PRESENCE optional},
	...
}
*/

struct E_RABs_Admitted_ToBeAdded_SgNBAddReqAck_Item_SgNBPDCPnotpresentExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_lCID() { set(id_lCID); type=1;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_lCID)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_lCID);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_lCID() { set(ignore); type=1;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		LCID& select_id_lCID() { return set<LCID>(1); }
		LCID const* get_id_lCID() const { return get<LCID>(1); }
		bool is_unknown() const { return type == 2; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<LCID>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<LCID>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_lCID()); return true;
			case 2: if(type != 2) {clear(); asn::base::set();} type = 2; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<LCID>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(LCID)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_lCID() { set(optional); type=1;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(optional)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(optional);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-Admitted-ToBeAdded-SgNBAddReqAck-Item-SgNBPDCPnotpresent ::= SEQUENCE {
	sgNB-DL-GTP-TEIDatSCG				GTPtunnelEndpoint,
	secondary-sgNB-DL-GTP-TEIDatSCG		GTPtunnelEndpoint		OPTIONAL,
	iE-Extensions						ProtocolExtensionContainer { {E-RABs-Admitted-ToBeAdded-SgNBAddReqAck-Item-SgNBPDCPnotpresentExtIEs} } 		OPTIONAL,
	...
}
*/

struct E_RABs_Admitted_ToBeAdded_SgNBAddReqAck_Item_SgNBPDCPnotpresent : asn::sequence<3, 0, true, 2>
{
	static constexpr const char* name() {return "E-RABs-Admitted-ToBeAdded-SgNBAddReqAck-Item-SgNBPDCPnotpresent";}
	using parent_t = asn::sequence<3, 0, true, 2>;
	struct sgNB_DL_GTP_TEIDatSCG_t : GTPtunnelEndpoint
	{
		static constexpr const char* name() {return "sgNB_DL_GTP_TEIDatSCG_t";}
		using parent_t = GTPtunnelEndpoint;

	};
	sgNB_DL_GTP_TEIDatSCG_t& ref_sgNB_DL_GTP_TEIDatSCG() {return sgNB_DL_GTP_TEIDatSCG;}
	sgNB_DL_GTP_TEIDatSCG_t const& ref_sgNB_DL_GTP_TEIDatSCG() const {return sgNB_DL_GTP_TEIDatSCG;}
	struct secondary_sgNB_DL_GTP_TEIDatSCG_t : GTPtunnelEndpoint
	{
		static constexpr const char* name() {return "secondary_sgNB_DL_GTP_TEIDatSCG_t";}
		using parent_t = GTPtunnelEndpoint;
		static constexpr bool optional = true;

	};
	secondary_sgNB_DL_GTP_TEIDatSCG_t& set_secondary_sgNB_DL_GTP_TEIDatSCG() { secondary_sgNB_DL_GTP_TEIDatSCG.setpresent(true); return secondary_sgNB_DL_GTP_TEIDatSCG;}
	secondary_sgNB_DL_GTP_TEIDatSCG_t const* get_secondary_sgNB_DL_GTP_TEIDatSCG() const {return secondary_sgNB_DL_GTP_TEIDatSCG.is_valid() ? &secondary_sgNB_DL_GTP_TEIDatSCG : nullptr;}
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_Admitted_ToBeAdded_SgNBAddReqAck_Item_SgNBPDCPnotpresentExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_Admitted_ToBeAdded_SgNBAddReqAck_Item_SgNBPDCPnotpresentExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(sgNB_DL_GTP_TEIDatSCG);
		v(secondary_sgNB_DL_GTP_TEIDatSCG);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(sgNB_DL_GTP_TEIDatSCG);
		v(secondary_sgNB_DL_GTP_TEIDatSCG);
		v(iE_Extensions);

	};
	void clear()
	{
		sgNB_DL_GTP_TEIDatSCG.clear();
		secondary_sgNB_DL_GTP_TEIDatSCG.clear();
		iE_Extensions.clear();

	};
	private:
	sgNB_DL_GTP_TEIDatSCG_t	sgNB_DL_GTP_TEIDatSCG;
	secondary_sgNB_DL_GTP_TEIDatSCG_t	secondary_sgNB_DL_GTP_TEIDatSCG;
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-ToBeAdded-SgNBAddReqAck-ItemExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct E_RABs_ToBeAdded_SgNBAddReqAck_ItemExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-Admitted-ToBeAdded-SgNBAddReqAck-Item ::= SEQUENCE {
	e-RAB-ID								E-RAB-ID,
	en-DC-ResourceConfiguration			EN-DC-ResourceConfiguration,
	resource-configuration				CHOICE {
		sgNBPDCPpresent						E-RABs-Admitted-ToBeAdded-SgNBAddReqAck-Item-SgNBPDCPpresent,
		sgNBPDCPnotpresent					E-RABs-Admitted-ToBeAdded-SgNBAddReqAck-Item-SgNBPDCPnotpresent,
		...
	},
	iE-Extensions					ProtocolExtensionContainer { {E-RABs-ToBeAdded-SgNBAddReqAck-ItemExtIEs} }	OPTIONAL,
	...
}
*/

struct E_RABs_Admitted_ToBeAdded_SgNBAddReqAck_Item : asn::sequence<4, 0, true, 1>
{
	static constexpr const char* name() {return "E-RABs-Admitted-ToBeAdded-SgNBAddReqAck-Item";}
	using parent_t = asn::sequence<4, 0, true, 1>;
	struct e_RAB_ID_t : E_RAB_ID
	{
		static constexpr const char* name() {return "e_RAB_ID_t";}
		using parent_t = E_RAB_ID;

	};
	e_RAB_ID_t& ref_e_RAB_ID() {return e_RAB_ID;}
	e_RAB_ID_t const& ref_e_RAB_ID() const {return e_RAB_ID;}
	struct en_DC_ResourceConfiguration_t : EN_DC_ResourceConfiguration
	{
		static constexpr const char* name() {return "en_DC_ResourceConfiguration_t";}
		using parent_t = EN_DC_ResourceConfiguration;

	};
	en_DC_ResourceConfiguration_t& ref_en_DC_ResourceConfiguration() {return en_DC_ResourceConfiguration;}
	en_DC_ResourceConfiguration_t const& ref_en_DC_ResourceConfiguration() const {return en_DC_ResourceConfiguration;}
	struct resource_configuration_t : asn::choice<2, 0, true>
	{
		static constexpr const char* name() {return "resource_configuration_t";}
		using parent_t = asn::choice<2, 0, true>;
		index_type get_index() const {return index;}
		bool is_unknown() const {return index == 3;}
		void set_unknown() { set_index(3);  }
		~resource_configuration_t() {clear();}
		struct sgNBPDCPpresent_t : E_RABs_Admitted_ToBeAdded_SgNBAddReqAck_Item_SgNBPDCPpresent
		{
			static constexpr const char* name() {return "sgNBPDCPpresent_t";}
			using parent_t = E_RABs_Admitted_ToBeAdded_SgNBAddReqAck_Item_SgNBPDCPpresent;

		};
		struct sgNBPDCPnotpresent_t : E_RABs_Admitted_ToBeAdded_SgNBAddReqAck_Item_SgNBPDCPnotpresent
		{
			static constexpr const char* name() {return "sgNBPDCPnotpresent_t";}
			using parent_t = E_RABs_Admitted_ToBeAdded_SgNBAddReqAck_Item_SgNBPDCPnotpresent;

		};
		void clear()
		{
			switch(get_index())
			{
			case 1: var.destroy<sgNBPDCPpresent_t>(); break;
			case 2: var.destroy<sgNBPDCPnotpresent_t>(); break;
			}
			index = 0;
			base::clear();
		}
		template<typename V> bool decode(size_t idx, V& v)
		{
			clear();
			switch(idx)
			{
			case 1: set_index(1); return v(var.build<sgNBPDCPpresent_t>());
			case 2: set_index(2); return v(var.build<sgNBPDCPnotpresent_t>());
			}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			switch(get_index())
			{
			case 1: return v(var.as<sgNBPDCPpresent_t>());
			case 2: return v(var.as<sgNBPDCPnotpresent_t>());
			}
			return false;
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<sgNBPDCPpresent_t>(1);
			v.template operator()<sgNBPDCPnotpresent_t>(2);

		}
		sgNBPDCPpresent_t& select_sgNBPDCPpresent() { if(get_index() != 1) { clear(); set_index(1); return var.build<sgNBPDCPpresent_t>();} return var.as<sgNBPDCPpresent_t>();}
		sgNBPDCPpresent_t const* get_sgNBPDCPpresent() const { if(get_index() == 1) { return &var.as<sgNBPDCPpresent_t>();} return nullptr; }
		sgNBPDCPnotpresent_t& select_sgNBPDCPnotpresent() { if(get_index() != 2) { clear(); set_index(2); return var.build<sgNBPDCPnotpresent_t>();} return var.as<sgNBPDCPnotpresent_t>();}
		sgNBPDCPnotpresent_t const* get_sgNBPDCPnotpresent() const { if(get_index() == 2) { return &var.as<sgNBPDCPnotpresent_t>();} return nullptr; }
		private:
		void set_index(index_type i) {index = i; base::set();}
		union union_type
		{
			char dummy1[sizeof(sgNBPDCPpresent_t)];
			char dummy2[sizeof(sgNBPDCPnotpresent_t)];

		};
		asn::variant<sizeof(union_type)>	var;
		index_type	index {0};
	};
	resource_configuration_t& ref_resource_configuration() {return resource_configuration;}
	resource_configuration_t const& ref_resource_configuration() const {return resource_configuration;}
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_ToBeAdded_SgNBAddReqAck_ItemExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_ToBeAdded_SgNBAddReqAck_ItemExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(e_RAB_ID);
		v(en_DC_ResourceConfiguration);
		v(resource_configuration);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(e_RAB_ID);
		v(en_DC_ResourceConfiguration);
		v(resource_configuration);
		v(iE_Extensions);

	};
	void clear()
	{
		e_RAB_ID.clear();
		en_DC_ResourceConfiguration.clear();
		resource_configuration.clear();
		iE_Extensions.clear();

	};
	private:
	e_RAB_ID_t	e_RAB_ID;
	en_DC_ResourceConfiguration_t	en_DC_ResourceConfiguration;
	resource_configuration_t	resource_configuration;
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-Admitted-ToBeAdded-SgNBAddReqAck-ItemIEs X2AP-PROTOCOL-IES ::= {
	{ ID id-E-RABs-Admitted-ToBeAdded-SgNBAddReqAck-Item	CRITICALITY ignore	TYPE E-RABs-Admitted-ToBeAdded-SgNBAddReqAck-Item 		PRESENCE mandatory}
}
*/

struct E_RABs_Admitted_ToBeAdded_SgNBAddReqAck_ItemIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, false>
	{
		size_t get_index() const {return type;}
		void clear() {type = 0;}
		void select_id_E_RABs_Admitted_ToBeAdded_SgNBAddReqAck_Item() { set(id_E_RABs_Admitted_ToBeAdded_SgNBAddReqAck_Item); type=1;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_E_RABs_Admitted_ToBeAdded_SgNBAddReqAck_Item)) { type = 1; return true; }
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_E_RABs_Admitted_ToBeAdded_SgNBAddReqAck_Item);} return false;
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, false>
	{
		size_t get_index() const {return type;}
		void clear() {type = 0;}
		void select_id_E_RABs_Admitted_ToBeAdded_SgNBAddReqAck_Item() { set(ignore); type=1;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<false>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		E_RABs_Admitted_ToBeAdded_SgNBAddReqAck_Item& select_id_E_RABs_Admitted_ToBeAdded_SgNBAddReqAck_Item() { return set<E_RABs_Admitted_ToBeAdded_SgNBAddReqAck_Item>(1); }
		E_RABs_Admitted_ToBeAdded_SgNBAddReqAck_Item const* get_id_E_RABs_Admitted_ToBeAdded_SgNBAddReqAck_Item() const { return get<E_RABs_Admitted_ToBeAdded_SgNBAddReqAck_Item>(1); }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<E_RABs_Admitted_ToBeAdded_SgNBAddReqAck_Item>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<E_RABs_Admitted_ToBeAdded_SgNBAddReqAck_Item>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_E_RABs_Admitted_ToBeAdded_SgNBAddReqAck_Item()); return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<E_RABs_Admitted_ToBeAdded_SgNBAddReqAck_Item>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(E_RABs_Admitted_ToBeAdded_SgNBAddReqAck_Item)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, false>
	{
		size_t get_index() const {return type;}
		void clear() {type = 0;}
		void select_id_E_RABs_Admitted_ToBeAdded_SgNBAddReqAck_Item() { set(mandatory); type=1;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-Admitted-ToBeAdded-SgNBAddReqAckList ::= SEQUENCE (SIZE (1..maxnoofBearers)) OF ProtocolIE-Single-Container { {E-RABs-Admitted-ToBeAdded-SgNBAddReqAck-ItemIEs} }
*/

struct E_RABs_Admitted_ToBeAdded_SgNBAddReqAckList_elm : ProtocolIE_Single_Container<E_RABs_Admitted_ToBeAdded_SgNBAddReqAck_ItemIEs>
{
	static constexpr const char* name() {return "E_RABs_Admitted_ToBeAdded_SgNBAddReqAckList_elm";}
	using parent_t = ProtocolIE_Single_Container<E_RABs_Admitted_ToBeAdded_SgNBAddReqAck_ItemIEs>;

};
struct E_RABs_Admitted_ToBeAdded_SgNBAddReqAckList : asn::sequenceof<E_RABs_Admitted_ToBeAdded_SgNBAddReqAckList_elm>
{
	static constexpr const char* name() {return "E-RABs-Admitted-ToBeAdded-SgNBAddReqAckList";}
	using parent_t = asn::sequenceof<E_RABs_Admitted_ToBeAdded_SgNBAddReqAckList_elm>;
	using constraint_t = asn::constraints<false,asn::span<1,  maxnoofBearers >>;

};
/*
E-RABs-Admitted-ToBeAdded-SgNBModAck-Item-SgNBPDCPpresentExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	{ ID id-uLpDCPSnLength							CRITICALITY ignore	EXTENSION PDCPSnLength					PRESENCE optional}|
	{ ID id-dLPDCPSnLength							CRITICALITY ignore	EXTENSION PDCPSnLength					PRESENCE optional},
	...
}
*/

struct E_RABs_Admitted_ToBeAdded_SgNBModAck_Item_SgNBPDCPpresentExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 3; }
		void clear() {type = 0;}
		void select_id_uLpDCPSnLength() { set(id_uLpDCPSnLength); type=1;}
		void select_id_dLPDCPSnLength() { set(id_dLPDCPSnLength); type=2;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_uLpDCPSnLength)) { type = 1; return true; }
			else if(equal(id_dLPDCPSnLength)) { type = 2; return true; }
			else { type = 3; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_uLpDCPSnLength);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_dLPDCPSnLength);} return false;
			case 3: type = 3; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 3; }
		void clear() {type = 0;}
		void select_id_uLpDCPSnLength() { set(ignore); type=1;}
		void select_id_dLPDCPSnLength() { set(ignore); type=2;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else if(equal(ignore)) { type = 2; return true; }
			else { type = 3; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(ignore);} return false;
			case 3: type = 3; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		PDCPSnLength& select_id_uLpDCPSnLength() { return set<PDCPSnLength>(1); }
		PDCPSnLength const* get_id_uLpDCPSnLength() const { return get<PDCPSnLength>(1); }
		PDCPSnLength& select_id_dLPDCPSnLength() { return set<PDCPSnLength>(2); }
		PDCPSnLength const* get_id_dLPDCPSnLength() const { return get<PDCPSnLength>(2); }
		bool is_unknown() const { return type == 3; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<PDCPSnLength>(); break;
			case 2: var.destroy<PDCPSnLength>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<PDCPSnLength>(1);
			v.template operator()<PDCPSnLength>(2);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_uLpDCPSnLength()); return true;
			case 2: v(select_id_dLPDCPSnLength()); return true;
			case 3: if(type != 3) {clear(); asn::base::set();} type = 3; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<PDCPSnLength>()); return true;
			case 2: v(var.as<PDCPSnLength>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(PDCPSnLength)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 3; }
		void clear() {type = 0;}
		void select_id_uLpDCPSnLength() { set(optional); type=1;}
		void select_id_dLPDCPSnLength() { set(optional); type=2;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(optional)) { type = 1; return true; }
			else if(equal(optional)) { type = 2; return true; }
			else { type = 3; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(optional);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(optional);} return false;
			case 3: type = 3; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-Admitted-ToBeAdded-SgNBModAck-Item-SgNBPDCPpresent ::= SEQUENCE {
	s1-DL-GTPtunnelEndpoint					GTPtunnelEndpoint,
	sgNB-UL-GTP-TEIDatPDCP					GTPtunnelEndpoint																					OPTIONAL,
-- This IE shall be present if MCG resource IE in the the EN-DC Resource Configuration IE are set to present --
	rlc-Mode									RLCMode																								OPTIONAL,
-- This IE shall be present if MCG resource IE in the the EN-DC Resource Configuration IE are set to present --
	dL-Forwarding-GTPtunnelEndpoint			GTPtunnelEndpoint																					OPTIONAL,
	uL-Forwarding-GTPtunnelEndpoint			GTPtunnelEndpoint																					OPTIONAL,
	mCG-E-RAB-Level-QoS-Parameters			E-RAB-Level-QoS-Parameters																			OPTIONAL,
-- This IE shall be present if MCG resource and SCG resource IEs in the the EN-DC Resource Configuration IE are set to present and the GBR QoS Information IE is present in the Requested MCG E-RAB Level QoS Parameters IE --
	uL-Configuration						ULConfiguration																							OPTIONAL,
-- This IE shall be present if MCG resource and SCG resources IEs in the the EN-DC Resource Configuration IE are set to present --
	iE-Extensions					ProtocolExtensionContainer { {E-RABs-Admitted-ToBeAdded-SgNBModAck-Item-SgNBPDCPpresentExtIEs} }		OPTIONAL,
	...
}
*/

struct E_RABs_Admitted_ToBeAdded_SgNBModAck_Item_SgNBPDCPpresent : asn::sequence<8, 0, true, 7>
{
	static constexpr const char* name() {return "E-RABs-Admitted-ToBeAdded-SgNBModAck-Item-SgNBPDCPpresent";}
	using parent_t = asn::sequence<8, 0, true, 7>;
	struct s1_DL_GTPtunnelEndpoint_t : GTPtunnelEndpoint
	{
		static constexpr const char* name() {return "s1_DL_GTPtunnelEndpoint_t";}
		using parent_t = GTPtunnelEndpoint;

	};
	s1_DL_GTPtunnelEndpoint_t& ref_s1_DL_GTPtunnelEndpoint() {return s1_DL_GTPtunnelEndpoint;}
	s1_DL_GTPtunnelEndpoint_t const& ref_s1_DL_GTPtunnelEndpoint() const {return s1_DL_GTPtunnelEndpoint;}
	struct sgNB_UL_GTP_TEIDatPDCP_t : GTPtunnelEndpoint
	{
		static constexpr const char* name() {return "sgNB_UL_GTP_TEIDatPDCP_t";}
		using parent_t = GTPtunnelEndpoint;
		static constexpr bool optional = true;

	};
	sgNB_UL_GTP_TEIDatPDCP_t& set_sgNB_UL_GTP_TEIDatPDCP() { sgNB_UL_GTP_TEIDatPDCP.setpresent(true); return sgNB_UL_GTP_TEIDatPDCP;}
	sgNB_UL_GTP_TEIDatPDCP_t const* get_sgNB_UL_GTP_TEIDatPDCP() const {return sgNB_UL_GTP_TEIDatPDCP.is_valid() ? &sgNB_UL_GTP_TEIDatPDCP : nullptr;}
	struct rlc_Mode_t : RLCMode
	{
		static constexpr const char* name() {return "rlc_Mode_t";}
		using parent_t = RLCMode;
		static constexpr bool optional = true;

	};
	rlc_Mode_t& set_rlc_Mode() { rlc_Mode.setpresent(true); return rlc_Mode;}
	rlc_Mode_t const* get_rlc_Mode() const {return rlc_Mode.is_valid() ? &rlc_Mode : nullptr;}
	struct dL_Forwarding_GTPtunnelEndpoint_t : GTPtunnelEndpoint
	{
		static constexpr const char* name() {return "dL_Forwarding_GTPtunnelEndpoint_t";}
		using parent_t = GTPtunnelEndpoint;
		static constexpr bool optional = true;

	};
	dL_Forwarding_GTPtunnelEndpoint_t& set_dL_Forwarding_GTPtunnelEndpoint() { dL_Forwarding_GTPtunnelEndpoint.setpresent(true); return dL_Forwarding_GTPtunnelEndpoint;}
	dL_Forwarding_GTPtunnelEndpoint_t const* get_dL_Forwarding_GTPtunnelEndpoint() const {return dL_Forwarding_GTPtunnelEndpoint.is_valid() ? &dL_Forwarding_GTPtunnelEndpoint : nullptr;}
	struct uL_Forwarding_GTPtunnelEndpoint_t : GTPtunnelEndpoint
	{
		static constexpr const char* name() {return "uL_Forwarding_GTPtunnelEndpoint_t";}
		using parent_t = GTPtunnelEndpoint;
		static constexpr bool optional = true;

	};
	uL_Forwarding_GTPtunnelEndpoint_t& set_uL_Forwarding_GTPtunnelEndpoint() { uL_Forwarding_GTPtunnelEndpoint.setpresent(true); return uL_Forwarding_GTPtunnelEndpoint;}
	uL_Forwarding_GTPtunnelEndpoint_t const* get_uL_Forwarding_GTPtunnelEndpoint() const {return uL_Forwarding_GTPtunnelEndpoint.is_valid() ? &uL_Forwarding_GTPtunnelEndpoint : nullptr;}
	struct mCG_E_RAB_Level_QoS_Parameters_t : E_RAB_Level_QoS_Parameters
	{
		static constexpr const char* name() {return "mCG_E_RAB_Level_QoS_Parameters_t";}
		using parent_t = E_RAB_Level_QoS_Parameters;
		static constexpr bool optional = true;

	};
	mCG_E_RAB_Level_QoS_Parameters_t& set_mCG_E_RAB_Level_QoS_Parameters() { mCG_E_RAB_Level_QoS_Parameters.setpresent(true); return mCG_E_RAB_Level_QoS_Parameters;}
	mCG_E_RAB_Level_QoS_Parameters_t const* get_mCG_E_RAB_Level_QoS_Parameters() const {return mCG_E_RAB_Level_QoS_Parameters.is_valid() ? &mCG_E_RAB_Level_QoS_Parameters : nullptr;}
	struct uL_Configuration_t : ULConfiguration
	{
		static constexpr const char* name() {return "uL_Configuration_t";}
		using parent_t = ULConfiguration;
		static constexpr bool optional = true;

	};
	uL_Configuration_t& set_uL_Configuration() { uL_Configuration.setpresent(true); return uL_Configuration;}
	uL_Configuration_t const* get_uL_Configuration() const {return uL_Configuration.is_valid() ? &uL_Configuration : nullptr;}
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_Admitted_ToBeAdded_SgNBModAck_Item_SgNBPDCPpresentExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_Admitted_ToBeAdded_SgNBModAck_Item_SgNBPDCPpresentExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(s1_DL_GTPtunnelEndpoint);
		v(sgNB_UL_GTP_TEIDatPDCP);
		v(rlc_Mode);
		v(dL_Forwarding_GTPtunnelEndpoint);
		v(uL_Forwarding_GTPtunnelEndpoint);
		v(mCG_E_RAB_Level_QoS_Parameters);
		v(uL_Configuration);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(s1_DL_GTPtunnelEndpoint);
		v(sgNB_UL_GTP_TEIDatPDCP);
		v(rlc_Mode);
		v(dL_Forwarding_GTPtunnelEndpoint);
		v(uL_Forwarding_GTPtunnelEndpoint);
		v(mCG_E_RAB_Level_QoS_Parameters);
		v(uL_Configuration);
		v(iE_Extensions);

	};
	void clear()
	{
		s1_DL_GTPtunnelEndpoint.clear();
		sgNB_UL_GTP_TEIDatPDCP.clear();
		rlc_Mode.clear();
		dL_Forwarding_GTPtunnelEndpoint.clear();
		uL_Forwarding_GTPtunnelEndpoint.clear();
		mCG_E_RAB_Level_QoS_Parameters.clear();
		uL_Configuration.clear();
		iE_Extensions.clear();

	};
	private:
	s1_DL_GTPtunnelEndpoint_t	s1_DL_GTPtunnelEndpoint;
	sgNB_UL_GTP_TEIDatPDCP_t	sgNB_UL_GTP_TEIDatPDCP;
	rlc_Mode_t	rlc_Mode;
	dL_Forwarding_GTPtunnelEndpoint_t	dL_Forwarding_GTPtunnelEndpoint;
	uL_Forwarding_GTPtunnelEndpoint_t	uL_Forwarding_GTPtunnelEndpoint;
	mCG_E_RAB_Level_QoS_Parameters_t	mCG_E_RAB_Level_QoS_Parameters;
	uL_Configuration_t	uL_Configuration;
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-Admitted-ToBeAdded-SgNBModAck-Item-SgNBPDCPnotpresentExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	{ID id-lCID				CRITICALITY ignore	EXTENSION LCID		PRESENCE optional},
	...
}
*/

struct E_RABs_Admitted_ToBeAdded_SgNBModAck_Item_SgNBPDCPnotpresentExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_lCID() { set(id_lCID); type=1;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_lCID)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_lCID);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_lCID() { set(ignore); type=1;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		LCID& select_id_lCID() { return set<LCID>(1); }
		LCID const* get_id_lCID() const { return get<LCID>(1); }
		bool is_unknown() const { return type == 2; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<LCID>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<LCID>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_lCID()); return true;
			case 2: if(type != 2) {clear(); asn::base::set();} type = 2; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<LCID>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(LCID)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_lCID() { set(optional); type=1;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(optional)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(optional);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-Admitted-ToBeAdded-SgNBModAck-Item-SgNBPDCPnotpresent ::= SEQUENCE {
	sgNB-DL-GTP-TEIDatSCG					GTPtunnelEndpoint,
	secondary-sgNB-DL-GTP-TEIDatSCG			GTPtunnelEndpoint			OPTIONAL,
	iE-Extensions					ProtocolExtensionContainer { {E-RABs-Admitted-ToBeAdded-SgNBModAck-Item-SgNBPDCPnotpresentExtIEs} } OPTIONAL,
	...
}
*/

struct E_RABs_Admitted_ToBeAdded_SgNBModAck_Item_SgNBPDCPnotpresent : asn::sequence<3, 0, true, 2>
{
	static constexpr const char* name() {return "E-RABs-Admitted-ToBeAdded-SgNBModAck-Item-SgNBPDCPnotpresent";}
	using parent_t = asn::sequence<3, 0, true, 2>;
	struct sgNB_DL_GTP_TEIDatSCG_t : GTPtunnelEndpoint
	{
		static constexpr const char* name() {return "sgNB_DL_GTP_TEIDatSCG_t";}
		using parent_t = GTPtunnelEndpoint;

	};
	sgNB_DL_GTP_TEIDatSCG_t& ref_sgNB_DL_GTP_TEIDatSCG() {return sgNB_DL_GTP_TEIDatSCG;}
	sgNB_DL_GTP_TEIDatSCG_t const& ref_sgNB_DL_GTP_TEIDatSCG() const {return sgNB_DL_GTP_TEIDatSCG;}
	struct secondary_sgNB_DL_GTP_TEIDatSCG_t : GTPtunnelEndpoint
	{
		static constexpr const char* name() {return "secondary_sgNB_DL_GTP_TEIDatSCG_t";}
		using parent_t = GTPtunnelEndpoint;
		static constexpr bool optional = true;

	};
	secondary_sgNB_DL_GTP_TEIDatSCG_t& set_secondary_sgNB_DL_GTP_TEIDatSCG() { secondary_sgNB_DL_GTP_TEIDatSCG.setpresent(true); return secondary_sgNB_DL_GTP_TEIDatSCG;}
	secondary_sgNB_DL_GTP_TEIDatSCG_t const* get_secondary_sgNB_DL_GTP_TEIDatSCG() const {return secondary_sgNB_DL_GTP_TEIDatSCG.is_valid() ? &secondary_sgNB_DL_GTP_TEIDatSCG : nullptr;}
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_Admitted_ToBeAdded_SgNBModAck_Item_SgNBPDCPnotpresentExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_Admitted_ToBeAdded_SgNBModAck_Item_SgNBPDCPnotpresentExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(sgNB_DL_GTP_TEIDatSCG);
		v(secondary_sgNB_DL_GTP_TEIDatSCG);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(sgNB_DL_GTP_TEIDatSCG);
		v(secondary_sgNB_DL_GTP_TEIDatSCG);
		v(iE_Extensions);

	};
	void clear()
	{
		sgNB_DL_GTP_TEIDatSCG.clear();
		secondary_sgNB_DL_GTP_TEIDatSCG.clear();
		iE_Extensions.clear();

	};
	private:
	sgNB_DL_GTP_TEIDatSCG_t	sgNB_DL_GTP_TEIDatSCG;
	secondary_sgNB_DL_GTP_TEIDatSCG_t	secondary_sgNB_DL_GTP_TEIDatSCG;
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-Admitted-ToBeAdded-SgNBModAck-ItemExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct E_RABs_Admitted_ToBeAdded_SgNBModAck_ItemExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-Admitted-ToBeAdded-SgNBModAck-Item ::= SEQUENCE {
	e-RAB-ID								E-RAB-ID,
	en-DC-ResourceConfiguration			EN-DC-ResourceConfiguration,
	resource-configuration				CHOICE {
		sgNBPDCPpresent						E-RABs-Admitted-ToBeAdded-SgNBModAck-Item-SgNBPDCPpresent,
		sgNBPDCPnotpresent					E-RABs-Admitted-ToBeAdded-SgNBModAck-Item-SgNBPDCPnotpresent,
		...
	},
	iE-Extensions					ProtocolExtensionContainer { {E-RABs-Admitted-ToBeAdded-SgNBModAck-ItemExtIEs} }	OPTIONAL,
	...
}
*/

struct E_RABs_Admitted_ToBeAdded_SgNBModAck_Item : asn::sequence<4, 0, true, 1>
{
	static constexpr const char* name() {return "E-RABs-Admitted-ToBeAdded-SgNBModAck-Item";}
	using parent_t = asn::sequence<4, 0, true, 1>;
	struct e_RAB_ID_t : E_RAB_ID
	{
		static constexpr const char* name() {return "e_RAB_ID_t";}
		using parent_t = E_RAB_ID;

	};
	e_RAB_ID_t& ref_e_RAB_ID() {return e_RAB_ID;}
	e_RAB_ID_t const& ref_e_RAB_ID() const {return e_RAB_ID;}
	struct en_DC_ResourceConfiguration_t : EN_DC_ResourceConfiguration
	{
		static constexpr const char* name() {return "en_DC_ResourceConfiguration_t";}
		using parent_t = EN_DC_ResourceConfiguration;

	};
	en_DC_ResourceConfiguration_t& ref_en_DC_ResourceConfiguration() {return en_DC_ResourceConfiguration;}
	en_DC_ResourceConfiguration_t const& ref_en_DC_ResourceConfiguration() const {return en_DC_ResourceConfiguration;}
	struct resource_configuration_t : asn::choice<2, 0, true>
	{
		static constexpr const char* name() {return "resource_configuration_t";}
		using parent_t = asn::choice<2, 0, true>;
		index_type get_index() const {return index;}
		bool is_unknown() const {return index == 3;}
		void set_unknown() { set_index(3);  }
		~resource_configuration_t() {clear();}
		struct sgNBPDCPpresent_t : E_RABs_Admitted_ToBeAdded_SgNBModAck_Item_SgNBPDCPpresent
		{
			static constexpr const char* name() {return "sgNBPDCPpresent_t";}
			using parent_t = E_RABs_Admitted_ToBeAdded_SgNBModAck_Item_SgNBPDCPpresent;

		};
		struct sgNBPDCPnotpresent_t : E_RABs_Admitted_ToBeAdded_SgNBModAck_Item_SgNBPDCPnotpresent
		{
			static constexpr const char* name() {return "sgNBPDCPnotpresent_t";}
			using parent_t = E_RABs_Admitted_ToBeAdded_SgNBModAck_Item_SgNBPDCPnotpresent;

		};
		void clear()
		{
			switch(get_index())
			{
			case 1: var.destroy<sgNBPDCPpresent_t>(); break;
			case 2: var.destroy<sgNBPDCPnotpresent_t>(); break;
			}
			index = 0;
			base::clear();
		}
		template<typename V> bool decode(size_t idx, V& v)
		{
			clear();
			switch(idx)
			{
			case 1: set_index(1); return v(var.build<sgNBPDCPpresent_t>());
			case 2: set_index(2); return v(var.build<sgNBPDCPnotpresent_t>());
			}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			switch(get_index())
			{
			case 1: return v(var.as<sgNBPDCPpresent_t>());
			case 2: return v(var.as<sgNBPDCPnotpresent_t>());
			}
			return false;
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<sgNBPDCPpresent_t>(1);
			v.template operator()<sgNBPDCPnotpresent_t>(2);

		}
		sgNBPDCPpresent_t& select_sgNBPDCPpresent() { if(get_index() != 1) { clear(); set_index(1); return var.build<sgNBPDCPpresent_t>();} return var.as<sgNBPDCPpresent_t>();}
		sgNBPDCPpresent_t const* get_sgNBPDCPpresent() const { if(get_index() == 1) { return &var.as<sgNBPDCPpresent_t>();} return nullptr; }
		sgNBPDCPnotpresent_t& select_sgNBPDCPnotpresent() { if(get_index() != 2) { clear(); set_index(2); return var.build<sgNBPDCPnotpresent_t>();} return var.as<sgNBPDCPnotpresent_t>();}
		sgNBPDCPnotpresent_t const* get_sgNBPDCPnotpresent() const { if(get_index() == 2) { return &var.as<sgNBPDCPnotpresent_t>();} return nullptr; }
		private:
		void set_index(index_type i) {index = i; base::set();}
		union union_type
		{
			char dummy1[sizeof(sgNBPDCPpresent_t)];
			char dummy2[sizeof(sgNBPDCPnotpresent_t)];

		};
		asn::variant<sizeof(union_type)>	var;
		index_type	index {0};
	};
	resource_configuration_t& ref_resource_configuration() {return resource_configuration;}
	resource_configuration_t const& ref_resource_configuration() const {return resource_configuration;}
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_Admitted_ToBeAdded_SgNBModAck_ItemExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_Admitted_ToBeAdded_SgNBModAck_ItemExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(e_RAB_ID);
		v(en_DC_ResourceConfiguration);
		v(resource_configuration);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(e_RAB_ID);
		v(en_DC_ResourceConfiguration);
		v(resource_configuration);
		v(iE_Extensions);

	};
	void clear()
	{
		e_RAB_ID.clear();
		en_DC_ResourceConfiguration.clear();
		resource_configuration.clear();
		iE_Extensions.clear();

	};
	private:
	e_RAB_ID_t	e_RAB_ID;
	en_DC_ResourceConfiguration_t	en_DC_ResourceConfiguration;
	resource_configuration_t	resource_configuration;
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-Admitted-ToBeAdded-SgNBModAck-ItemIEs X2AP-PROTOCOL-IES ::= {
	{ ID id-E-RABs-Admitted-ToBeAdded-SgNBModAck-Item 	CRITICALITY ignore	TYPE E-RABs-Admitted-ToBeAdded-SgNBModAck-Item		PRESENCE mandatory}
}
*/

struct E_RABs_Admitted_ToBeAdded_SgNBModAck_ItemIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, false>
	{
		size_t get_index() const {return type;}
		void clear() {type = 0;}
		void select_id_E_RABs_Admitted_ToBeAdded_SgNBModAck_Item() { set(id_E_RABs_Admitted_ToBeAdded_SgNBModAck_Item); type=1;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_E_RABs_Admitted_ToBeAdded_SgNBModAck_Item)) { type = 1; return true; }
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_E_RABs_Admitted_ToBeAdded_SgNBModAck_Item);} return false;
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, false>
	{
		size_t get_index() const {return type;}
		void clear() {type = 0;}
		void select_id_E_RABs_Admitted_ToBeAdded_SgNBModAck_Item() { set(ignore); type=1;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<false>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		E_RABs_Admitted_ToBeAdded_SgNBModAck_Item& select_id_E_RABs_Admitted_ToBeAdded_SgNBModAck_Item() { return set<E_RABs_Admitted_ToBeAdded_SgNBModAck_Item>(1); }
		E_RABs_Admitted_ToBeAdded_SgNBModAck_Item const* get_id_E_RABs_Admitted_ToBeAdded_SgNBModAck_Item() const { return get<E_RABs_Admitted_ToBeAdded_SgNBModAck_Item>(1); }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<E_RABs_Admitted_ToBeAdded_SgNBModAck_Item>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<E_RABs_Admitted_ToBeAdded_SgNBModAck_Item>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_E_RABs_Admitted_ToBeAdded_SgNBModAck_Item()); return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<E_RABs_Admitted_ToBeAdded_SgNBModAck_Item>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(E_RABs_Admitted_ToBeAdded_SgNBModAck_Item)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, false>
	{
		size_t get_index() const {return type;}
		void clear() {type = 0;}
		void select_id_E_RABs_Admitted_ToBeAdded_SgNBModAck_Item() { set(mandatory); type=1;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-Admitted-ToBeAdded-SgNBModAckList ::= SEQUENCE (SIZE (1..maxnoofBearers)) OF ProtocolIE-Single-Container { {E-RABs-Admitted-ToBeAdded-SgNBModAck-ItemIEs} }
*/

struct E_RABs_Admitted_ToBeAdded_SgNBModAckList_elm : ProtocolIE_Single_Container<E_RABs_Admitted_ToBeAdded_SgNBModAck_ItemIEs>
{
	static constexpr const char* name() {return "E_RABs_Admitted_ToBeAdded_SgNBModAckList_elm";}
	using parent_t = ProtocolIE_Single_Container<E_RABs_Admitted_ToBeAdded_SgNBModAck_ItemIEs>;

};
struct E_RABs_Admitted_ToBeAdded_SgNBModAckList : asn::sequenceof<E_RABs_Admitted_ToBeAdded_SgNBModAckList_elm>
{
	static constexpr const char* name() {return "E-RABs-Admitted-ToBeAdded-SgNBModAckList";}
	using parent_t = asn::sequenceof<E_RABs_Admitted_ToBeAdded_SgNBModAckList_elm>;
	using constraint_t = asn::constraints<false,asn::span<1,  maxnoofBearers >>;

};
/*
E-RABs-Admitted-ToBeModified-ModAckItem-SCG-BearerExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct E_RABs_Admitted_ToBeModified_ModAckItem_SCG_BearerExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-Admitted-ToBeModified-ModAckItem-SCG-Bearer ::= SEQUENCE {
	e-RAB-ID						E-RAB-ID,
	s1-DL-GTPtunnelEndpoint			GTPtunnelEndpoint																	OPTIONAL,
	iE-Extensions					ProtocolExtensionContainer { {E-RABs-Admitted-ToBeModified-ModAckItem-SCG-BearerExtIEs} } OPTIONAL,
	...
}
*/

struct E_RABs_Admitted_ToBeModified_ModAckItem_SCG_Bearer : asn::sequence<3, 0, true, 2>
{
	static constexpr const char* name() {return "E-RABs-Admitted-ToBeModified-ModAckItem-SCG-Bearer";}
	using parent_t = asn::sequence<3, 0, true, 2>;
	struct e_RAB_ID_t : E_RAB_ID
	{
		static constexpr const char* name() {return "e_RAB_ID_t";}
		using parent_t = E_RAB_ID;

	};
	e_RAB_ID_t& ref_e_RAB_ID() {return e_RAB_ID;}
	e_RAB_ID_t const& ref_e_RAB_ID() const {return e_RAB_ID;}
	struct s1_DL_GTPtunnelEndpoint_t : GTPtunnelEndpoint
	{
		static constexpr const char* name() {return "s1_DL_GTPtunnelEndpoint_t";}
		using parent_t = GTPtunnelEndpoint;
		static constexpr bool optional = true;

	};
	s1_DL_GTPtunnelEndpoint_t& set_s1_DL_GTPtunnelEndpoint() { s1_DL_GTPtunnelEndpoint.setpresent(true); return s1_DL_GTPtunnelEndpoint;}
	s1_DL_GTPtunnelEndpoint_t const* get_s1_DL_GTPtunnelEndpoint() const {return s1_DL_GTPtunnelEndpoint.is_valid() ? &s1_DL_GTPtunnelEndpoint : nullptr;}
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_Admitted_ToBeModified_ModAckItem_SCG_BearerExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_Admitted_ToBeModified_ModAckItem_SCG_BearerExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(e_RAB_ID);
		v(s1_DL_GTPtunnelEndpoint);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(e_RAB_ID);
		v(s1_DL_GTPtunnelEndpoint);
		v(iE_Extensions);

	};
	void clear()
	{
		e_RAB_ID.clear();
		s1_DL_GTPtunnelEndpoint.clear();
		iE_Extensions.clear();

	};
	private:
	e_RAB_ID_t	e_RAB_ID;
	s1_DL_GTPtunnelEndpoint_t	s1_DL_GTPtunnelEndpoint;
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-Admitted-ToBeModified-ModAckItem-Split-BearerExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct E_RABs_Admitted_ToBeModified_ModAckItem_Split_BearerExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-Admitted-ToBeModified-ModAckItem-Split-Bearer ::= SEQUENCE {
	e-RAB-ID						E-RAB-ID,
	seNB-GTPtunnelEndpoint			GTPtunnelEndpoint																			OPTIONAL,
	iE-Extensions					ProtocolExtensionContainer { {E-RABs-Admitted-ToBeModified-ModAckItem-Split-BearerExtIEs} } OPTIONAL,
	...
}
*/

struct E_RABs_Admitted_ToBeModified_ModAckItem_Split_Bearer : asn::sequence<3, 0, true, 2>
{
	static constexpr const char* name() {return "E-RABs-Admitted-ToBeModified-ModAckItem-Split-Bearer";}
	using parent_t = asn::sequence<3, 0, true, 2>;
	struct e_RAB_ID_t : E_RAB_ID
	{
		static constexpr const char* name() {return "e_RAB_ID_t";}
		using parent_t = E_RAB_ID;

	};
	e_RAB_ID_t& ref_e_RAB_ID() {return e_RAB_ID;}
	e_RAB_ID_t const& ref_e_RAB_ID() const {return e_RAB_ID;}
	struct seNB_GTPtunnelEndpoint_t : GTPtunnelEndpoint
	{
		static constexpr const char* name() {return "seNB_GTPtunnelEndpoint_t";}
		using parent_t = GTPtunnelEndpoint;
		static constexpr bool optional = true;

	};
	seNB_GTPtunnelEndpoint_t& set_seNB_GTPtunnelEndpoint() { seNB_GTPtunnelEndpoint.setpresent(true); return seNB_GTPtunnelEndpoint;}
	seNB_GTPtunnelEndpoint_t const* get_seNB_GTPtunnelEndpoint() const {return seNB_GTPtunnelEndpoint.is_valid() ? &seNB_GTPtunnelEndpoint : nullptr;}
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_Admitted_ToBeModified_ModAckItem_Split_BearerExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_Admitted_ToBeModified_ModAckItem_Split_BearerExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(e_RAB_ID);
		v(seNB_GTPtunnelEndpoint);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(e_RAB_ID);
		v(seNB_GTPtunnelEndpoint);
		v(iE_Extensions);

	};
	void clear()
	{
		e_RAB_ID.clear();
		seNB_GTPtunnelEndpoint.clear();
		iE_Extensions.clear();

	};
	private:
	e_RAB_ID_t	e_RAB_ID;
	seNB_GTPtunnelEndpoint_t	seNB_GTPtunnelEndpoint;
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-Admitted-ToBeModified-ModAckItem ::= CHOICE {
	sCG-Bearer		E-RABs-Admitted-ToBeModified-ModAckItem-SCG-Bearer,
	split-Bearer	E-RABs-Admitted-ToBeModified-ModAckItem-Split-Bearer,
	...
}
*/

struct E_RABs_Admitted_ToBeModified_ModAckItem : asn::choice<2, 0, true>
{
	static constexpr const char* name() {return "E-RABs-Admitted-ToBeModified-ModAckItem";}
	using parent_t = asn::choice<2, 0, true>;
	index_type get_index() const {return index;}
	bool is_unknown() const {return index == 3;}
	void set_unknown() { set_index(3);  }
	~E_RABs_Admitted_ToBeModified_ModAckItem() {clear();}
	struct sCG_Bearer_t : E_RABs_Admitted_ToBeModified_ModAckItem_SCG_Bearer
	{
		static constexpr const char* name() {return "sCG_Bearer_t";}
		using parent_t = E_RABs_Admitted_ToBeModified_ModAckItem_SCG_Bearer;

	};
	struct split_Bearer_t : E_RABs_Admitted_ToBeModified_ModAckItem_Split_Bearer
	{
		static constexpr const char* name() {return "split_Bearer_t";}
		using parent_t = E_RABs_Admitted_ToBeModified_ModAckItem_Split_Bearer;

	};
	void clear()
	{
		switch(get_index())
		{
		case 1: var.destroy<sCG_Bearer_t>(); break;
		case 2: var.destroy<split_Bearer_t>(); break;
		}
		index = 0;
		base::clear();
	}
	template<typename V> bool decode(size_t idx, V& v)
	{
		clear();
		switch(idx)
		{
		case 1: set_index(1); return v(var.build<sCG_Bearer_t>());
		case 2: set_index(2); return v(var.build<split_Bearer_t>());
		}
		return false;

	}
	template<typename V> bool encode(V& v) const
	{
		switch(get_index())
		{
		case 1: return v(var.as<sCG_Bearer_t>());
		case 2: return v(var.as<split_Bearer_t>());
		}
		return false;
	}
	template<typename V> static inline void enumerate(V& v)
	{
		v.template operator()<sCG_Bearer_t>(1);
		v.template operator()<split_Bearer_t>(2);

	}
	sCG_Bearer_t& select_sCG_Bearer() { if(get_index() != 1) { clear(); set_index(1); return var.build<sCG_Bearer_t>();} return var.as<sCG_Bearer_t>();}
	sCG_Bearer_t const* get_sCG_Bearer() const { if(get_index() == 1) { return &var.as<sCG_Bearer_t>();} return nullptr; }
	split_Bearer_t& select_split_Bearer() { if(get_index() != 2) { clear(); set_index(2); return var.build<split_Bearer_t>();} return var.as<split_Bearer_t>();}
	split_Bearer_t const* get_split_Bearer() const { if(get_index() == 2) { return &var.as<split_Bearer_t>();} return nullptr; }
	private:
	void set_index(index_type i) {index = i; base::set();}
	union union_type
	{
		char dummy1[sizeof(sCG_Bearer_t)];
		char dummy2[sizeof(split_Bearer_t)];

	};
	asn::variant<sizeof(union_type)>	var;
	index_type	index {0};
};
/*
E-RABs-Admitted-ToBeModified-ModAckItemIEs X2AP-PROTOCOL-IES ::= {
	{ ID id-E-RABs-Admitted-ToBeModified-ModAckItem		CRITICALITY ignore	TYPE E-RABs-Admitted-ToBeModified-ModAckItem	PRESENCE mandatory}
}
*/

struct E_RABs_Admitted_ToBeModified_ModAckItemIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, false>
	{
		size_t get_index() const {return type;}
		void clear() {type = 0;}
		void select_id_E_RABs_Admitted_ToBeModified_ModAckItem() { set(id_E_RABs_Admitted_ToBeModified_ModAckItem); type=1;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_E_RABs_Admitted_ToBeModified_ModAckItem)) { type = 1; return true; }
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_E_RABs_Admitted_ToBeModified_ModAckItem);} return false;
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, false>
	{
		size_t get_index() const {return type;}
		void clear() {type = 0;}
		void select_id_E_RABs_Admitted_ToBeModified_ModAckItem() { set(ignore); type=1;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<false>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		E_RABs_Admitted_ToBeModified_ModAckItem& select_id_E_RABs_Admitted_ToBeModified_ModAckItem() { return set<E_RABs_Admitted_ToBeModified_ModAckItem>(1); }
		E_RABs_Admitted_ToBeModified_ModAckItem const* get_id_E_RABs_Admitted_ToBeModified_ModAckItem() const { return get<E_RABs_Admitted_ToBeModified_ModAckItem>(1); }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<E_RABs_Admitted_ToBeModified_ModAckItem>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<E_RABs_Admitted_ToBeModified_ModAckItem>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_E_RABs_Admitted_ToBeModified_ModAckItem()); return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<E_RABs_Admitted_ToBeModified_ModAckItem>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(E_RABs_Admitted_ToBeModified_ModAckItem)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, false>
	{
		size_t get_index() const {return type;}
		void clear() {type = 0;}
		void select_id_E_RABs_Admitted_ToBeModified_ModAckItem() { set(mandatory); type=1;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-Admitted-ToBeModified-ModAckList ::= SEQUENCE (SIZE (1..maxnoofBearers)) OF ProtocolIE-Single-Container { {E-RABs-Admitted-ToBeModified-ModAckItemIEs} }
*/

struct E_RABs_Admitted_ToBeModified_ModAckList_elm : ProtocolIE_Single_Container<E_RABs_Admitted_ToBeModified_ModAckItemIEs>
{
	static constexpr const char* name() {return "E_RABs_Admitted_ToBeModified_ModAckList_elm";}
	using parent_t = ProtocolIE_Single_Container<E_RABs_Admitted_ToBeModified_ModAckItemIEs>;

};
struct E_RABs_Admitted_ToBeModified_ModAckList : asn::sequenceof<E_RABs_Admitted_ToBeModified_ModAckList_elm>
{
	static constexpr const char* name() {return "E-RABs-Admitted-ToBeModified-ModAckList";}
	using parent_t = asn::sequenceof<E_RABs_Admitted_ToBeModified_ModAckList_elm>;
	using constraint_t = asn::constraints<false,asn::span<1,  maxnoofBearers >>;

};
/*
E-RABs-Admitted-ToBeModified-SgNBModAck-Item-SgNBPDCPpresentExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	{ ID id-uLpDCPSnLength							CRITICALITY ignore	EXTENSION PDCPSnLength					PRESENCE optional}|
	{ ID id-dLPDCPSnLength							CRITICALITY ignore	EXTENSION PDCPSnLength					PRESENCE optional},
	...
}
*/

struct E_RABs_Admitted_ToBeModified_SgNBModAck_Item_SgNBPDCPpresentExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 3; }
		void clear() {type = 0;}
		void select_id_uLpDCPSnLength() { set(id_uLpDCPSnLength); type=1;}
		void select_id_dLPDCPSnLength() { set(id_dLPDCPSnLength); type=2;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_uLpDCPSnLength)) { type = 1; return true; }
			else if(equal(id_dLPDCPSnLength)) { type = 2; return true; }
			else { type = 3; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_uLpDCPSnLength);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_dLPDCPSnLength);} return false;
			case 3: type = 3; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 3; }
		void clear() {type = 0;}
		void select_id_uLpDCPSnLength() { set(ignore); type=1;}
		void select_id_dLPDCPSnLength() { set(ignore); type=2;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else if(equal(ignore)) { type = 2; return true; }
			else { type = 3; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(ignore);} return false;
			case 3: type = 3; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		PDCPSnLength& select_id_uLpDCPSnLength() { return set<PDCPSnLength>(1); }
		PDCPSnLength const* get_id_uLpDCPSnLength() const { return get<PDCPSnLength>(1); }
		PDCPSnLength& select_id_dLPDCPSnLength() { return set<PDCPSnLength>(2); }
		PDCPSnLength const* get_id_dLPDCPSnLength() const { return get<PDCPSnLength>(2); }
		bool is_unknown() const { return type == 3; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<PDCPSnLength>(); break;
			case 2: var.destroy<PDCPSnLength>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<PDCPSnLength>(1);
			v.template operator()<PDCPSnLength>(2);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_uLpDCPSnLength()); return true;
			case 2: v(select_id_dLPDCPSnLength()); return true;
			case 3: if(type != 3) {clear(); asn::base::set();} type = 3; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<PDCPSnLength>()); return true;
			case 2: v(var.as<PDCPSnLength>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(PDCPSnLength)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 3; }
		void clear() {type = 0;}
		void select_id_uLpDCPSnLength() { set(optional); type=1;}
		void select_id_dLPDCPSnLength() { set(optional); type=2;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(optional)) { type = 1; return true; }
			else if(equal(optional)) { type = 2; return true; }
			else { type = 3; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(optional);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(optional);} return false;
			case 3: type = 3; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-Admitted-ToBeModified-SgNBModAck-Item-SgNBPDCPpresent ::= SEQUENCE {
	s1-DL-GTPtunnelEndpoint					GTPtunnelEndpoint																						OPTIONAL,
	sgNB-UL-GTP-TEIDatPDCP					GTPtunnelEndpoint																						OPTIONAL,
	mCG-E-RAB-Level-QoS-Parameters			E-RAB-Level-QoS-Parameters																				OPTIONAL,
	uL-Configuration							ULConfiguration																							OPTIONAL,
	iE-Extensions					ProtocolExtensionContainer { {E-RABs-Admitted-ToBeModified-SgNBModAck-Item-SgNBPDCPpresentExtIEs} } 	OPTIONAL,
	...
}
*/

struct E_RABs_Admitted_ToBeModified_SgNBModAck_Item_SgNBPDCPpresent : asn::sequence<5, 0, true, 5>
{
	static constexpr const char* name() {return "E-RABs-Admitted-ToBeModified-SgNBModAck-Item-SgNBPDCPpresent";}
	using parent_t = asn::sequence<5, 0, true, 5>;
	struct s1_DL_GTPtunnelEndpoint_t : GTPtunnelEndpoint
	{
		static constexpr const char* name() {return "s1_DL_GTPtunnelEndpoint_t";}
		using parent_t = GTPtunnelEndpoint;
		static constexpr bool optional = true;

	};
	s1_DL_GTPtunnelEndpoint_t& set_s1_DL_GTPtunnelEndpoint() { s1_DL_GTPtunnelEndpoint.setpresent(true); return s1_DL_GTPtunnelEndpoint;}
	s1_DL_GTPtunnelEndpoint_t const* get_s1_DL_GTPtunnelEndpoint() const {return s1_DL_GTPtunnelEndpoint.is_valid() ? &s1_DL_GTPtunnelEndpoint : nullptr;}
	struct sgNB_UL_GTP_TEIDatPDCP_t : GTPtunnelEndpoint
	{
		static constexpr const char* name() {return "sgNB_UL_GTP_TEIDatPDCP_t";}
		using parent_t = GTPtunnelEndpoint;
		static constexpr bool optional = true;

	};
	sgNB_UL_GTP_TEIDatPDCP_t& set_sgNB_UL_GTP_TEIDatPDCP() { sgNB_UL_GTP_TEIDatPDCP.setpresent(true); return sgNB_UL_GTP_TEIDatPDCP;}
	sgNB_UL_GTP_TEIDatPDCP_t const* get_sgNB_UL_GTP_TEIDatPDCP() const {return sgNB_UL_GTP_TEIDatPDCP.is_valid() ? &sgNB_UL_GTP_TEIDatPDCP : nullptr;}
	struct mCG_E_RAB_Level_QoS_Parameters_t : E_RAB_Level_QoS_Parameters
	{
		static constexpr const char* name() {return "mCG_E_RAB_Level_QoS_Parameters_t";}
		using parent_t = E_RAB_Level_QoS_Parameters;
		static constexpr bool optional = true;

	};
	mCG_E_RAB_Level_QoS_Parameters_t& set_mCG_E_RAB_Level_QoS_Parameters() { mCG_E_RAB_Level_QoS_Parameters.setpresent(true); return mCG_E_RAB_Level_QoS_Parameters;}
	mCG_E_RAB_Level_QoS_Parameters_t const* get_mCG_E_RAB_Level_QoS_Parameters() const {return mCG_E_RAB_Level_QoS_Parameters.is_valid() ? &mCG_E_RAB_Level_QoS_Parameters : nullptr;}
	struct uL_Configuration_t : ULConfiguration
	{
		static constexpr const char* name() {return "uL_Configuration_t";}
		using parent_t = ULConfiguration;
		static constexpr bool optional = true;

	};
	uL_Configuration_t& set_uL_Configuration() { uL_Configuration.setpresent(true); return uL_Configuration;}
	uL_Configuration_t const* get_uL_Configuration() const {return uL_Configuration.is_valid() ? &uL_Configuration : nullptr;}
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_Admitted_ToBeModified_SgNBModAck_Item_SgNBPDCPpresentExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_Admitted_ToBeModified_SgNBModAck_Item_SgNBPDCPpresentExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(s1_DL_GTPtunnelEndpoint);
		v(sgNB_UL_GTP_TEIDatPDCP);
		v(mCG_E_RAB_Level_QoS_Parameters);
		v(uL_Configuration);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(s1_DL_GTPtunnelEndpoint);
		v(sgNB_UL_GTP_TEIDatPDCP);
		v(mCG_E_RAB_Level_QoS_Parameters);
		v(uL_Configuration);
		v(iE_Extensions);

	};
	void clear()
	{
		s1_DL_GTPtunnelEndpoint.clear();
		sgNB_UL_GTP_TEIDatPDCP.clear();
		mCG_E_RAB_Level_QoS_Parameters.clear();
		uL_Configuration.clear();
		iE_Extensions.clear();

	};
	private:
	s1_DL_GTPtunnelEndpoint_t	s1_DL_GTPtunnelEndpoint;
	sgNB_UL_GTP_TEIDatPDCP_t	sgNB_UL_GTP_TEIDatPDCP;
	mCG_E_RAB_Level_QoS_Parameters_t	mCG_E_RAB_Level_QoS_Parameters;
	uL_Configuration_t	uL_Configuration;
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-Admitted-ToBeModified-SgNBModAck-Item-SgNBPDCPnotpresentExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	{ ID id-secondarysgNBDLGTPTEIDatPDCP			CRITICALITY ignore	EXTENSION GTPtunnelEndpoint				PRESENCE optional}|
	{ ID id-RLC-Status								CRITICALITY ignore			EXTENSION RLC-Status				PRESENCE optional },
	...
}
*/

struct E_RABs_Admitted_ToBeModified_SgNBModAck_Item_SgNBPDCPnotpresentExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 3; }
		void clear() {type = 0;}
		void select_id_secondarysgNBDLGTPTEIDatPDCP() { set(id_secondarysgNBDLGTPTEIDatPDCP); type=1;}
		void select_id_RLC_Status() { set(id_RLC_Status); type=2;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_secondarysgNBDLGTPTEIDatPDCP)) { type = 1; return true; }
			else if(equal(id_RLC_Status)) { type = 2; return true; }
			else { type = 3; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_secondarysgNBDLGTPTEIDatPDCP);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_RLC_Status);} return false;
			case 3: type = 3; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 3; }
		void clear() {type = 0;}
		void select_id_secondarysgNBDLGTPTEIDatPDCP() { set(ignore); type=1;}
		void select_id_RLC_Status() { set(ignore); type=2;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else if(equal(ignore)) { type = 2; return true; }
			else { type = 3; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(ignore);} return false;
			case 3: type = 3; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		GTPtunnelEndpoint& select_id_secondarysgNBDLGTPTEIDatPDCP() { return set<GTPtunnelEndpoint>(1); }
		GTPtunnelEndpoint const* get_id_secondarysgNBDLGTPTEIDatPDCP() const { return get<GTPtunnelEndpoint>(1); }
		RLC_Status& select_id_RLC_Status() { return set<RLC_Status>(2); }
		RLC_Status const* get_id_RLC_Status() const { return get<RLC_Status>(2); }
		bool is_unknown() const { return type == 3; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<GTPtunnelEndpoint>(); break;
			case 2: var.destroy<RLC_Status>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<GTPtunnelEndpoint>(1);
			v.template operator()<RLC_Status>(2);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_secondarysgNBDLGTPTEIDatPDCP()); return true;
			case 2: v(select_id_RLC_Status()); return true;
			case 3: if(type != 3) {clear(); asn::base::set();} type = 3; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<GTPtunnelEndpoint>()); return true;
			case 2: v(var.as<RLC_Status>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(GTPtunnelEndpoint)];
			char dummy2[sizeof(RLC_Status)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 3; }
		void clear() {type = 0;}
		void select_id_secondarysgNBDLGTPTEIDatPDCP() { set(optional); type=1;}
		void select_id_RLC_Status() { set(optional); type=2;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(optional)) { type = 1; return true; }
			else if(equal(optional)) { type = 2; return true; }
			else { type = 3; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(optional);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(optional);} return false;
			case 3: type = 3; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-Admitted-ToBeModified-SgNBModAck-Item-SgNBPDCPnotpresent ::= SEQUENCE {
	sgNB-DL-GTP-TEIDatSCG					GTPtunnelEndpoint																								OPTIONAL,
	iE-Extensions					ProtocolExtensionContainer { {E-RABs-Admitted-ToBeModified-SgNBModAck-Item-SgNBPDCPnotpresentExtIEs} } 	OPTIONAL,
	...
}
*/

struct E_RABs_Admitted_ToBeModified_SgNBModAck_Item_SgNBPDCPnotpresent : asn::sequence<2, 0, true, 2>
{
	static constexpr const char* name() {return "E-RABs-Admitted-ToBeModified-SgNBModAck-Item-SgNBPDCPnotpresent";}
	using parent_t = asn::sequence<2, 0, true, 2>;
	struct sgNB_DL_GTP_TEIDatSCG_t : GTPtunnelEndpoint
	{
		static constexpr const char* name() {return "sgNB_DL_GTP_TEIDatSCG_t";}
		using parent_t = GTPtunnelEndpoint;
		static constexpr bool optional = true;

	};
	sgNB_DL_GTP_TEIDatSCG_t& set_sgNB_DL_GTP_TEIDatSCG() { sgNB_DL_GTP_TEIDatSCG.setpresent(true); return sgNB_DL_GTP_TEIDatSCG;}
	sgNB_DL_GTP_TEIDatSCG_t const* get_sgNB_DL_GTP_TEIDatSCG() const {return sgNB_DL_GTP_TEIDatSCG.is_valid() ? &sgNB_DL_GTP_TEIDatSCG : nullptr;}
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_Admitted_ToBeModified_SgNBModAck_Item_SgNBPDCPnotpresentExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_Admitted_ToBeModified_SgNBModAck_Item_SgNBPDCPnotpresentExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(sgNB_DL_GTP_TEIDatSCG);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(sgNB_DL_GTP_TEIDatSCG);
		v(iE_Extensions);

	};
	void clear()
	{
		sgNB_DL_GTP_TEIDatSCG.clear();
		iE_Extensions.clear();

	};
	private:
	sgNB_DL_GTP_TEIDatSCG_t	sgNB_DL_GTP_TEIDatSCG;
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-ToBeAdded-SgNBModAck-ItemExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct E_RABs_ToBeAdded_SgNBModAck_ItemExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-Admitted-ToBeModified-SgNBModAck-Item ::= SEQUENCE {
	e-RAB-ID								E-RAB-ID,
	en-DC-ResourceConfiguration			EN-DC-ResourceConfiguration,
	resource-configuration				CHOICE {
		sgNBPDCPpresent						E-RABs-Admitted-ToBeModified-SgNBModAck-Item-SgNBPDCPpresent,
		sgNBPDCPnotpresent					E-RABs-Admitted-ToBeModified-SgNBModAck-Item-SgNBPDCPnotpresent,
		...
	},
	iE-Extensions					ProtocolExtensionContainer { {E-RABs-ToBeAdded-SgNBModAck-ItemExtIEs} }	OPTIONAL,
	...
}
*/

struct E_RABs_Admitted_ToBeModified_SgNBModAck_Item : asn::sequence<4, 0, true, 1>
{
	static constexpr const char* name() {return "E-RABs-Admitted-ToBeModified-SgNBModAck-Item";}
	using parent_t = asn::sequence<4, 0, true, 1>;
	struct e_RAB_ID_t : E_RAB_ID
	{
		static constexpr const char* name() {return "e_RAB_ID_t";}
		using parent_t = E_RAB_ID;

	};
	e_RAB_ID_t& ref_e_RAB_ID() {return e_RAB_ID;}
	e_RAB_ID_t const& ref_e_RAB_ID() const {return e_RAB_ID;}
	struct en_DC_ResourceConfiguration_t : EN_DC_ResourceConfiguration
	{
		static constexpr const char* name() {return "en_DC_ResourceConfiguration_t";}
		using parent_t = EN_DC_ResourceConfiguration;

	};
	en_DC_ResourceConfiguration_t& ref_en_DC_ResourceConfiguration() {return en_DC_ResourceConfiguration;}
	en_DC_ResourceConfiguration_t const& ref_en_DC_ResourceConfiguration() const {return en_DC_ResourceConfiguration;}
	struct resource_configuration_t : asn::choice<2, 0, true>
	{
		static constexpr const char* name() {return "resource_configuration_t";}
		using parent_t = asn::choice<2, 0, true>;
		index_type get_index() const {return index;}
		bool is_unknown() const {return index == 3;}
		void set_unknown() { set_index(3);  }
		~resource_configuration_t() {clear();}
		struct sgNBPDCPpresent_t : E_RABs_Admitted_ToBeModified_SgNBModAck_Item_SgNBPDCPpresent
		{
			static constexpr const char* name() {return "sgNBPDCPpresent_t";}
			using parent_t = E_RABs_Admitted_ToBeModified_SgNBModAck_Item_SgNBPDCPpresent;

		};
		struct sgNBPDCPnotpresent_t : E_RABs_Admitted_ToBeModified_SgNBModAck_Item_SgNBPDCPnotpresent
		{
			static constexpr const char* name() {return "sgNBPDCPnotpresent_t";}
			using parent_t = E_RABs_Admitted_ToBeModified_SgNBModAck_Item_SgNBPDCPnotpresent;

		};
		void clear()
		{
			switch(get_index())
			{
			case 1: var.destroy<sgNBPDCPpresent_t>(); break;
			case 2: var.destroy<sgNBPDCPnotpresent_t>(); break;
			}
			index = 0;
			base::clear();
		}
		template<typename V> bool decode(size_t idx, V& v)
		{
			clear();
			switch(idx)
			{
			case 1: set_index(1); return v(var.build<sgNBPDCPpresent_t>());
			case 2: set_index(2); return v(var.build<sgNBPDCPnotpresent_t>());
			}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			switch(get_index())
			{
			case 1: return v(var.as<sgNBPDCPpresent_t>());
			case 2: return v(var.as<sgNBPDCPnotpresent_t>());
			}
			return false;
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<sgNBPDCPpresent_t>(1);
			v.template operator()<sgNBPDCPnotpresent_t>(2);

		}
		sgNBPDCPpresent_t& select_sgNBPDCPpresent() { if(get_index() != 1) { clear(); set_index(1); return var.build<sgNBPDCPpresent_t>();} return var.as<sgNBPDCPpresent_t>();}
		sgNBPDCPpresent_t const* get_sgNBPDCPpresent() const { if(get_index() == 1) { return &var.as<sgNBPDCPpresent_t>();} return nullptr; }
		sgNBPDCPnotpresent_t& select_sgNBPDCPnotpresent() { if(get_index() != 2) { clear(); set_index(2); return var.build<sgNBPDCPnotpresent_t>();} return var.as<sgNBPDCPnotpresent_t>();}
		sgNBPDCPnotpresent_t const* get_sgNBPDCPnotpresent() const { if(get_index() == 2) { return &var.as<sgNBPDCPnotpresent_t>();} return nullptr; }
		private:
		void set_index(index_type i) {index = i; base::set();}
		union union_type
		{
			char dummy1[sizeof(sgNBPDCPpresent_t)];
			char dummy2[sizeof(sgNBPDCPnotpresent_t)];

		};
		asn::variant<sizeof(union_type)>	var;
		index_type	index {0};
	};
	resource_configuration_t& ref_resource_configuration() {return resource_configuration;}
	resource_configuration_t const& ref_resource_configuration() const {return resource_configuration;}
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_ToBeAdded_SgNBModAck_ItemExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_ToBeAdded_SgNBModAck_ItemExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(e_RAB_ID);
		v(en_DC_ResourceConfiguration);
		v(resource_configuration);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(e_RAB_ID);
		v(en_DC_ResourceConfiguration);
		v(resource_configuration);
		v(iE_Extensions);

	};
	void clear()
	{
		e_RAB_ID.clear();
		en_DC_ResourceConfiguration.clear();
		resource_configuration.clear();
		iE_Extensions.clear();

	};
	private:
	e_RAB_ID_t	e_RAB_ID;
	en_DC_ResourceConfiguration_t	en_DC_ResourceConfiguration;
	resource_configuration_t	resource_configuration;
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-Admitted-ToBeModified-SgNBModAck-ItemIEs X2AP-PROTOCOL-IES ::= {
	{ ID id-E-RABs-Admitted-ToBeModified-SgNBModAck-Item		CRITICALITY ignore	TYPE E-RABs-Admitted-ToBeModified-SgNBModAck-Item		PRESENCE mandatory}
}
*/

struct E_RABs_Admitted_ToBeModified_SgNBModAck_ItemIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, false>
	{
		size_t get_index() const {return type;}
		void clear() {type = 0;}
		void select_id_E_RABs_Admitted_ToBeModified_SgNBModAck_Item() { set(id_E_RABs_Admitted_ToBeModified_SgNBModAck_Item); type=1;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_E_RABs_Admitted_ToBeModified_SgNBModAck_Item)) { type = 1; return true; }
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_E_RABs_Admitted_ToBeModified_SgNBModAck_Item);} return false;
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, false>
	{
		size_t get_index() const {return type;}
		void clear() {type = 0;}
		void select_id_E_RABs_Admitted_ToBeModified_SgNBModAck_Item() { set(ignore); type=1;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<false>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		E_RABs_Admitted_ToBeModified_SgNBModAck_Item& select_id_E_RABs_Admitted_ToBeModified_SgNBModAck_Item() { return set<E_RABs_Admitted_ToBeModified_SgNBModAck_Item>(1); }
		E_RABs_Admitted_ToBeModified_SgNBModAck_Item const* get_id_E_RABs_Admitted_ToBeModified_SgNBModAck_Item() const { return get<E_RABs_Admitted_ToBeModified_SgNBModAck_Item>(1); }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<E_RABs_Admitted_ToBeModified_SgNBModAck_Item>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<E_RABs_Admitted_ToBeModified_SgNBModAck_Item>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_E_RABs_Admitted_ToBeModified_SgNBModAck_Item()); return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<E_RABs_Admitted_ToBeModified_SgNBModAck_Item>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(E_RABs_Admitted_ToBeModified_SgNBModAck_Item)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, false>
	{
		size_t get_index() const {return type;}
		void clear() {type = 0;}
		void select_id_E_RABs_Admitted_ToBeModified_SgNBModAck_Item() { set(mandatory); type=1;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-Admitted-ToBeModified-SgNBModAckList ::= SEQUENCE (SIZE (1..maxnoofBearers)) OF ProtocolIE-Single-Container { {E-RABs-Admitted-ToBeModified-SgNBModAck-ItemIEs} }
*/

struct E_RABs_Admitted_ToBeModified_SgNBModAckList_elm : ProtocolIE_Single_Container<E_RABs_Admitted_ToBeModified_SgNBModAck_ItemIEs>
{
	static constexpr const char* name() {return "E_RABs_Admitted_ToBeModified_SgNBModAckList_elm";}
	using parent_t = ProtocolIE_Single_Container<E_RABs_Admitted_ToBeModified_SgNBModAck_ItemIEs>;

};
struct E_RABs_Admitted_ToBeModified_SgNBModAckList : asn::sequenceof<E_RABs_Admitted_ToBeModified_SgNBModAckList_elm>
{
	static constexpr const char* name() {return "E-RABs-Admitted-ToBeModified-SgNBModAckList";}
	using parent_t = asn::sequenceof<E_RABs_Admitted_ToBeModified_SgNBModAckList_elm>;
	using constraint_t = asn::constraints<false,asn::span<1,  maxnoofBearers >>;

};
/*
E-RABs-Admitted-ToBeReleased-ModAckItem-SCG-BearerExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct E_RABs_Admitted_ToBeReleased_ModAckItem_SCG_BearerExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-Admitted-ToBeReleased-ModAckItem-SCG-Bearer ::= SEQUENCE {
	e-RAB-ID					E-RAB-ID,
	iE-Extensions				ProtocolExtensionContainer { {E-RABs-Admitted-ToBeReleased-ModAckItem-SCG-BearerExtIEs} }	OPTIONAL,
	...
}
*/

struct E_RABs_Admitted_ToBeReleased_ModAckItem_SCG_Bearer : asn::sequence<2, 0, true, 1>
{
	static constexpr const char* name() {return "E-RABs-Admitted-ToBeReleased-ModAckItem-SCG-Bearer";}
	using parent_t = asn::sequence<2, 0, true, 1>;
	struct e_RAB_ID_t : E_RAB_ID
	{
		static constexpr const char* name() {return "e_RAB_ID_t";}
		using parent_t = E_RAB_ID;

	};
	e_RAB_ID_t& ref_e_RAB_ID() {return e_RAB_ID;}
	e_RAB_ID_t const& ref_e_RAB_ID() const {return e_RAB_ID;}
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_Admitted_ToBeReleased_ModAckItem_SCG_BearerExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_Admitted_ToBeReleased_ModAckItem_SCG_BearerExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(e_RAB_ID);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(e_RAB_ID);
		v(iE_Extensions);

	};
	void clear()
	{
		e_RAB_ID.clear();
		iE_Extensions.clear();

	};
	private:
	e_RAB_ID_t	e_RAB_ID;
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-Admitted-ToBeReleased-ModAckItem-Split-BearerExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct E_RABs_Admitted_ToBeReleased_ModAckItem_Split_BearerExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-Admitted-ToBeReleased-ModAckItem-Split-Bearer ::= SEQUENCE {
	e-RAB-ID					E-RAB-ID,
	iE-Extensions				ProtocolExtensionContainer { {E-RABs-Admitted-ToBeReleased-ModAckItem-Split-BearerExtIEs} } OPTIONAL,
	...
}
*/

struct E_RABs_Admitted_ToBeReleased_ModAckItem_Split_Bearer : asn::sequence<2, 0, true, 1>
{
	static constexpr const char* name() {return "E-RABs-Admitted-ToBeReleased-ModAckItem-Split-Bearer";}
	using parent_t = asn::sequence<2, 0, true, 1>;
	struct e_RAB_ID_t : E_RAB_ID
	{
		static constexpr const char* name() {return "e_RAB_ID_t";}
		using parent_t = E_RAB_ID;

	};
	e_RAB_ID_t& ref_e_RAB_ID() {return e_RAB_ID;}
	e_RAB_ID_t const& ref_e_RAB_ID() const {return e_RAB_ID;}
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_Admitted_ToBeReleased_ModAckItem_Split_BearerExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_Admitted_ToBeReleased_ModAckItem_Split_BearerExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(e_RAB_ID);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(e_RAB_ID);
		v(iE_Extensions);

	};
	void clear()
	{
		e_RAB_ID.clear();
		iE_Extensions.clear();

	};
	private:
	e_RAB_ID_t	e_RAB_ID;
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-Admitted-ToReleased-ModAckItem ::= CHOICE {
	sCG-Bearer		E-RABs-Admitted-ToBeReleased-ModAckItem-SCG-Bearer,
	split-Bearer	E-RABs-Admitted-ToBeReleased-ModAckItem-Split-Bearer,
	...
}
*/

struct E_RABs_Admitted_ToReleased_ModAckItem : asn::choice<2, 0, true>
{
	static constexpr const char* name() {return "E-RABs-Admitted-ToReleased-ModAckItem";}
	using parent_t = asn::choice<2, 0, true>;
	index_type get_index() const {return index;}
	bool is_unknown() const {return index == 3;}
	void set_unknown() { set_index(3);  }
	~E_RABs_Admitted_ToReleased_ModAckItem() {clear();}
	struct sCG_Bearer_t : E_RABs_Admitted_ToBeReleased_ModAckItem_SCG_Bearer
	{
		static constexpr const char* name() {return "sCG_Bearer_t";}
		using parent_t = E_RABs_Admitted_ToBeReleased_ModAckItem_SCG_Bearer;

	};
	struct split_Bearer_t : E_RABs_Admitted_ToBeReleased_ModAckItem_Split_Bearer
	{
		static constexpr const char* name() {return "split_Bearer_t";}
		using parent_t = E_RABs_Admitted_ToBeReleased_ModAckItem_Split_Bearer;

	};
	void clear()
	{
		switch(get_index())
		{
		case 1: var.destroy<sCG_Bearer_t>(); break;
		case 2: var.destroy<split_Bearer_t>(); break;
		}
		index = 0;
		base::clear();
	}
	template<typename V> bool decode(size_t idx, V& v)
	{
		clear();
		switch(idx)
		{
		case 1: set_index(1); return v(var.build<sCG_Bearer_t>());
		case 2: set_index(2); return v(var.build<split_Bearer_t>());
		}
		return false;

	}
	template<typename V> bool encode(V& v) const
	{
		switch(get_index())
		{
		case 1: return v(var.as<sCG_Bearer_t>());
		case 2: return v(var.as<split_Bearer_t>());
		}
		return false;
	}
	template<typename V> static inline void enumerate(V& v)
	{
		v.template operator()<sCG_Bearer_t>(1);
		v.template operator()<split_Bearer_t>(2);

	}
	sCG_Bearer_t& select_sCG_Bearer() { if(get_index() != 1) { clear(); set_index(1); return var.build<sCG_Bearer_t>();} return var.as<sCG_Bearer_t>();}
	sCG_Bearer_t const* get_sCG_Bearer() const { if(get_index() == 1) { return &var.as<sCG_Bearer_t>();} return nullptr; }
	split_Bearer_t& select_split_Bearer() { if(get_index() != 2) { clear(); set_index(2); return var.build<split_Bearer_t>();} return var.as<split_Bearer_t>();}
	split_Bearer_t const* get_split_Bearer() const { if(get_index() == 2) { return &var.as<split_Bearer_t>();} return nullptr; }
	private:
	void set_index(index_type i) {index = i; base::set();}
	union union_type
	{
		char dummy1[sizeof(sCG_Bearer_t)];
		char dummy2[sizeof(split_Bearer_t)];

	};
	asn::variant<sizeof(union_type)>	var;
	index_type	index {0};
};
/*
E-RABs-Admitted-ToBeReleased-ModAckItemIEs X2AP-PROTOCOL-IES ::= {
	{ ID id-E-RABs-Admitted-ToBeReleased-ModAckItem		CRITICALITY ignore	TYPE E-RABs-Admitted-ToReleased-ModAckItem		PRESENCE mandatory}
}
*/

struct E_RABs_Admitted_ToBeReleased_ModAckItemIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, false>
	{
		size_t get_index() const {return type;}
		void clear() {type = 0;}
		void select_id_E_RABs_Admitted_ToBeReleased_ModAckItem() { set(id_E_RABs_Admitted_ToBeReleased_ModAckItem); type=1;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_E_RABs_Admitted_ToBeReleased_ModAckItem)) { type = 1; return true; }
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_E_RABs_Admitted_ToBeReleased_ModAckItem);} return false;
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, false>
	{
		size_t get_index() const {return type;}
		void clear() {type = 0;}
		void select_id_E_RABs_Admitted_ToBeReleased_ModAckItem() { set(ignore); type=1;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<false>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		E_RABs_Admitted_ToReleased_ModAckItem& select_id_E_RABs_Admitted_ToBeReleased_ModAckItem() { return set<E_RABs_Admitted_ToReleased_ModAckItem>(1); }
		E_RABs_Admitted_ToReleased_ModAckItem const* get_id_E_RABs_Admitted_ToBeReleased_ModAckItem() const { return get<E_RABs_Admitted_ToReleased_ModAckItem>(1); }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<E_RABs_Admitted_ToReleased_ModAckItem>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<E_RABs_Admitted_ToReleased_ModAckItem>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_E_RABs_Admitted_ToBeReleased_ModAckItem()); return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<E_RABs_Admitted_ToReleased_ModAckItem>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(E_RABs_Admitted_ToReleased_ModAckItem)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, false>
	{
		size_t get_index() const {return type;}
		void clear() {type = 0;}
		void select_id_E_RABs_Admitted_ToBeReleased_ModAckItem() { set(mandatory); type=1;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-Admitted-ToBeReleased-ModAckList ::= SEQUENCE (SIZE (1..maxnoofBearers)) OF ProtocolIE-Single-Container { {E-RABs-Admitted-ToBeReleased-ModAckItemIEs} }
*/

struct E_RABs_Admitted_ToBeReleased_ModAckList_elm : ProtocolIE_Single_Container<E_RABs_Admitted_ToBeReleased_ModAckItemIEs>
{
	static constexpr const char* name() {return "E_RABs_Admitted_ToBeReleased_ModAckList_elm";}
	using parent_t = ProtocolIE_Single_Container<E_RABs_Admitted_ToBeReleased_ModAckItemIEs>;

};
struct E_RABs_Admitted_ToBeReleased_ModAckList : asn::sequenceof<E_RABs_Admitted_ToBeReleased_ModAckList_elm>
{
	static constexpr const char* name() {return "E-RABs-Admitted-ToBeReleased-ModAckList";}
	using parent_t = asn::sequenceof<E_RABs_Admitted_ToBeReleased_ModAckList_elm>;
	using constraint_t = asn::constraints<false,asn::span<1,  maxnoofBearers >>;

};
/*
E-RABs-Admitted-ToBeReleased-SgNBModAck-Item-SgNBPDCPnotpresentExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct E_RABs_Admitted_ToBeReleased_SgNBModAck_Item_SgNBPDCPnotpresentExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-Admitted-ToBeReleased-SgNBModAck-Item-SgNBPDCPnotpresent ::= SEQUENCE {
	iE-Extensions				ProtocolExtensionContainer { {E-RABs-Admitted-ToBeReleased-SgNBModAck-Item-SgNBPDCPnotpresentExtIEs} } OPTIONAL,
	...
}
*/

struct E_RABs_Admitted_ToBeReleased_SgNBModAck_Item_SgNBPDCPnotpresent : asn::sequence<1, 0, true, 1>
{
	static constexpr const char* name() {return "E-RABs-Admitted-ToBeReleased-SgNBModAck-Item-SgNBPDCPnotpresent";}
	using parent_t = asn::sequence<1, 0, true, 1>;
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_Admitted_ToBeReleased_SgNBModAck_Item_SgNBPDCPnotpresentExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_Admitted_ToBeReleased_SgNBModAck_Item_SgNBPDCPnotpresentExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(iE_Extensions);

	};
	void clear()
	{
		iE_Extensions.clear();

	};
	private:
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-Admitted-ToBeReleased-SgNBModAck-Item-SgNBPDCPpresentExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct E_RABs_Admitted_ToBeReleased_SgNBModAck_Item_SgNBPDCPpresentExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-Admitted-ToBeReleased-SgNBModAck-Item-SgNBPDCPpresent ::= SEQUENCE {
	iE-Extensions				ProtocolExtensionContainer { {E-RABs-Admitted-ToBeReleased-SgNBModAck-Item-SgNBPDCPpresentExtIEs} }		OPTIONAL,
	...
}
*/

struct E_RABs_Admitted_ToBeReleased_SgNBModAck_Item_SgNBPDCPpresent : asn::sequence<1, 0, true, 1>
{
	static constexpr const char* name() {return "E-RABs-Admitted-ToBeReleased-SgNBModAck-Item-SgNBPDCPpresent";}
	using parent_t = asn::sequence<1, 0, true, 1>;
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_Admitted_ToBeReleased_SgNBModAck_Item_SgNBPDCPpresentExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_Admitted_ToBeReleased_SgNBModAck_Item_SgNBPDCPpresentExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(iE_Extensions);

	};
	void clear()
	{
		iE_Extensions.clear();

	};
	private:
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-ToBeReleased-SgNBModAck-ItemExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct E_RABs_ToBeReleased_SgNBModAck_ItemExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-Admitted-ToReleased-SgNBModAck-Item ::= SEQUENCE {
	e-RAB-ID							E-RAB-ID,
	en-DC-ResourceConfiguration			EN-DC-ResourceConfiguration,
	resource-configuration				CHOICE {
		sgNBPDCPpresent						E-RABs-Admitted-ToBeReleased-SgNBModAck-Item-SgNBPDCPpresent,
		sgNBPDCPnotpresent					E-RABs-Admitted-ToBeReleased-SgNBModAck-Item-SgNBPDCPnotpresent,
		...
	},
	iE-Extensions					ProtocolExtensionContainer { {E-RABs-ToBeReleased-SgNBModAck-ItemExtIEs} }	OPTIONAL,
	...
}
*/

struct E_RABs_Admitted_ToReleased_SgNBModAck_Item : asn::sequence<4, 0, true, 1>
{
	static constexpr const char* name() {return "E-RABs-Admitted-ToReleased-SgNBModAck-Item";}
	using parent_t = asn::sequence<4, 0, true, 1>;
	struct e_RAB_ID_t : E_RAB_ID
	{
		static constexpr const char* name() {return "e_RAB_ID_t";}
		using parent_t = E_RAB_ID;

	};
	e_RAB_ID_t& ref_e_RAB_ID() {return e_RAB_ID;}
	e_RAB_ID_t const& ref_e_RAB_ID() const {return e_RAB_ID;}
	struct en_DC_ResourceConfiguration_t : EN_DC_ResourceConfiguration
	{
		static constexpr const char* name() {return "en_DC_ResourceConfiguration_t";}
		using parent_t = EN_DC_ResourceConfiguration;

	};
	en_DC_ResourceConfiguration_t& ref_en_DC_ResourceConfiguration() {return en_DC_ResourceConfiguration;}
	en_DC_ResourceConfiguration_t const& ref_en_DC_ResourceConfiguration() const {return en_DC_ResourceConfiguration;}
	struct resource_configuration_t : asn::choice<2, 0, true>
	{
		static constexpr const char* name() {return "resource_configuration_t";}
		using parent_t = asn::choice<2, 0, true>;
		index_type get_index() const {return index;}
		bool is_unknown() const {return index == 3;}
		void set_unknown() { set_index(3);  }
		~resource_configuration_t() {clear();}
		struct sgNBPDCPpresent_t : E_RABs_Admitted_ToBeReleased_SgNBModAck_Item_SgNBPDCPpresent
		{
			static constexpr const char* name() {return "sgNBPDCPpresent_t";}
			using parent_t = E_RABs_Admitted_ToBeReleased_SgNBModAck_Item_SgNBPDCPpresent;

		};
		struct sgNBPDCPnotpresent_t : E_RABs_Admitted_ToBeReleased_SgNBModAck_Item_SgNBPDCPnotpresent
		{
			static constexpr const char* name() {return "sgNBPDCPnotpresent_t";}
			using parent_t = E_RABs_Admitted_ToBeReleased_SgNBModAck_Item_SgNBPDCPnotpresent;

		};
		void clear()
		{
			switch(get_index())
			{
			case 1: var.destroy<sgNBPDCPpresent_t>(); break;
			case 2: var.destroy<sgNBPDCPnotpresent_t>(); break;
			}
			index = 0;
			base::clear();
		}
		template<typename V> bool decode(size_t idx, V& v)
		{
			clear();
			switch(idx)
			{
			case 1: set_index(1); return v(var.build<sgNBPDCPpresent_t>());
			case 2: set_index(2); return v(var.build<sgNBPDCPnotpresent_t>());
			}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			switch(get_index())
			{
			case 1: return v(var.as<sgNBPDCPpresent_t>());
			case 2: return v(var.as<sgNBPDCPnotpresent_t>());
			}
			return false;
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<sgNBPDCPpresent_t>(1);
			v.template operator()<sgNBPDCPnotpresent_t>(2);

		}
		sgNBPDCPpresent_t& select_sgNBPDCPpresent() { if(get_index() != 1) { clear(); set_index(1); return var.build<sgNBPDCPpresent_t>();} return var.as<sgNBPDCPpresent_t>();}
		sgNBPDCPpresent_t const* get_sgNBPDCPpresent() const { if(get_index() == 1) { return &var.as<sgNBPDCPpresent_t>();} return nullptr; }
		sgNBPDCPnotpresent_t& select_sgNBPDCPnotpresent() { if(get_index() != 2) { clear(); set_index(2); return var.build<sgNBPDCPnotpresent_t>();} return var.as<sgNBPDCPnotpresent_t>();}
		sgNBPDCPnotpresent_t const* get_sgNBPDCPnotpresent() const { if(get_index() == 2) { return &var.as<sgNBPDCPnotpresent_t>();} return nullptr; }
		private:
		void set_index(index_type i) {index = i; base::set();}
		union union_type
		{
			char dummy1[sizeof(sgNBPDCPpresent_t)];
			char dummy2[sizeof(sgNBPDCPnotpresent_t)];

		};
		asn::variant<sizeof(union_type)>	var;
		index_type	index {0};
	};
	resource_configuration_t& ref_resource_configuration() {return resource_configuration;}
	resource_configuration_t const& ref_resource_configuration() const {return resource_configuration;}
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_ToBeReleased_SgNBModAck_ItemExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_ToBeReleased_SgNBModAck_ItemExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(e_RAB_ID);
		v(en_DC_ResourceConfiguration);
		v(resource_configuration);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(e_RAB_ID);
		v(en_DC_ResourceConfiguration);
		v(resource_configuration);
		v(iE_Extensions);

	};
	void clear()
	{
		e_RAB_ID.clear();
		en_DC_ResourceConfiguration.clear();
		resource_configuration.clear();
		iE_Extensions.clear();

	};
	private:
	e_RAB_ID_t	e_RAB_ID;
	en_DC_ResourceConfiguration_t	en_DC_ResourceConfiguration;
	resource_configuration_t	resource_configuration;
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-Admitted-ToBeReleased-SgNBModAck-ItemIEs X2AP-PROTOCOL-IES ::= {
	{ ID id-E-RABs-Admitted-ToBeReleased-SgNBModAck-Item		CRITICALITY ignore	TYPE E-RABs-Admitted-ToReleased-SgNBModAck-Item		PRESENCE mandatory}
}
*/

struct E_RABs_Admitted_ToBeReleased_SgNBModAck_ItemIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, false>
	{
		size_t get_index() const {return type;}
		void clear() {type = 0;}
		void select_id_E_RABs_Admitted_ToBeReleased_SgNBModAck_Item() { set(id_E_RABs_Admitted_ToBeReleased_SgNBModAck_Item); type=1;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_E_RABs_Admitted_ToBeReleased_SgNBModAck_Item)) { type = 1; return true; }
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_E_RABs_Admitted_ToBeReleased_SgNBModAck_Item);} return false;
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, false>
	{
		size_t get_index() const {return type;}
		void clear() {type = 0;}
		void select_id_E_RABs_Admitted_ToBeReleased_SgNBModAck_Item() { set(ignore); type=1;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<false>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		E_RABs_Admitted_ToReleased_SgNBModAck_Item& select_id_E_RABs_Admitted_ToBeReleased_SgNBModAck_Item() { return set<E_RABs_Admitted_ToReleased_SgNBModAck_Item>(1); }
		E_RABs_Admitted_ToReleased_SgNBModAck_Item const* get_id_E_RABs_Admitted_ToBeReleased_SgNBModAck_Item() const { return get<E_RABs_Admitted_ToReleased_SgNBModAck_Item>(1); }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<E_RABs_Admitted_ToReleased_SgNBModAck_Item>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<E_RABs_Admitted_ToReleased_SgNBModAck_Item>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_E_RABs_Admitted_ToBeReleased_SgNBModAck_Item()); return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<E_RABs_Admitted_ToReleased_SgNBModAck_Item>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(E_RABs_Admitted_ToReleased_SgNBModAck_Item)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, false>
	{
		size_t get_index() const {return type;}
		void clear() {type = 0;}
		void select_id_E_RABs_Admitted_ToBeReleased_SgNBModAck_Item() { set(mandatory); type=1;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-Admitted-ToBeReleased-SgNBModAckList ::= SEQUENCE (SIZE (1..maxnoofBearers)) OF ProtocolIE-Single-Container { {E-RABs-Admitted-ToBeReleased-SgNBModAck-ItemIEs} }
*/

struct E_RABs_Admitted_ToBeReleased_SgNBModAckList_elm : ProtocolIE_Single_Container<E_RABs_Admitted_ToBeReleased_SgNBModAck_ItemIEs>
{
	static constexpr const char* name() {return "E_RABs_Admitted_ToBeReleased_SgNBModAckList_elm";}
	using parent_t = ProtocolIE_Single_Container<E_RABs_Admitted_ToBeReleased_SgNBModAck_ItemIEs>;

};
struct E_RABs_Admitted_ToBeReleased_SgNBModAckList : asn::sequenceof<E_RABs_Admitted_ToBeReleased_SgNBModAckList_elm>
{
	static constexpr const char* name() {return "E-RABs-Admitted-ToBeReleased-SgNBModAckList";}
	using parent_t = asn::sequenceof<E_RABs_Admitted_ToBeReleased_SgNBModAckList_elm>;
	using constraint_t = asn::constraints<false,asn::span<1,  maxnoofBearers >>;

};
/*
E-RABs-Admitted-ToBeReleased-SgNBRelReqAck-ItemExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct E_RABs_Admitted_ToBeReleased_SgNBRelReqAck_ItemExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-Admitted-ToBeReleased-SgNBRelReqAck-Item ::= SEQUENCE {
	e-RAB-ID							E-RAB-ID,
	rlc-Mode-transferred			RLCMode,
	iE-Extensions					ProtocolExtensionContainer { {E-RABs-Admitted-ToBeReleased-SgNBRelReqAck-ItemExtIEs} }	OPTIONAL,
	...
}
*/

struct E_RABs_Admitted_ToBeReleased_SgNBRelReqAck_Item : asn::sequence<3, 0, true, 1>
{
	static constexpr const char* name() {return "E-RABs-Admitted-ToBeReleased-SgNBRelReqAck-Item";}
	using parent_t = asn::sequence<3, 0, true, 1>;
	struct e_RAB_ID_t : E_RAB_ID
	{
		static constexpr const char* name() {return "e_RAB_ID_t";}
		using parent_t = E_RAB_ID;

	};
	e_RAB_ID_t& ref_e_RAB_ID() {return e_RAB_ID;}
	e_RAB_ID_t const& ref_e_RAB_ID() const {return e_RAB_ID;}
	struct rlc_Mode_transferred_t : RLCMode
	{
		static constexpr const char* name() {return "rlc_Mode_transferred_t";}
		using parent_t = RLCMode;

	};
	rlc_Mode_transferred_t& ref_rlc_Mode_transferred() {return rlc_Mode_transferred;}
	rlc_Mode_transferred_t const& ref_rlc_Mode_transferred() const {return rlc_Mode_transferred;}
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_Admitted_ToBeReleased_SgNBRelReqAck_ItemExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_Admitted_ToBeReleased_SgNBRelReqAck_ItemExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(e_RAB_ID);
		v(rlc_Mode_transferred);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(e_RAB_ID);
		v(rlc_Mode_transferred);
		v(iE_Extensions);

	};
	void clear()
	{
		e_RAB_ID.clear();
		rlc_Mode_transferred.clear();
		iE_Extensions.clear();

	};
	private:
	e_RAB_ID_t	e_RAB_ID;
	rlc_Mode_transferred_t	rlc_Mode_transferred;
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-Admitted-ToBeReleased-SgNBRelReqAck-ItemIEs X2AP-PROTOCOL-IES ::= {
	{ ID id-E-RABs-Admitted-ToBeReleased-SgNBRelReqAck-Item	CRITICALITY ignore	TYPE E-RABs-Admitted-ToBeReleased-SgNBRelReqAck-Item		PRESENCE mandatory},
	...
}
*/

struct E_RABs_Admitted_ToBeReleased_SgNBRelReqAck_ItemIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_Admitted_ToBeReleased_SgNBRelReqAck_Item() { set(id_E_RABs_Admitted_ToBeReleased_SgNBRelReqAck_Item); type=1;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_E_RABs_Admitted_ToBeReleased_SgNBRelReqAck_Item)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_E_RABs_Admitted_ToBeReleased_SgNBRelReqAck_Item);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_Admitted_ToBeReleased_SgNBRelReqAck_Item() { set(ignore); type=1;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		E_RABs_Admitted_ToBeReleased_SgNBRelReqAck_Item& select_id_E_RABs_Admitted_ToBeReleased_SgNBRelReqAck_Item() { return set<E_RABs_Admitted_ToBeReleased_SgNBRelReqAck_Item>(1); }
		E_RABs_Admitted_ToBeReleased_SgNBRelReqAck_Item const* get_id_E_RABs_Admitted_ToBeReleased_SgNBRelReqAck_Item() const { return get<E_RABs_Admitted_ToBeReleased_SgNBRelReqAck_Item>(1); }
		bool is_unknown() const { return type == 2; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<E_RABs_Admitted_ToBeReleased_SgNBRelReqAck_Item>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<E_RABs_Admitted_ToBeReleased_SgNBRelReqAck_Item>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_E_RABs_Admitted_ToBeReleased_SgNBRelReqAck_Item()); return true;
			case 2: if(type != 2) {clear(); asn::base::set();} type = 2; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<E_RABs_Admitted_ToBeReleased_SgNBRelReqAck_Item>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(E_RABs_Admitted_ToBeReleased_SgNBRelReqAck_Item)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_Admitted_ToBeReleased_SgNBRelReqAck_Item() { set(mandatory); type=1;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-Admitted-ToBeReleased-SgNBRelReqAckList ::= SEQUENCE (SIZE(1..maxnoofBearers)) OF
										ProtocolIE-Single-Container { {E-RABs-Admitted-ToBeReleased-SgNBRelReqAck-ItemIEs} }
*/

struct E_RABs_Admitted_ToBeReleased_SgNBRelReqAckList_elm : ProtocolIE_Single_Container<E_RABs_Admitted_ToBeReleased_SgNBRelReqAck_ItemIEs>
{
	static constexpr const char* name() {return "E_RABs_Admitted_ToBeReleased_SgNBRelReqAckList_elm";}
	using parent_t = ProtocolIE_Single_Container<E_RABs_Admitted_ToBeReleased_SgNBRelReqAck_ItemIEs>;

};
struct E_RABs_Admitted_ToBeReleased_SgNBRelReqAckList : asn::sequenceof<E_RABs_Admitted_ToBeReleased_SgNBRelReqAckList_elm>
{
	static constexpr const char* name() {return "E-RABs-Admitted-ToBeReleased-SgNBRelReqAckList";}
	using parent_t = asn::sequenceof<E_RABs_Admitted_ToBeReleased_SgNBRelReqAckList_elm>;
	using constraint_t = asn::constraints<false,asn::span<1,  maxnoofBearers >>;

};
/*
E-RABs-AdmittedToBeModified-SgNBModConf-Item-SgNBPDCPpresentExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct E_RABs_AdmittedToBeModified_SgNBModConf_Item_SgNBPDCPpresentExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-AdmittedToBeModified-SgNBModConf-Item-SgNBPDCPpresent ::= SEQUENCE {
	iE-Extensions				ProtocolExtensionContainer { {E-RABs-AdmittedToBeModified-SgNBModConf-Item-SgNBPDCPpresentExtIEs} }		OPTIONAL,
	...
}
*/

struct E_RABs_AdmittedToBeModified_SgNBModConf_Item_SgNBPDCPpresent : asn::sequence<1, 0, true, 1>
{
	static constexpr const char* name() {return "E-RABs-AdmittedToBeModified-SgNBModConf-Item-SgNBPDCPpresent";}
	using parent_t = asn::sequence<1, 0, true, 1>;
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_AdmittedToBeModified_SgNBModConf_Item_SgNBPDCPpresentExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_AdmittedToBeModified_SgNBModConf_Item_SgNBPDCPpresentExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(iE_Extensions);

	};
	void clear()
	{
		iE_Extensions.clear();

	};
	private:
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-AdmittedToBeModified-SgNBModConf-Item-SgNBPDCPnotpresentExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	{ ID id-uLpDCPSnLength							CRITICALITY ignore	EXTENSION PDCPSnLength					PRESENCE optional}|
	{ ID id-dLPDCPSnLength							CRITICALITY ignore	EXTENSION PDCPSnLength					PRESENCE optional},
	...
}
*/

struct E_RABs_AdmittedToBeModified_SgNBModConf_Item_SgNBPDCPnotpresentExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 3; }
		void clear() {type = 0;}
		void select_id_uLpDCPSnLength() { set(id_uLpDCPSnLength); type=1;}
		void select_id_dLPDCPSnLength() { set(id_dLPDCPSnLength); type=2;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_uLpDCPSnLength)) { type = 1; return true; }
			else if(equal(id_dLPDCPSnLength)) { type = 2; return true; }
			else { type = 3; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_uLpDCPSnLength);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_dLPDCPSnLength);} return false;
			case 3: type = 3; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 3; }
		void clear() {type = 0;}
		void select_id_uLpDCPSnLength() { set(ignore); type=1;}
		void select_id_dLPDCPSnLength() { set(ignore); type=2;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else if(equal(ignore)) { type = 2; return true; }
			else { type = 3; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(ignore);} return false;
			case 3: type = 3; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		PDCPSnLength& select_id_uLpDCPSnLength() { return set<PDCPSnLength>(1); }
		PDCPSnLength const* get_id_uLpDCPSnLength() const { return get<PDCPSnLength>(1); }
		PDCPSnLength& select_id_dLPDCPSnLength() { return set<PDCPSnLength>(2); }
		PDCPSnLength const* get_id_dLPDCPSnLength() const { return get<PDCPSnLength>(2); }
		bool is_unknown() const { return type == 3; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<PDCPSnLength>(); break;
			case 2: var.destroy<PDCPSnLength>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<PDCPSnLength>(1);
			v.template operator()<PDCPSnLength>(2);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_uLpDCPSnLength()); return true;
			case 2: v(select_id_dLPDCPSnLength()); return true;
			case 3: if(type != 3) {clear(); asn::base::set();} type = 3; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<PDCPSnLength>()); return true;
			case 2: v(var.as<PDCPSnLength>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(PDCPSnLength)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 3; }
		void clear() {type = 0;}
		void select_id_uLpDCPSnLength() { set(optional); type=1;}
		void select_id_dLPDCPSnLength() { set(optional); type=2;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(optional)) { type = 1; return true; }
			else if(equal(optional)) { type = 2; return true; }
			else { type = 3; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(optional);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(optional);} return false;
			case 3: type = 3; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-AdmittedToBeModified-SgNBModConf-Item-SgNBPDCPnotpresent ::= SEQUENCE {
	secondary-meNB-UL-GTP-TEIDatPDCP				GTPtunnelEndpoint				OPTIONAL,
	iE-Extensions				ProtocolExtensionContainer { {E-RABs-AdmittedToBeModified-SgNBModConf-Item-SgNBPDCPnotpresentExtIEs} }		OPTIONAL,
	...
}
*/

struct E_RABs_AdmittedToBeModified_SgNBModConf_Item_SgNBPDCPnotpresent : asn::sequence<2, 0, true, 2>
{
	static constexpr const char* name() {return "E-RABs-AdmittedToBeModified-SgNBModConf-Item-SgNBPDCPnotpresent";}
	using parent_t = asn::sequence<2, 0, true, 2>;
	struct secondary_meNB_UL_GTP_TEIDatPDCP_t : GTPtunnelEndpoint
	{
		static constexpr const char* name() {return "secondary_meNB_UL_GTP_TEIDatPDCP_t";}
		using parent_t = GTPtunnelEndpoint;
		static constexpr bool optional = true;

	};
	secondary_meNB_UL_GTP_TEIDatPDCP_t& set_secondary_meNB_UL_GTP_TEIDatPDCP() { secondary_meNB_UL_GTP_TEIDatPDCP.setpresent(true); return secondary_meNB_UL_GTP_TEIDatPDCP;}
	secondary_meNB_UL_GTP_TEIDatPDCP_t const* get_secondary_meNB_UL_GTP_TEIDatPDCP() const {return secondary_meNB_UL_GTP_TEIDatPDCP.is_valid() ? &secondary_meNB_UL_GTP_TEIDatPDCP : nullptr;}
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_AdmittedToBeModified_SgNBModConf_Item_SgNBPDCPnotpresentExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_AdmittedToBeModified_SgNBModConf_Item_SgNBPDCPnotpresentExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(secondary_meNB_UL_GTP_TEIDatPDCP);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(secondary_meNB_UL_GTP_TEIDatPDCP);
		v(iE_Extensions);

	};
	void clear()
	{
		secondary_meNB_UL_GTP_TEIDatPDCP.clear();
		iE_Extensions.clear();

	};
	private:
	secondary_meNB_UL_GTP_TEIDatPDCP_t	secondary_meNB_UL_GTP_TEIDatPDCP;
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-AdmittedToBeModified-SgNBModConf-ItemExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct E_RABs_AdmittedToBeModified_SgNBModConf_ItemExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-AdmittedToBeModified-SgNBModConf-Item ::= SEQUENCE {
	e-RAB-ID								E-RAB-ID,
	en-DC-ResourceConfiguration			EN-DC-ResourceConfiguration,
	resource-configuration				CHOICE {
		sgNBPDCPpresent						E-RABs-AdmittedToBeModified-SgNBModConf-Item-SgNBPDCPpresent,
		sgNBPDCPnotpresent					E-RABs-AdmittedToBeModified-SgNBModConf-Item-SgNBPDCPnotpresent,
		...
	},
	iE-Extensions					ProtocolExtensionContainer { {E-RABs-AdmittedToBeModified-SgNBModConf-ItemExtIEs} }	OPTIONAL,
	...
}
*/

struct E_RABs_AdmittedToBeModified_SgNBModConf_Item : asn::sequence<4, 0, true, 1>
{
	static constexpr const char* name() {return "E-RABs-AdmittedToBeModified-SgNBModConf-Item";}
	using parent_t = asn::sequence<4, 0, true, 1>;
	struct e_RAB_ID_t : E_RAB_ID
	{
		static constexpr const char* name() {return "e_RAB_ID_t";}
		using parent_t = E_RAB_ID;

	};
	e_RAB_ID_t& ref_e_RAB_ID() {return e_RAB_ID;}
	e_RAB_ID_t const& ref_e_RAB_ID() const {return e_RAB_ID;}
	struct en_DC_ResourceConfiguration_t : EN_DC_ResourceConfiguration
	{
		static constexpr const char* name() {return "en_DC_ResourceConfiguration_t";}
		using parent_t = EN_DC_ResourceConfiguration;

	};
	en_DC_ResourceConfiguration_t& ref_en_DC_ResourceConfiguration() {return en_DC_ResourceConfiguration;}
	en_DC_ResourceConfiguration_t const& ref_en_DC_ResourceConfiguration() const {return en_DC_ResourceConfiguration;}
	struct resource_configuration_t : asn::choice<2, 0, true>
	{
		static constexpr const char* name() {return "resource_configuration_t";}
		using parent_t = asn::choice<2, 0, true>;
		index_type get_index() const {return index;}
		bool is_unknown() const {return index == 3;}
		void set_unknown() { set_index(3);  }
		~resource_configuration_t() {clear();}
		struct sgNBPDCPpresent_t : E_RABs_AdmittedToBeModified_SgNBModConf_Item_SgNBPDCPpresent
		{
			static constexpr const char* name() {return "sgNBPDCPpresent_t";}
			using parent_t = E_RABs_AdmittedToBeModified_SgNBModConf_Item_SgNBPDCPpresent;

		};
		struct sgNBPDCPnotpresent_t : E_RABs_AdmittedToBeModified_SgNBModConf_Item_SgNBPDCPnotpresent
		{
			static constexpr const char* name() {return "sgNBPDCPnotpresent_t";}
			using parent_t = E_RABs_AdmittedToBeModified_SgNBModConf_Item_SgNBPDCPnotpresent;

		};
		void clear()
		{
			switch(get_index())
			{
			case 1: var.destroy<sgNBPDCPpresent_t>(); break;
			case 2: var.destroy<sgNBPDCPnotpresent_t>(); break;
			}
			index = 0;
			base::clear();
		}
		template<typename V> bool decode(size_t idx, V& v)
		{
			clear();
			switch(idx)
			{
			case 1: set_index(1); return v(var.build<sgNBPDCPpresent_t>());
			case 2: set_index(2); return v(var.build<sgNBPDCPnotpresent_t>());
			}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			switch(get_index())
			{
			case 1: return v(var.as<sgNBPDCPpresent_t>());
			case 2: return v(var.as<sgNBPDCPnotpresent_t>());
			}
			return false;
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<sgNBPDCPpresent_t>(1);
			v.template operator()<sgNBPDCPnotpresent_t>(2);

		}
		sgNBPDCPpresent_t& select_sgNBPDCPpresent() { if(get_index() != 1) { clear(); set_index(1); return var.build<sgNBPDCPpresent_t>();} return var.as<sgNBPDCPpresent_t>();}
		sgNBPDCPpresent_t const* get_sgNBPDCPpresent() const { if(get_index() == 1) { return &var.as<sgNBPDCPpresent_t>();} return nullptr; }
		sgNBPDCPnotpresent_t& select_sgNBPDCPnotpresent() { if(get_index() != 2) { clear(); set_index(2); return var.build<sgNBPDCPnotpresent_t>();} return var.as<sgNBPDCPnotpresent_t>();}
		sgNBPDCPnotpresent_t const* get_sgNBPDCPnotpresent() const { if(get_index() == 2) { return &var.as<sgNBPDCPnotpresent_t>();} return nullptr; }
		private:
		void set_index(index_type i) {index = i; base::set();}
		union union_type
		{
			char dummy1[sizeof(sgNBPDCPpresent_t)];
			char dummy2[sizeof(sgNBPDCPnotpresent_t)];

		};
		asn::variant<sizeof(union_type)>	var;
		index_type	index {0};
	};
	resource_configuration_t& ref_resource_configuration() {return resource_configuration;}
	resource_configuration_t const& ref_resource_configuration() const {return resource_configuration;}
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_AdmittedToBeModified_SgNBModConf_ItemExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_AdmittedToBeModified_SgNBModConf_ItemExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(e_RAB_ID);
		v(en_DC_ResourceConfiguration);
		v(resource_configuration);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(e_RAB_ID);
		v(en_DC_ResourceConfiguration);
		v(resource_configuration);
		v(iE_Extensions);

	};
	void clear()
	{
		e_RAB_ID.clear();
		en_DC_ResourceConfiguration.clear();
		resource_configuration.clear();
		iE_Extensions.clear();

	};
	private:
	e_RAB_ID_t	e_RAB_ID;
	en_DC_ResourceConfiguration_t	en_DC_ResourceConfiguration;
	resource_configuration_t	resource_configuration;
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-AdmittedToBeModified-SgNBModConf-ItemIEs X2AP-PROTOCOL-IES ::= {
{ ID id-E-RABs-AdmittedToBeModified-SgNBModConf-Item	 CRITICALITY ignore	TYPE E-RABs-AdmittedToBeModified-SgNBModConf-Item	 PRESENCE mandatory },
	...
}
*/

struct E_RABs_AdmittedToBeModified_SgNBModConf_ItemIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_AdmittedToBeModified_SgNBModConf_Item() { set(id_E_RABs_AdmittedToBeModified_SgNBModConf_Item); type=1;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_E_RABs_AdmittedToBeModified_SgNBModConf_Item)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_E_RABs_AdmittedToBeModified_SgNBModConf_Item);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_AdmittedToBeModified_SgNBModConf_Item() { set(ignore); type=1;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		E_RABs_AdmittedToBeModified_SgNBModConf_Item& select_id_E_RABs_AdmittedToBeModified_SgNBModConf_Item() { return set<E_RABs_AdmittedToBeModified_SgNBModConf_Item>(1); }
		E_RABs_AdmittedToBeModified_SgNBModConf_Item const* get_id_E_RABs_AdmittedToBeModified_SgNBModConf_Item() const { return get<E_RABs_AdmittedToBeModified_SgNBModConf_Item>(1); }
		bool is_unknown() const { return type == 2; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<E_RABs_AdmittedToBeModified_SgNBModConf_Item>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<E_RABs_AdmittedToBeModified_SgNBModConf_Item>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_E_RABs_AdmittedToBeModified_SgNBModConf_Item()); return true;
			case 2: if(type != 2) {clear(); asn::base::set();} type = 2; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<E_RABs_AdmittedToBeModified_SgNBModConf_Item>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(E_RABs_AdmittedToBeModified_SgNBModConf_Item)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_AdmittedToBeModified_SgNBModConf_Item() { set(mandatory); type=1;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-AdmittedToBeModified-SgNBModConfList ::= SEQUENCE (SIZE (1..maxnoofBearers)) OF ProtocolIE-Single-Container
	{ {E-RABs-AdmittedToBeModified-SgNBModConf-ItemIEs} }
*/

struct E_RABs_AdmittedToBeModified_SgNBModConfList_elm : ProtocolIE_Single_Container<E_RABs_AdmittedToBeModified_SgNBModConf_ItemIEs>
{
	static constexpr const char* name() {return "E_RABs_AdmittedToBeModified_SgNBModConfList_elm";}
	using parent_t = ProtocolIE_Single_Container<E_RABs_AdmittedToBeModified_SgNBModConf_ItemIEs>;

};
struct E_RABs_AdmittedToBeModified_SgNBModConfList : asn::sequenceof<E_RABs_AdmittedToBeModified_SgNBModConfList_elm>
{
	static constexpr const char* name() {return "E-RABs-AdmittedToBeModified-SgNBModConfList";}
	using parent_t = asn::sequenceof<E_RABs_AdmittedToBeModified_SgNBModConfList_elm>;
	using constraint_t = asn::constraints<false,asn::span<1,  maxnoofBearers >>;

};
/*
E-RABs-SubjectToCounterCheckItemExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct E_RABs_SubjectToCounterCheckItemExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-SubjectToCounterCheckItem ::= SEQUENCE {
	e-RAB-ID						E-RAB-ID,
	uL-Count						INTEGER (0..4294967295),
	dL-Count						INTEGER (0..4294967295),
	iE-Extensions					ProtocolExtensionContainer { {E-RABs-SubjectToCounterCheckItemExtIEs} } OPTIONAL,
	...
}
*/

struct E_RABs_SubjectToCounterCheckItem : asn::sequence<4, 0, true, 1>
{
	static constexpr const char* name() {return "E-RABs-SubjectToCounterCheckItem";}
	using parent_t = asn::sequence<4, 0, true, 1>;
	struct e_RAB_ID_t : E_RAB_ID
	{
		static constexpr const char* name() {return "e_RAB_ID_t";}
		using parent_t = E_RAB_ID;

	};
	e_RAB_ID_t& ref_e_RAB_ID() {return e_RAB_ID;}
	e_RAB_ID_t const& ref_e_RAB_ID() const {return e_RAB_ID;}
	struct uL_Count_t : asn::integer<>
	{
		using constraint_t = asn::constraints<false,asn::span<0, 4294967295>>;
		static constexpr const char* name() {return "uL_Count_t";}
		using parent_t = asn::integer<>;

	};

	uL_Count_t& ref_uL_Count() {return uL_Count;}
	uL_Count_t const& ref_uL_Count() const {return uL_Count;}
	struct dL_Count_t : asn::integer<>
	{
		using constraint_t = asn::constraints<false,asn::span<0, 4294967295>>;
		static constexpr const char* name() {return "dL_Count_t";}
		using parent_t = asn::integer<>;

	};

	dL_Count_t& ref_dL_Count() {return dL_Count;}
	dL_Count_t const& ref_dL_Count() const {return dL_Count;}
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_SubjectToCounterCheckItemExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_SubjectToCounterCheckItemExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(e_RAB_ID);
		v(uL_Count);
		v(dL_Count);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(e_RAB_ID);
		v(uL_Count);
		v(dL_Count);
		v(iE_Extensions);

	};
	void clear()
	{
		e_RAB_ID.clear();
		uL_Count.clear();
		dL_Count.clear();
		iE_Extensions.clear();

	};
	private:
	e_RAB_ID_t	e_RAB_ID;
	uL_Count_t	uL_Count;
	dL_Count_t	dL_Count;
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-SubjectToCounterCheckItemIEs X2AP-PROTOCOL-IES ::= {
	{ ID id-E-RABs-SubjectToCounterCheckItem	CRITICALITY ignore	TYPE E-RABs-SubjectToCounterCheckItem		PRESENCE mandatory},
	...
}
*/

struct E_RABs_SubjectToCounterCheckItemIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_SubjectToCounterCheckItem() { set(id_E_RABs_SubjectToCounterCheckItem); type=1;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_E_RABs_SubjectToCounterCheckItem)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_E_RABs_SubjectToCounterCheckItem);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_SubjectToCounterCheckItem() { set(ignore); type=1;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		E_RABs_SubjectToCounterCheckItem& select_id_E_RABs_SubjectToCounterCheckItem() { return set<E_RABs_SubjectToCounterCheckItem>(1); }
		E_RABs_SubjectToCounterCheckItem const* get_id_E_RABs_SubjectToCounterCheckItem() const { return get<E_RABs_SubjectToCounterCheckItem>(1); }
		bool is_unknown() const { return type == 2; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<E_RABs_SubjectToCounterCheckItem>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<E_RABs_SubjectToCounterCheckItem>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_E_RABs_SubjectToCounterCheckItem()); return true;
			case 2: if(type != 2) {clear(); asn::base::set();} type = 2; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<E_RABs_SubjectToCounterCheckItem>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(E_RABs_SubjectToCounterCheckItem)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_SubjectToCounterCheckItem() { set(mandatory); type=1;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-SubjectToCounterCheck-List ::= SEQUENCE (SIZE(1..maxnoofBearers)) OF ProtocolIE-Single-Container { {E-RABs-SubjectToCounterCheckItemIEs} }
*/

struct E_RABs_SubjectToCounterCheck_List_elm : ProtocolIE_Single_Container<E_RABs_SubjectToCounterCheckItemIEs>
{
	static constexpr const char* name() {return "E_RABs_SubjectToCounterCheck_List_elm";}
	using parent_t = ProtocolIE_Single_Container<E_RABs_SubjectToCounterCheckItemIEs>;

};
struct E_RABs_SubjectToCounterCheck_List : asn::sequenceof<E_RABs_SubjectToCounterCheck_List_elm>
{
	static constexpr const char* name() {return "E-RABs-SubjectToCounterCheck-List";}
	using parent_t = asn::sequenceof<E_RABs_SubjectToCounterCheck_List_elm>;
	using constraint_t = asn::constraints<false,asn::span<1,  maxnoofBearers >>;

};
/*
E-RABs-SubjectToSgNBCounterCheck-ItemExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct E_RABs_SubjectToSgNBCounterCheck_ItemExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-SubjectToSgNBCounterCheck-Item ::= SEQUENCE {
	e-RAB-ID						E-RAB-ID,
	uL-Count						INTEGER (0..4294967295),
	dL-Count						INTEGER (0..4294967295),
	iE-Extensions					ProtocolExtensionContainer { {E-RABs-SubjectToSgNBCounterCheck-ItemExtIEs} } OPTIONAL,
	...
}
*/

struct E_RABs_SubjectToSgNBCounterCheck_Item : asn::sequence<4, 0, true, 1>
{
	static constexpr const char* name() {return "E-RABs-SubjectToSgNBCounterCheck-Item";}
	using parent_t = asn::sequence<4, 0, true, 1>;
	struct e_RAB_ID_t : E_RAB_ID
	{
		static constexpr const char* name() {return "e_RAB_ID_t";}
		using parent_t = E_RAB_ID;

	};
	e_RAB_ID_t& ref_e_RAB_ID() {return e_RAB_ID;}
	e_RAB_ID_t const& ref_e_RAB_ID() const {return e_RAB_ID;}
	struct uL_Count_t : asn::integer<>
	{
		using constraint_t = asn::constraints<false,asn::span<0, 4294967295>>;
		static constexpr const char* name() {return "uL_Count_t";}
		using parent_t = asn::integer<>;

	};

	uL_Count_t& ref_uL_Count() {return uL_Count;}
	uL_Count_t const& ref_uL_Count() const {return uL_Count;}
	struct dL_Count_t : asn::integer<>
	{
		using constraint_t = asn::constraints<false,asn::span<0, 4294967295>>;
		static constexpr const char* name() {return "dL_Count_t";}
		using parent_t = asn::integer<>;

	};

	dL_Count_t& ref_dL_Count() {return dL_Count;}
	dL_Count_t const& ref_dL_Count() const {return dL_Count;}
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_SubjectToSgNBCounterCheck_ItemExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_SubjectToSgNBCounterCheck_ItemExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(e_RAB_ID);
		v(uL_Count);
		v(dL_Count);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(e_RAB_ID);
		v(uL_Count);
		v(dL_Count);
		v(iE_Extensions);

	};
	void clear()
	{
		e_RAB_ID.clear();
		uL_Count.clear();
		dL_Count.clear();
		iE_Extensions.clear();

	};
	private:
	e_RAB_ID_t	e_RAB_ID;
	uL_Count_t	uL_Count;
	dL_Count_t	dL_Count;
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-SubjectToSgNBCounterCheck-ItemIEs X2AP-PROTOCOL-IES ::= {
	{ ID id-E-RABs-SubjectToSgNBCounterCheck-Item		CRITICALITY ignore	TYPE E-RABs-SubjectToSgNBCounterCheck-Item		PRESENCE mandatory},
	...
}
*/

struct E_RABs_SubjectToSgNBCounterCheck_ItemIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_SubjectToSgNBCounterCheck_Item() { set(id_E_RABs_SubjectToSgNBCounterCheck_Item); type=1;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_E_RABs_SubjectToSgNBCounterCheck_Item)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_E_RABs_SubjectToSgNBCounterCheck_Item);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_SubjectToSgNBCounterCheck_Item() { set(ignore); type=1;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		E_RABs_SubjectToSgNBCounterCheck_Item& select_id_E_RABs_SubjectToSgNBCounterCheck_Item() { return set<E_RABs_SubjectToSgNBCounterCheck_Item>(1); }
		E_RABs_SubjectToSgNBCounterCheck_Item const* get_id_E_RABs_SubjectToSgNBCounterCheck_Item() const { return get<E_RABs_SubjectToSgNBCounterCheck_Item>(1); }
		bool is_unknown() const { return type == 2; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<E_RABs_SubjectToSgNBCounterCheck_Item>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<E_RABs_SubjectToSgNBCounterCheck_Item>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_E_RABs_SubjectToSgNBCounterCheck_Item()); return true;
			case 2: if(type != 2) {clear(); asn::base::set();} type = 2; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<E_RABs_SubjectToSgNBCounterCheck_Item>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(E_RABs_SubjectToSgNBCounterCheck_Item)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_SubjectToSgNBCounterCheck_Item() { set(mandatory); type=1;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-SubjectToSgNBCounterCheck-List ::= SEQUENCE (SIZE(1..maxnoofBearers)) OF ProtocolIE-Single-Container { {E-RABs-SubjectToSgNBCounterCheck-ItemIEs} }
*/

struct E_RABs_SubjectToSgNBCounterCheck_List_elm : ProtocolIE_Single_Container<E_RABs_SubjectToSgNBCounterCheck_ItemIEs>
{
	static constexpr const char* name() {return "E_RABs_SubjectToSgNBCounterCheck_List_elm";}
	using parent_t = ProtocolIE_Single_Container<E_RABs_SubjectToSgNBCounterCheck_ItemIEs>;

};
struct E_RABs_SubjectToSgNBCounterCheck_List : asn::sequenceof<E_RABs_SubjectToSgNBCounterCheck_List_elm>
{
	static constexpr const char* name() {return "E-RABs-SubjectToSgNBCounterCheck-List";}
	using parent_t = asn::sequenceof<E_RABs_SubjectToSgNBCounterCheck_List_elm>;
	using constraint_t = asn::constraints<false,asn::span<1,  maxnoofBearers >>;

};
/*
E-RABs-SubjectToStatusTransfer-ItemExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	{ ID id-ReceiveStatusOfULPDCPSDUsExtended			CRITICALITY ignore	EXTENSION ReceiveStatusOfULPDCPSDUsExtended			PRESENCE optional}|
	{ ID id-ULCOUNTValueExtended						CRITICALITY ignore	EXTENSION COUNTValueExtended								PRESENCE optional}|
	{ ID id-DLCOUNTValueExtended						CRITICALITY ignore	EXTENSION COUNTValueExtended								PRESENCE optional}|
	{ ID id-ReceiveStatusOfULPDCPSDUsPDCP-SNlength18	CRITICALITY ignore	EXTENSION ReceiveStatusOfULPDCPSDUsPDCP-SNlength18	PRESENCE optional}|
	{ ID id-ULCOUNTValuePDCP-SNlength18					CRITICALITY ignore	EXTENSION COUNTvaluePDCP-SNlength18						PRESENCE optional}|
	{ ID id-DLCOUNTValuePDCP-SNlength18					CRITICALITY ignore	EXTENSION COUNTvaluePDCP-SNlength18						PRESENCE optional},
	...
}
*/

struct E_RABs_SubjectToStatusTransfer_ItemExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 7; }
		void clear() {type = 0;}
		void select_id_ReceiveStatusOfULPDCPSDUsExtended() { set(id_ReceiveStatusOfULPDCPSDUsExtended); type=1;}
		void select_id_ULCOUNTValueExtended() { set(id_ULCOUNTValueExtended); type=2;}
		void select_id_DLCOUNTValueExtended() { set(id_DLCOUNTValueExtended); type=3;}
		void select_id_ReceiveStatusOfULPDCPSDUsPDCP_SNlength18() { set(id_ReceiveStatusOfULPDCPSDUsPDCP_SNlength18); type=4;}
		void select_id_ULCOUNTValuePDCP_SNlength18() { set(id_ULCOUNTValuePDCP_SNlength18); type=5;}
		void select_id_DLCOUNTValuePDCP_SNlength18() { set(id_DLCOUNTValuePDCP_SNlength18); type=6;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_ReceiveStatusOfULPDCPSDUsExtended)) { type = 1; return true; }
			else if(equal(id_ULCOUNTValueExtended)) { type = 2; return true; }
			else if(equal(id_DLCOUNTValueExtended)) { type = 3; return true; }
			else if(equal(id_ReceiveStatusOfULPDCPSDUsPDCP_SNlength18)) { type = 4; return true; }
			else if(equal(id_ULCOUNTValuePDCP_SNlength18)) { type = 5; return true; }
			else if(equal(id_DLCOUNTValuePDCP_SNlength18)) { type = 6; return true; }
			else { type = 7; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_ReceiveStatusOfULPDCPSDUsExtended);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_ULCOUNTValueExtended);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_DLCOUNTValueExtended);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(id_ReceiveStatusOfULPDCPSDUsPDCP_SNlength18);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(id_ULCOUNTValuePDCP_SNlength18);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(id_DLCOUNTValuePDCP_SNlength18);} return false;
			case 7: type = 7; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 7; }
		void clear() {type = 0;}
		void select_id_ReceiveStatusOfULPDCPSDUsExtended() { set(ignore); type=1;}
		void select_id_ULCOUNTValueExtended() { set(ignore); type=2;}
		void select_id_DLCOUNTValueExtended() { set(ignore); type=3;}
		void select_id_ReceiveStatusOfULPDCPSDUsPDCP_SNlength18() { set(ignore); type=4;}
		void select_id_ULCOUNTValuePDCP_SNlength18() { set(ignore); type=5;}
		void select_id_DLCOUNTValuePDCP_SNlength18() { set(ignore); type=6;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else if(equal(ignore)) { type = 2; return true; }
			else if(equal(ignore)) { type = 3; return true; }
			else if(equal(ignore)) { type = 4; return true; }
			else if(equal(ignore)) { type = 5; return true; }
			else if(equal(ignore)) { type = 6; return true; }
			else { type = 7; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(ignore);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(ignore);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(ignore);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(ignore);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(ignore);} return false;
			case 7: type = 7; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		ReceiveStatusOfULPDCPSDUsExtended& select_id_ReceiveStatusOfULPDCPSDUsExtended() { return set<ReceiveStatusOfULPDCPSDUsExtended>(1); }
		ReceiveStatusOfULPDCPSDUsExtended const* get_id_ReceiveStatusOfULPDCPSDUsExtended() const { return get<ReceiveStatusOfULPDCPSDUsExtended>(1); }
		COUNTValueExtended& select_id_ULCOUNTValueExtended() { return set<COUNTValueExtended>(2); }
		COUNTValueExtended const* get_id_ULCOUNTValueExtended() const { return get<COUNTValueExtended>(2); }
		COUNTValueExtended& select_id_DLCOUNTValueExtended() { return set<COUNTValueExtended>(3); }
		COUNTValueExtended const* get_id_DLCOUNTValueExtended() const { return get<COUNTValueExtended>(3); }
		ReceiveStatusOfULPDCPSDUsPDCP_SNlength18& select_id_ReceiveStatusOfULPDCPSDUsPDCP_SNlength18() { return set<ReceiveStatusOfULPDCPSDUsPDCP_SNlength18>(4); }
		ReceiveStatusOfULPDCPSDUsPDCP_SNlength18 const* get_id_ReceiveStatusOfULPDCPSDUsPDCP_SNlength18() const { return get<ReceiveStatusOfULPDCPSDUsPDCP_SNlength18>(4); }
		COUNTvaluePDCP_SNlength18& select_id_ULCOUNTValuePDCP_SNlength18() { return set<COUNTvaluePDCP_SNlength18>(5); }
		COUNTvaluePDCP_SNlength18 const* get_id_ULCOUNTValuePDCP_SNlength18() const { return get<COUNTvaluePDCP_SNlength18>(5); }
		COUNTvaluePDCP_SNlength18& select_id_DLCOUNTValuePDCP_SNlength18() { return set<COUNTvaluePDCP_SNlength18>(6); }
		COUNTvaluePDCP_SNlength18 const* get_id_DLCOUNTValuePDCP_SNlength18() const { return get<COUNTvaluePDCP_SNlength18>(6); }
		bool is_unknown() const { return type == 7; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<ReceiveStatusOfULPDCPSDUsExtended>(); break;
			case 2: var.destroy<COUNTValueExtended>(); break;
			case 3: var.destroy<COUNTValueExtended>(); break;
			case 4: var.destroy<ReceiveStatusOfULPDCPSDUsPDCP_SNlength18>(); break;
			case 5: var.destroy<COUNTvaluePDCP_SNlength18>(); break;
			case 6: var.destroy<COUNTvaluePDCP_SNlength18>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<ReceiveStatusOfULPDCPSDUsExtended>(1);
			v.template operator()<COUNTValueExtended>(2);
			v.template operator()<COUNTValueExtended>(3);
			v.template operator()<ReceiveStatusOfULPDCPSDUsPDCP_SNlength18>(4);
			v.template operator()<COUNTvaluePDCP_SNlength18>(5);
			v.template operator()<COUNTvaluePDCP_SNlength18>(6);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_ReceiveStatusOfULPDCPSDUsExtended()); return true;
			case 2: v(select_id_ULCOUNTValueExtended()); return true;
			case 3: v(select_id_DLCOUNTValueExtended()); return true;
			case 4: v(select_id_ReceiveStatusOfULPDCPSDUsPDCP_SNlength18()); return true;
			case 5: v(select_id_ULCOUNTValuePDCP_SNlength18()); return true;
			case 6: v(select_id_DLCOUNTValuePDCP_SNlength18()); return true;
			case 7: if(type != 7) {clear(); asn::base::set();} type = 7; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<ReceiveStatusOfULPDCPSDUsExtended>()); return true;
			case 2: v(var.as<COUNTValueExtended>()); return true;
			case 3: v(var.as<COUNTValueExtended>()); return true;
			case 4: v(var.as<ReceiveStatusOfULPDCPSDUsPDCP_SNlength18>()); return true;
			case 5: v(var.as<COUNTvaluePDCP_SNlength18>()); return true;
			case 6: v(var.as<COUNTvaluePDCP_SNlength18>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(COUNTValueExtended)];
			char dummy2[sizeof(COUNTvaluePDCP_SNlength18)];
			char dummy3[sizeof(ReceiveStatusOfULPDCPSDUsExtended)];
			char dummy4[sizeof(ReceiveStatusOfULPDCPSDUsPDCP_SNlength18)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 7; }
		void clear() {type = 0;}
		void select_id_ReceiveStatusOfULPDCPSDUsExtended() { set(optional); type=1;}
		void select_id_ULCOUNTValueExtended() { set(optional); type=2;}
		void select_id_DLCOUNTValueExtended() { set(optional); type=3;}
		void select_id_ReceiveStatusOfULPDCPSDUsPDCP_SNlength18() { set(optional); type=4;}
		void select_id_ULCOUNTValuePDCP_SNlength18() { set(optional); type=5;}
		void select_id_DLCOUNTValuePDCP_SNlength18() { set(optional); type=6;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(optional)) { type = 1; return true; }
			else if(equal(optional)) { type = 2; return true; }
			else if(equal(optional)) { type = 3; return true; }
			else if(equal(optional)) { type = 4; return true; }
			else if(equal(optional)) { type = 5; return true; }
			else if(equal(optional)) { type = 6; return true; }
			else { type = 7; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(optional);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(optional);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(optional);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(optional);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(optional);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(optional);} return false;
			case 7: type = 7; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-SubjectToStatusTransfer-Item ::= SEQUENCE {
	e-RAB-ID								E-RAB-ID,

	receiveStatusofULPDCPSDUs				ReceiveStatusofULPDCPSDUs			OPTIONAL,
	uL-COUNTvalue					COUNTvalue,
	dL-COUNTvalue					COUNTvalue,
	iE-Extensions							ProtocolExtensionContainer { {E-RABs-SubjectToStatusTransfer-ItemExtIEs} } OPTIONAL,
	...
}
*/

struct E_RABs_SubjectToStatusTransfer_Item : asn::sequence<5, 0, true, 2>
{
	static constexpr const char* name() {return "E-RABs-SubjectToStatusTransfer-Item";}
	using parent_t = asn::sequence<5, 0, true, 2>;
	struct e_RAB_ID_t : E_RAB_ID
	{
		static constexpr const char* name() {return "e_RAB_ID_t";}
		using parent_t = E_RAB_ID;

	};
	e_RAB_ID_t& ref_e_RAB_ID() {return e_RAB_ID;}
	e_RAB_ID_t const& ref_e_RAB_ID() const {return e_RAB_ID;}
	struct receiveStatusofULPDCPSDUs_t : ReceiveStatusofULPDCPSDUs
	{
		static constexpr const char* name() {return "receiveStatusofULPDCPSDUs_t";}
		using parent_t = ReceiveStatusofULPDCPSDUs;
		static constexpr bool optional = true;

	};
	receiveStatusofULPDCPSDUs_t& set_receiveStatusofULPDCPSDUs() { receiveStatusofULPDCPSDUs.setpresent(true); return receiveStatusofULPDCPSDUs;}
	receiveStatusofULPDCPSDUs_t const* get_receiveStatusofULPDCPSDUs() const {return receiveStatusofULPDCPSDUs.is_valid() ? &receiveStatusofULPDCPSDUs : nullptr;}
	struct uL_COUNTvalue_t : COUNTvalue
	{
		static constexpr const char* name() {return "uL_COUNTvalue_t";}
		using parent_t = COUNTvalue;

	};
	uL_COUNTvalue_t& ref_uL_COUNTvalue() {return uL_COUNTvalue;}
	uL_COUNTvalue_t const& ref_uL_COUNTvalue() const {return uL_COUNTvalue;}
	struct dL_COUNTvalue_t : COUNTvalue
	{
		static constexpr const char* name() {return "dL_COUNTvalue_t";}
		using parent_t = COUNTvalue;

	};
	dL_COUNTvalue_t& ref_dL_COUNTvalue() {return dL_COUNTvalue;}
	dL_COUNTvalue_t const& ref_dL_COUNTvalue() const {return dL_COUNTvalue;}
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_SubjectToStatusTransfer_ItemExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_SubjectToStatusTransfer_ItemExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(e_RAB_ID);
		v(receiveStatusofULPDCPSDUs);
		v(uL_COUNTvalue);
		v(dL_COUNTvalue);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(e_RAB_ID);
		v(receiveStatusofULPDCPSDUs);
		v(uL_COUNTvalue);
		v(dL_COUNTvalue);
		v(iE_Extensions);

	};
	void clear()
	{
		e_RAB_ID.clear();
		receiveStatusofULPDCPSDUs.clear();
		uL_COUNTvalue.clear();
		dL_COUNTvalue.clear();
		iE_Extensions.clear();

	};
	private:
	e_RAB_ID_t	e_RAB_ID;
	receiveStatusofULPDCPSDUs_t	receiveStatusofULPDCPSDUs;
	uL_COUNTvalue_t	uL_COUNTvalue;
	dL_COUNTvalue_t	dL_COUNTvalue;
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-SubjectToStatusTransfer-ItemIEs X2AP-PROTOCOL-IES ::= {
	{ ID id-E-RABs-SubjectToStatusTransfer-Item	CRITICALITY ignore	TYPE E-RABs-SubjectToStatusTransfer-Item 	PRESENCE mandatory	}
}
*/

struct E_RABs_SubjectToStatusTransfer_ItemIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, false>
	{
		size_t get_index() const {return type;}
		void clear() {type = 0;}
		void select_id_E_RABs_SubjectToStatusTransfer_Item() { set(id_E_RABs_SubjectToStatusTransfer_Item); type=1;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_E_RABs_SubjectToStatusTransfer_Item)) { type = 1; return true; }
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_E_RABs_SubjectToStatusTransfer_Item);} return false;
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, false>
	{
		size_t get_index() const {return type;}
		void clear() {type = 0;}
		void select_id_E_RABs_SubjectToStatusTransfer_Item() { set(ignore); type=1;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<false>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		E_RABs_SubjectToStatusTransfer_Item& select_id_E_RABs_SubjectToStatusTransfer_Item() { return set<E_RABs_SubjectToStatusTransfer_Item>(1); }
		E_RABs_SubjectToStatusTransfer_Item const* get_id_E_RABs_SubjectToStatusTransfer_Item() const { return get<E_RABs_SubjectToStatusTransfer_Item>(1); }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<E_RABs_SubjectToStatusTransfer_Item>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<E_RABs_SubjectToStatusTransfer_Item>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_E_RABs_SubjectToStatusTransfer_Item()); return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<E_RABs_SubjectToStatusTransfer_Item>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(E_RABs_SubjectToStatusTransfer_Item)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, false>
	{
		size_t get_index() const {return type;}
		void clear() {type = 0;}
		void select_id_E_RABs_SubjectToStatusTransfer_Item() { set(mandatory); type=1;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-SubjectToStatusTransfer-List	::= SEQUENCE (SIZE (1..maxnoofBearers)) OF ProtocolIE-Single-Container { {E-RABs-SubjectToStatusTransfer-ItemIEs} }
*/

struct E_RABs_SubjectToStatusTransfer_List_elm : ProtocolIE_Single_Container<E_RABs_SubjectToStatusTransfer_ItemIEs>
{
	static constexpr const char* name() {return "E_RABs_SubjectToStatusTransfer_List_elm";}
	using parent_t = ProtocolIE_Single_Container<E_RABs_SubjectToStatusTransfer_ItemIEs>;

};
struct E_RABs_SubjectToStatusTransfer_List : asn::sequenceof<E_RABs_SubjectToStatusTransfer_List_elm>
{
	static constexpr const char* name() {return "E-RABs-SubjectToStatusTransfer-List";}
	using parent_t = asn::sequenceof<E_RABs_SubjectToStatusTransfer_List_elm>;
	using constraint_t = asn::constraints<false,asn::span<1,  maxnoofBearers >>;

};
/*
E-RABs-ToBeAdded-Item-SCG-BearerExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	{ ID id-Correlation-ID				CRITICALITY ignore	EXTENSION Correlation-ID		PRESENCE optional}|
	{ ID id-SIPTO-Correlation-ID		CRITICALITY ignore	EXTENSION Correlation-ID		PRESENCE optional},
	...
}
*/

struct E_RABs_ToBeAdded_Item_SCG_BearerExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 3; }
		void clear() {type = 0;}
		void select_id_Correlation_ID() { set(id_Correlation_ID); type=1;}
		void select_id_SIPTO_Correlation_ID() { set(id_SIPTO_Correlation_ID); type=2;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_Correlation_ID)) { type = 1; return true; }
			else if(equal(id_SIPTO_Correlation_ID)) { type = 2; return true; }
			else { type = 3; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_Correlation_ID);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_SIPTO_Correlation_ID);} return false;
			case 3: type = 3; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 3; }
		void clear() {type = 0;}
		void select_id_Correlation_ID() { set(ignore); type=1;}
		void select_id_SIPTO_Correlation_ID() { set(ignore); type=2;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else if(equal(ignore)) { type = 2; return true; }
			else { type = 3; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(ignore);} return false;
			case 3: type = 3; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		Correlation_ID& select_id_Correlation_ID() { return set<Correlation_ID>(1); }
		Correlation_ID const* get_id_Correlation_ID() const { return get<Correlation_ID>(1); }
		Correlation_ID& select_id_SIPTO_Correlation_ID() { return set<Correlation_ID>(2); }
		Correlation_ID const* get_id_SIPTO_Correlation_ID() const { return get<Correlation_ID>(2); }
		bool is_unknown() const { return type == 3; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<Correlation_ID>(); break;
			case 2: var.destroy<Correlation_ID>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<Correlation_ID>(1);
			v.template operator()<Correlation_ID>(2);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_Correlation_ID()); return true;
			case 2: v(select_id_SIPTO_Correlation_ID()); return true;
			case 3: if(type != 3) {clear(); asn::base::set();} type = 3; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<Correlation_ID>()); return true;
			case 2: v(var.as<Correlation_ID>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(Correlation_ID)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 3; }
		void clear() {type = 0;}
		void select_id_Correlation_ID() { set(optional); type=1;}
		void select_id_SIPTO_Correlation_ID() { set(optional); type=2;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(optional)) { type = 1; return true; }
			else if(equal(optional)) { type = 2; return true; }
			else { type = 3; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(optional);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(optional);} return false;
			case 3: type = 3; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-ToBeAdded-Item-SCG-Bearer ::= SEQUENCE {
	e-RAB-ID						E-RAB-ID,
	e-RAB-Level-QoS-Parameters		E-RAB-Level-QoS-Parameters,
	dL-Forwarding					DL-Forwarding																	OPTIONAL,
	s1-UL-GTPtunnelEndpoint			GTPtunnelEndpoint,
	iE-Extensions					ProtocolExtensionContainer { {E-RABs-ToBeAdded-Item-SCG-BearerExtIEs} }	OPTIONAL,
	...
}
*/

struct E_RABs_ToBeAdded_Item_SCG_Bearer : asn::sequence<5, 0, true, 2>
{
	static constexpr const char* name() {return "E-RABs-ToBeAdded-Item-SCG-Bearer";}
	using parent_t = asn::sequence<5, 0, true, 2>;
	struct e_RAB_ID_t : E_RAB_ID
	{
		static constexpr const char* name() {return "e_RAB_ID_t";}
		using parent_t = E_RAB_ID;

	};
	e_RAB_ID_t& ref_e_RAB_ID() {return e_RAB_ID;}
	e_RAB_ID_t const& ref_e_RAB_ID() const {return e_RAB_ID;}
	struct e_RAB_Level_QoS_Parameters_t : E_RAB_Level_QoS_Parameters
	{
		static constexpr const char* name() {return "e_RAB_Level_QoS_Parameters_t";}
		using parent_t = E_RAB_Level_QoS_Parameters;

	};
	e_RAB_Level_QoS_Parameters_t& ref_e_RAB_Level_QoS_Parameters() {return e_RAB_Level_QoS_Parameters;}
	e_RAB_Level_QoS_Parameters_t const& ref_e_RAB_Level_QoS_Parameters() const {return e_RAB_Level_QoS_Parameters;}
	struct dL_Forwarding_t : DL_Forwarding
	{
		static constexpr const char* name() {return "dL_Forwarding_t";}
		using parent_t = DL_Forwarding;
		static constexpr bool optional = true;

	};
	dL_Forwarding_t& set_dL_Forwarding() { dL_Forwarding.setpresent(true); return dL_Forwarding;}
	dL_Forwarding_t const* get_dL_Forwarding() const {return dL_Forwarding.is_valid() ? &dL_Forwarding : nullptr;}
	struct s1_UL_GTPtunnelEndpoint_t : GTPtunnelEndpoint
	{
		static constexpr const char* name() {return "s1_UL_GTPtunnelEndpoint_t";}
		using parent_t = GTPtunnelEndpoint;

	};
	s1_UL_GTPtunnelEndpoint_t& ref_s1_UL_GTPtunnelEndpoint() {return s1_UL_GTPtunnelEndpoint;}
	s1_UL_GTPtunnelEndpoint_t const& ref_s1_UL_GTPtunnelEndpoint() const {return s1_UL_GTPtunnelEndpoint;}
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_ToBeAdded_Item_SCG_BearerExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_ToBeAdded_Item_SCG_BearerExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(e_RAB_ID);
		v(e_RAB_Level_QoS_Parameters);
		v(dL_Forwarding);
		v(s1_UL_GTPtunnelEndpoint);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(e_RAB_ID);
		v(e_RAB_Level_QoS_Parameters);
		v(dL_Forwarding);
		v(s1_UL_GTPtunnelEndpoint);
		v(iE_Extensions);

	};
	void clear()
	{
		e_RAB_ID.clear();
		e_RAB_Level_QoS_Parameters.clear();
		dL_Forwarding.clear();
		s1_UL_GTPtunnelEndpoint.clear();
		iE_Extensions.clear();

	};
	private:
	e_RAB_ID_t	e_RAB_ID;
	e_RAB_Level_QoS_Parameters_t	e_RAB_Level_QoS_Parameters;
	dL_Forwarding_t	dL_Forwarding;
	s1_UL_GTPtunnelEndpoint_t	s1_UL_GTPtunnelEndpoint;
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-ToBeAdded-Item-Split-BearerExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct E_RABs_ToBeAdded_Item_Split_BearerExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-ToBeAdded-Item-Split-Bearer ::= SEQUENCE {
	e-RAB-ID						E-RAB-ID,
	e-RAB-Level-QoS-Parameters		E-RAB-Level-QoS-Parameters,
	meNB-GTPtunnelEndpoint			GTPtunnelEndpoint,
	iE-Extensions					ProtocolExtensionContainer { {E-RABs-ToBeAdded-Item-Split-BearerExtIEs} } OPTIONAL,
	...
}
*/

struct E_RABs_ToBeAdded_Item_Split_Bearer : asn::sequence<4, 0, true, 1>
{
	static constexpr const char* name() {return "E-RABs-ToBeAdded-Item-Split-Bearer";}
	using parent_t = asn::sequence<4, 0, true, 1>;
	struct e_RAB_ID_t : E_RAB_ID
	{
		static constexpr const char* name() {return "e_RAB_ID_t";}
		using parent_t = E_RAB_ID;

	};
	e_RAB_ID_t& ref_e_RAB_ID() {return e_RAB_ID;}
	e_RAB_ID_t const& ref_e_RAB_ID() const {return e_RAB_ID;}
	struct e_RAB_Level_QoS_Parameters_t : E_RAB_Level_QoS_Parameters
	{
		static constexpr const char* name() {return "e_RAB_Level_QoS_Parameters_t";}
		using parent_t = E_RAB_Level_QoS_Parameters;

	};
	e_RAB_Level_QoS_Parameters_t& ref_e_RAB_Level_QoS_Parameters() {return e_RAB_Level_QoS_Parameters;}
	e_RAB_Level_QoS_Parameters_t const& ref_e_RAB_Level_QoS_Parameters() const {return e_RAB_Level_QoS_Parameters;}
	struct meNB_GTPtunnelEndpoint_t : GTPtunnelEndpoint
	{
		static constexpr const char* name() {return "meNB_GTPtunnelEndpoint_t";}
		using parent_t = GTPtunnelEndpoint;

	};
	meNB_GTPtunnelEndpoint_t& ref_meNB_GTPtunnelEndpoint() {return meNB_GTPtunnelEndpoint;}
	meNB_GTPtunnelEndpoint_t const& ref_meNB_GTPtunnelEndpoint() const {return meNB_GTPtunnelEndpoint;}
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_ToBeAdded_Item_Split_BearerExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_ToBeAdded_Item_Split_BearerExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(e_RAB_ID);
		v(e_RAB_Level_QoS_Parameters);
		v(meNB_GTPtunnelEndpoint);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(e_RAB_ID);
		v(e_RAB_Level_QoS_Parameters);
		v(meNB_GTPtunnelEndpoint);
		v(iE_Extensions);

	};
	void clear()
	{
		e_RAB_ID.clear();
		e_RAB_Level_QoS_Parameters.clear();
		meNB_GTPtunnelEndpoint.clear();
		iE_Extensions.clear();

	};
	private:
	e_RAB_ID_t	e_RAB_ID;
	e_RAB_Level_QoS_Parameters_t	e_RAB_Level_QoS_Parameters;
	meNB_GTPtunnelEndpoint_t	meNB_GTPtunnelEndpoint;
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-ToBeAdded-Item ::= CHOICE {
	sCG-Bearer		E-RABs-ToBeAdded-Item-SCG-Bearer,
	split-Bearer	E-RABs-ToBeAdded-Item-Split-Bearer,
	...
}
*/

struct E_RABs_ToBeAdded_Item : asn::choice<2, 0, true>
{
	static constexpr const char* name() {return "E-RABs-ToBeAdded-Item";}
	using parent_t = asn::choice<2, 0, true>;
	index_type get_index() const {return index;}
	bool is_unknown() const {return index == 3;}
	void set_unknown() { set_index(3);  }
	~E_RABs_ToBeAdded_Item() {clear();}
	struct sCG_Bearer_t : E_RABs_ToBeAdded_Item_SCG_Bearer
	{
		static constexpr const char* name() {return "sCG_Bearer_t";}
		using parent_t = E_RABs_ToBeAdded_Item_SCG_Bearer;

	};
	struct split_Bearer_t : E_RABs_ToBeAdded_Item_Split_Bearer
	{
		static constexpr const char* name() {return "split_Bearer_t";}
		using parent_t = E_RABs_ToBeAdded_Item_Split_Bearer;

	};
	void clear()
	{
		switch(get_index())
		{
		case 1: var.destroy<sCG_Bearer_t>(); break;
		case 2: var.destroy<split_Bearer_t>(); break;
		}
		index = 0;
		base::clear();
	}
	template<typename V> bool decode(size_t idx, V& v)
	{
		clear();
		switch(idx)
		{
		case 1: set_index(1); return v(var.build<sCG_Bearer_t>());
		case 2: set_index(2); return v(var.build<split_Bearer_t>());
		}
		return false;

	}
	template<typename V> bool encode(V& v) const
	{
		switch(get_index())
		{
		case 1: return v(var.as<sCG_Bearer_t>());
		case 2: return v(var.as<split_Bearer_t>());
		}
		return false;
	}
	template<typename V> static inline void enumerate(V& v)
	{
		v.template operator()<sCG_Bearer_t>(1);
		v.template operator()<split_Bearer_t>(2);

	}
	sCG_Bearer_t& select_sCG_Bearer() { if(get_index() != 1) { clear(); set_index(1); return var.build<sCG_Bearer_t>();} return var.as<sCG_Bearer_t>();}
	sCG_Bearer_t const* get_sCG_Bearer() const { if(get_index() == 1) { return &var.as<sCG_Bearer_t>();} return nullptr; }
	split_Bearer_t& select_split_Bearer() { if(get_index() != 2) { clear(); set_index(2); return var.build<split_Bearer_t>();} return var.as<split_Bearer_t>();}
	split_Bearer_t const* get_split_Bearer() const { if(get_index() == 2) { return &var.as<split_Bearer_t>();} return nullptr; }
	private:
	void set_index(index_type i) {index = i; base::set();}
	union union_type
	{
		char dummy1[sizeof(sCG_Bearer_t)];
		char dummy2[sizeof(split_Bearer_t)];

	};
	asn::variant<sizeof(union_type)>	var;
	index_type	index {0};
};
/*
E-RABs-ToBeAdded-ItemIEs X2AP-PROTOCOL-IES ::= {
	{ ID id-E-RABs-ToBeAdded-Item	CRITICALITY reject	TYPE E-RABs-ToBeAdded-Item		PRESENCE mandatory},
	...
}
*/

struct E_RABs_ToBeAdded_ItemIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_ToBeAdded_Item() { set(id_E_RABs_ToBeAdded_Item); type=1;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_E_RABs_ToBeAdded_Item)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_E_RABs_ToBeAdded_Item);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_ToBeAdded_Item() { set(reject); type=1;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		E_RABs_ToBeAdded_Item& select_id_E_RABs_ToBeAdded_Item() { return set<E_RABs_ToBeAdded_Item>(1); }
		E_RABs_ToBeAdded_Item const* get_id_E_RABs_ToBeAdded_Item() const { return get<E_RABs_ToBeAdded_Item>(1); }
		bool is_unknown() const { return type == 2; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<E_RABs_ToBeAdded_Item>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<E_RABs_ToBeAdded_Item>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_E_RABs_ToBeAdded_Item()); return true;
			case 2: if(type != 2) {clear(); asn::base::set();} type = 2; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<E_RABs_ToBeAdded_Item>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(E_RABs_ToBeAdded_Item)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_ToBeAdded_Item() { set(mandatory); type=1;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-ToBeAdded-List ::= SEQUENCE (SIZE(1..maxnoofBearers)) OF ProtocolIE-Single-Container { {E-RABs-ToBeAdded-ItemIEs} }
*/

struct E_RABs_ToBeAdded_List_elm : ProtocolIE_Single_Container<E_RABs_ToBeAdded_ItemIEs>
{
	static constexpr const char* name() {return "E_RABs_ToBeAdded_List_elm";}
	using parent_t = ProtocolIE_Single_Container<E_RABs_ToBeAdded_ItemIEs>;

};
struct E_RABs_ToBeAdded_List : asn::sequenceof<E_RABs_ToBeAdded_List_elm>
{
	static constexpr const char* name() {return "E-RABs-ToBeAdded-List";}
	using parent_t = asn::sequenceof<E_RABs_ToBeAdded_List_elm>;
	using constraint_t = asn::constraints<false,asn::span<1,  maxnoofBearers >>;

};
/*
E-RABs-ToBeAdded-ModReqItem-SCG-BearerExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	{ ID id-Correlation-ID				CRITICALITY ignore	EXTENSION Correlation-ID		PRESENCE optional}|
	{ ID id-SIPTO-Correlation-ID		CRITICALITY ignore	EXTENSION Correlation-ID		PRESENCE optional},
	...
}
*/

struct E_RABs_ToBeAdded_ModReqItem_SCG_BearerExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 3; }
		void clear() {type = 0;}
		void select_id_Correlation_ID() { set(id_Correlation_ID); type=1;}
		void select_id_SIPTO_Correlation_ID() { set(id_SIPTO_Correlation_ID); type=2;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_Correlation_ID)) { type = 1; return true; }
			else if(equal(id_SIPTO_Correlation_ID)) { type = 2; return true; }
			else { type = 3; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_Correlation_ID);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_SIPTO_Correlation_ID);} return false;
			case 3: type = 3; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 3; }
		void clear() {type = 0;}
		void select_id_Correlation_ID() { set(ignore); type=1;}
		void select_id_SIPTO_Correlation_ID() { set(ignore); type=2;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else if(equal(ignore)) { type = 2; return true; }
			else { type = 3; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(ignore);} return false;
			case 3: type = 3; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		Correlation_ID& select_id_Correlation_ID() { return set<Correlation_ID>(1); }
		Correlation_ID const* get_id_Correlation_ID() const { return get<Correlation_ID>(1); }
		Correlation_ID& select_id_SIPTO_Correlation_ID() { return set<Correlation_ID>(2); }
		Correlation_ID const* get_id_SIPTO_Correlation_ID() const { return get<Correlation_ID>(2); }
		bool is_unknown() const { return type == 3; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<Correlation_ID>(); break;
			case 2: var.destroy<Correlation_ID>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<Correlation_ID>(1);
			v.template operator()<Correlation_ID>(2);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_Correlation_ID()); return true;
			case 2: v(select_id_SIPTO_Correlation_ID()); return true;
			case 3: if(type != 3) {clear(); asn::base::set();} type = 3; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<Correlation_ID>()); return true;
			case 2: v(var.as<Correlation_ID>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(Correlation_ID)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 3; }
		void clear() {type = 0;}
		void select_id_Correlation_ID() { set(optional); type=1;}
		void select_id_SIPTO_Correlation_ID() { set(optional); type=2;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(optional)) { type = 1; return true; }
			else if(equal(optional)) { type = 2; return true; }
			else { type = 3; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(optional);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(optional);} return false;
			case 3: type = 3; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-ToBeAdded-ModReqItem-SCG-Bearer ::= SEQUENCE {
	e-RAB-ID						E-RAB-ID,
	e-RAB-Level-QoS-Parameters		E-RAB-Level-QoS-Parameters,
	dL-Forwarding					DL-Forwarding																	OPTIONAL,
	s1-UL-GTPtunnelEndpoint			GTPtunnelEndpoint,
	iE-Extensions					ProtocolExtensionContainer { {E-RABs-ToBeAdded-ModReqItem-SCG-BearerExtIEs} } OPTIONAL,
	...
}
*/

struct E_RABs_ToBeAdded_ModReqItem_SCG_Bearer : asn::sequence<5, 0, true, 2>
{
	static constexpr const char* name() {return "E-RABs-ToBeAdded-ModReqItem-SCG-Bearer";}
	using parent_t = asn::sequence<5, 0, true, 2>;
	struct e_RAB_ID_t : E_RAB_ID
	{
		static constexpr const char* name() {return "e_RAB_ID_t";}
		using parent_t = E_RAB_ID;

	};
	e_RAB_ID_t& ref_e_RAB_ID() {return e_RAB_ID;}
	e_RAB_ID_t const& ref_e_RAB_ID() const {return e_RAB_ID;}
	struct e_RAB_Level_QoS_Parameters_t : E_RAB_Level_QoS_Parameters
	{
		static constexpr const char* name() {return "e_RAB_Level_QoS_Parameters_t";}
		using parent_t = E_RAB_Level_QoS_Parameters;

	};
	e_RAB_Level_QoS_Parameters_t& ref_e_RAB_Level_QoS_Parameters() {return e_RAB_Level_QoS_Parameters;}
	e_RAB_Level_QoS_Parameters_t const& ref_e_RAB_Level_QoS_Parameters() const {return e_RAB_Level_QoS_Parameters;}
	struct dL_Forwarding_t : DL_Forwarding
	{
		static constexpr const char* name() {return "dL_Forwarding_t";}
		using parent_t = DL_Forwarding;
		static constexpr bool optional = true;

	};
	dL_Forwarding_t& set_dL_Forwarding() { dL_Forwarding.setpresent(true); return dL_Forwarding;}
	dL_Forwarding_t const* get_dL_Forwarding() const {return dL_Forwarding.is_valid() ? &dL_Forwarding : nullptr;}
	struct s1_UL_GTPtunnelEndpoint_t : GTPtunnelEndpoint
	{
		static constexpr const char* name() {return "s1_UL_GTPtunnelEndpoint_t";}
		using parent_t = GTPtunnelEndpoint;

	};
	s1_UL_GTPtunnelEndpoint_t& ref_s1_UL_GTPtunnelEndpoint() {return s1_UL_GTPtunnelEndpoint;}
	s1_UL_GTPtunnelEndpoint_t const& ref_s1_UL_GTPtunnelEndpoint() const {return s1_UL_GTPtunnelEndpoint;}
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_ToBeAdded_ModReqItem_SCG_BearerExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_ToBeAdded_ModReqItem_SCG_BearerExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(e_RAB_ID);
		v(e_RAB_Level_QoS_Parameters);
		v(dL_Forwarding);
		v(s1_UL_GTPtunnelEndpoint);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(e_RAB_ID);
		v(e_RAB_Level_QoS_Parameters);
		v(dL_Forwarding);
		v(s1_UL_GTPtunnelEndpoint);
		v(iE_Extensions);

	};
	void clear()
	{
		e_RAB_ID.clear();
		e_RAB_Level_QoS_Parameters.clear();
		dL_Forwarding.clear();
		s1_UL_GTPtunnelEndpoint.clear();
		iE_Extensions.clear();

	};
	private:
	e_RAB_ID_t	e_RAB_ID;
	e_RAB_Level_QoS_Parameters_t	e_RAB_Level_QoS_Parameters;
	dL_Forwarding_t	dL_Forwarding;
	s1_UL_GTPtunnelEndpoint_t	s1_UL_GTPtunnelEndpoint;
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-ToBeAdded-ModReqItem-Split-BearerExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct E_RABs_ToBeAdded_ModReqItem_Split_BearerExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-ToBeAdded-ModReqItem-Split-Bearer ::= SEQUENCE {
	e-RAB-ID						E-RAB-ID,
	e-RAB-Level-QoS-Parameters		E-RAB-Level-QoS-Parameters,
	meNB-GTPtunnelEndpoint			GTPtunnelEndpoint,
	iE-Extensions			ProtocolExtensionContainer { {E-RABs-ToBeAdded-ModReqItem-Split-BearerExtIEs} } OPTIONAL,
	...
}
*/

struct E_RABs_ToBeAdded_ModReqItem_Split_Bearer : asn::sequence<4, 0, true, 1>
{
	static constexpr const char* name() {return "E-RABs-ToBeAdded-ModReqItem-Split-Bearer";}
	using parent_t = asn::sequence<4, 0, true, 1>;
	struct e_RAB_ID_t : E_RAB_ID
	{
		static constexpr const char* name() {return "e_RAB_ID_t";}
		using parent_t = E_RAB_ID;

	};
	e_RAB_ID_t& ref_e_RAB_ID() {return e_RAB_ID;}
	e_RAB_ID_t const& ref_e_RAB_ID() const {return e_RAB_ID;}
	struct e_RAB_Level_QoS_Parameters_t : E_RAB_Level_QoS_Parameters
	{
		static constexpr const char* name() {return "e_RAB_Level_QoS_Parameters_t";}
		using parent_t = E_RAB_Level_QoS_Parameters;

	};
	e_RAB_Level_QoS_Parameters_t& ref_e_RAB_Level_QoS_Parameters() {return e_RAB_Level_QoS_Parameters;}
	e_RAB_Level_QoS_Parameters_t const& ref_e_RAB_Level_QoS_Parameters() const {return e_RAB_Level_QoS_Parameters;}
	struct meNB_GTPtunnelEndpoint_t : GTPtunnelEndpoint
	{
		static constexpr const char* name() {return "meNB_GTPtunnelEndpoint_t";}
		using parent_t = GTPtunnelEndpoint;

	};
	meNB_GTPtunnelEndpoint_t& ref_meNB_GTPtunnelEndpoint() {return meNB_GTPtunnelEndpoint;}
	meNB_GTPtunnelEndpoint_t const& ref_meNB_GTPtunnelEndpoint() const {return meNB_GTPtunnelEndpoint;}
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_ToBeAdded_ModReqItem_Split_BearerExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_ToBeAdded_ModReqItem_Split_BearerExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(e_RAB_ID);
		v(e_RAB_Level_QoS_Parameters);
		v(meNB_GTPtunnelEndpoint);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(e_RAB_ID);
		v(e_RAB_Level_QoS_Parameters);
		v(meNB_GTPtunnelEndpoint);
		v(iE_Extensions);

	};
	void clear()
	{
		e_RAB_ID.clear();
		e_RAB_Level_QoS_Parameters.clear();
		meNB_GTPtunnelEndpoint.clear();
		iE_Extensions.clear();

	};
	private:
	e_RAB_ID_t	e_RAB_ID;
	e_RAB_Level_QoS_Parameters_t	e_RAB_Level_QoS_Parameters;
	meNB_GTPtunnelEndpoint_t	meNB_GTPtunnelEndpoint;
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-ToBeAdded-ModReqItem ::= CHOICE {
	sCG-Bearer		E-RABs-ToBeAdded-ModReqItem-SCG-Bearer,
	split-Bearer	E-RABs-ToBeAdded-ModReqItem-Split-Bearer,
	...
}
*/

struct E_RABs_ToBeAdded_ModReqItem : asn::choice<2, 0, true>
{
	static constexpr const char* name() {return "E-RABs-ToBeAdded-ModReqItem";}
	using parent_t = asn::choice<2, 0, true>;
	index_type get_index() const {return index;}
	bool is_unknown() const {return index == 3;}
	void set_unknown() { set_index(3);  }
	~E_RABs_ToBeAdded_ModReqItem() {clear();}
	struct sCG_Bearer_t : E_RABs_ToBeAdded_ModReqItem_SCG_Bearer
	{
		static constexpr const char* name() {return "sCG_Bearer_t";}
		using parent_t = E_RABs_ToBeAdded_ModReqItem_SCG_Bearer;

	};
	struct split_Bearer_t : E_RABs_ToBeAdded_ModReqItem_Split_Bearer
	{
		static constexpr const char* name() {return "split_Bearer_t";}
		using parent_t = E_RABs_ToBeAdded_ModReqItem_Split_Bearer;

	};
	void clear()
	{
		switch(get_index())
		{
		case 1: var.destroy<sCG_Bearer_t>(); break;
		case 2: var.destroy<split_Bearer_t>(); break;
		}
		index = 0;
		base::clear();
	}
	template<typename V> bool decode(size_t idx, V& v)
	{
		clear();
		switch(idx)
		{
		case 1: set_index(1); return v(var.build<sCG_Bearer_t>());
		case 2: set_index(2); return v(var.build<split_Bearer_t>());
		}
		return false;

	}
	template<typename V> bool encode(V& v) const
	{
		switch(get_index())
		{
		case 1: return v(var.as<sCG_Bearer_t>());
		case 2: return v(var.as<split_Bearer_t>());
		}
		return false;
	}
	template<typename V> static inline void enumerate(V& v)
	{
		v.template operator()<sCG_Bearer_t>(1);
		v.template operator()<split_Bearer_t>(2);

	}
	sCG_Bearer_t& select_sCG_Bearer() { if(get_index() != 1) { clear(); set_index(1); return var.build<sCG_Bearer_t>();} return var.as<sCG_Bearer_t>();}
	sCG_Bearer_t const* get_sCG_Bearer() const { if(get_index() == 1) { return &var.as<sCG_Bearer_t>();} return nullptr; }
	split_Bearer_t& select_split_Bearer() { if(get_index() != 2) { clear(); set_index(2); return var.build<split_Bearer_t>();} return var.as<split_Bearer_t>();}
	split_Bearer_t const* get_split_Bearer() const { if(get_index() == 2) { return &var.as<split_Bearer_t>();} return nullptr; }
	private:
	void set_index(index_type i) {index = i; base::set();}
	union union_type
	{
		char dummy1[sizeof(sCG_Bearer_t)];
		char dummy2[sizeof(split_Bearer_t)];

	};
	asn::variant<sizeof(union_type)>	var;
	index_type	index {0};
};
/*
E-RABs-ToBeAdded-ModReqItemIEs X2AP-PROTOCOL-IES ::= {
	{ ID id-E-RABs-ToBeAdded-ModReqItem	CRITICALITY ignore	TYPE E-RABs-ToBeAdded-ModReqItem	PRESENCE mandatory},
	...
}
*/

struct E_RABs_ToBeAdded_ModReqItemIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_ToBeAdded_ModReqItem() { set(id_E_RABs_ToBeAdded_ModReqItem); type=1;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_E_RABs_ToBeAdded_ModReqItem)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_E_RABs_ToBeAdded_ModReqItem);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_ToBeAdded_ModReqItem() { set(ignore); type=1;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		E_RABs_ToBeAdded_ModReqItem& select_id_E_RABs_ToBeAdded_ModReqItem() { return set<E_RABs_ToBeAdded_ModReqItem>(1); }
		E_RABs_ToBeAdded_ModReqItem const* get_id_E_RABs_ToBeAdded_ModReqItem() const { return get<E_RABs_ToBeAdded_ModReqItem>(1); }
		bool is_unknown() const { return type == 2; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<E_RABs_ToBeAdded_ModReqItem>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<E_RABs_ToBeAdded_ModReqItem>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_E_RABs_ToBeAdded_ModReqItem()); return true;
			case 2: if(type != 2) {clear(); asn::base::set();} type = 2; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<E_RABs_ToBeAdded_ModReqItem>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(E_RABs_ToBeAdded_ModReqItem)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_ToBeAdded_ModReqItem() { set(mandatory); type=1;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-ToBeAdded-List-ModReq ::= SEQUENCE (SIZE(1..maxnoofBearers)) OF ProtocolIE-Single-Container { {E-RABs-ToBeAdded-ModReqItemIEs} }
*/

struct E_RABs_ToBeAdded_List_ModReq_elm : ProtocolIE_Single_Container<E_RABs_ToBeAdded_ModReqItemIEs>
{
	static constexpr const char* name() {return "E_RABs_ToBeAdded_List_ModReq_elm";}
	using parent_t = ProtocolIE_Single_Container<E_RABs_ToBeAdded_ModReqItemIEs>;

};
struct E_RABs_ToBeAdded_List_ModReq : asn::sequenceof<E_RABs_ToBeAdded_List_ModReq_elm>
{
	static constexpr const char* name() {return "E-RABs-ToBeAdded-List-ModReq";}
	using parent_t = asn::sequenceof<E_RABs_ToBeAdded_List_ModReq_elm>;
	using constraint_t = asn::constraints<false,asn::span<1,  maxnoofBearers >>;

};
/*
E-RABs-ToBeAdded-SgNBAddReq-Item-SgNBPDCPpresentExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	{ ID id-RLCMode-transferred					CRITICALITY ignore	EXTENSION RLCMode					PRESENCE optional},
	...
}
*/

struct E_RABs_ToBeAdded_SgNBAddReq_Item_SgNBPDCPpresentExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_RLCMode_transferred() { set(id_RLCMode_transferred); type=1;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_RLCMode_transferred)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_RLCMode_transferred);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_RLCMode_transferred() { set(ignore); type=1;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		RLCMode& select_id_RLCMode_transferred() { return set<RLCMode>(1); }
		RLCMode const* get_id_RLCMode_transferred() const { return get<RLCMode>(1); }
		bool is_unknown() const { return type == 2; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<RLCMode>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<RLCMode>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_RLCMode_transferred()); return true;
			case 2: if(type != 2) {clear(); asn::base::set();} type = 2; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<RLCMode>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(RLCMode)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_RLCMode_transferred() { set(optional); type=1;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(optional)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(optional);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-ToBeAdded-SgNBAddReq-Item-SgNBPDCPpresent ::= SEQUENCE {
	full-E-RAB-Level-QoS-Parameters				E-RAB-Level-QoS-Parameters,
	max-MCG-admit-E-RAB-Level-QoS-Parameters	GBR-QosInformation															OPTIONAL,
-- This IE shall be present if MCG resource and SCG resources IEs in the the EN-DC Resource Configuration IE are set to present and GBR QoS Information IE is present in Full E-RAB Level QoS Parameters IE --
	dL-Forwarding								DL-Forwarding																		OPTIONAL,
	meNB-DL-GTP-TEIDatMCG						GTPtunnelEndpoint																	OPTIONAL,
-- This IE shall be present if MCG resource IE in the the EN-DC Resource Configuration IE is set to present --
	s1-UL-GTPtunnelEndpoint						GTPtunnelEndpoint,
	iE-Extensions					ProtocolExtensionContainer { {E-RABs-ToBeAdded-SgNBAddReq-Item-SgNBPDCPpresentExtIEs} }	OPTIONAL,
	...
}
*/

struct E_RABs_ToBeAdded_SgNBAddReq_Item_SgNBPDCPpresent : asn::sequence<6, 0, true, 4>
{
	static constexpr const char* name() {return "E-RABs-ToBeAdded-SgNBAddReq-Item-SgNBPDCPpresent";}
	using parent_t = asn::sequence<6, 0, true, 4>;
	struct full_E_RAB_Level_QoS_Parameters_t : E_RAB_Level_QoS_Parameters
	{
		static constexpr const char* name() {return "full_E_RAB_Level_QoS_Parameters_t";}
		using parent_t = E_RAB_Level_QoS_Parameters;

	};
	full_E_RAB_Level_QoS_Parameters_t& ref_full_E_RAB_Level_QoS_Parameters() {return full_E_RAB_Level_QoS_Parameters;}
	full_E_RAB_Level_QoS_Parameters_t const& ref_full_E_RAB_Level_QoS_Parameters() const {return full_E_RAB_Level_QoS_Parameters;}
	struct max_MCG_admit_E_RAB_Level_QoS_Parameters_t : GBR_QosInformation
	{
		static constexpr const char* name() {return "max_MCG_admit_E_RAB_Level_QoS_Parameters_t";}
		using parent_t = GBR_QosInformation;
		static constexpr bool optional = true;

	};
	max_MCG_admit_E_RAB_Level_QoS_Parameters_t& set_max_MCG_admit_E_RAB_Level_QoS_Parameters() { max_MCG_admit_E_RAB_Level_QoS_Parameters.setpresent(true); return max_MCG_admit_E_RAB_Level_QoS_Parameters;}
	max_MCG_admit_E_RAB_Level_QoS_Parameters_t const* get_max_MCG_admit_E_RAB_Level_QoS_Parameters() const {return max_MCG_admit_E_RAB_Level_QoS_Parameters.is_valid() ? &max_MCG_admit_E_RAB_Level_QoS_Parameters : nullptr;}
	struct dL_Forwarding_t : DL_Forwarding
	{
		static constexpr const char* name() {return "dL_Forwarding_t";}
		using parent_t = DL_Forwarding;
		static constexpr bool optional = true;

	};
	dL_Forwarding_t& set_dL_Forwarding() { dL_Forwarding.setpresent(true); return dL_Forwarding;}
	dL_Forwarding_t const* get_dL_Forwarding() const {return dL_Forwarding.is_valid() ? &dL_Forwarding : nullptr;}
	struct meNB_DL_GTP_TEIDatMCG_t : GTPtunnelEndpoint
	{
		static constexpr const char* name() {return "meNB_DL_GTP_TEIDatMCG_t";}
		using parent_t = GTPtunnelEndpoint;
		static constexpr bool optional = true;

	};
	meNB_DL_GTP_TEIDatMCG_t& set_meNB_DL_GTP_TEIDatMCG() { meNB_DL_GTP_TEIDatMCG.setpresent(true); return meNB_DL_GTP_TEIDatMCG;}
	meNB_DL_GTP_TEIDatMCG_t const* get_meNB_DL_GTP_TEIDatMCG() const {return meNB_DL_GTP_TEIDatMCG.is_valid() ? &meNB_DL_GTP_TEIDatMCG : nullptr;}
	struct s1_UL_GTPtunnelEndpoint_t : GTPtunnelEndpoint
	{
		static constexpr const char* name() {return "s1_UL_GTPtunnelEndpoint_t";}
		using parent_t = GTPtunnelEndpoint;

	};
	s1_UL_GTPtunnelEndpoint_t& ref_s1_UL_GTPtunnelEndpoint() {return s1_UL_GTPtunnelEndpoint;}
	s1_UL_GTPtunnelEndpoint_t const& ref_s1_UL_GTPtunnelEndpoint() const {return s1_UL_GTPtunnelEndpoint;}
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_ToBeAdded_SgNBAddReq_Item_SgNBPDCPpresentExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_ToBeAdded_SgNBAddReq_Item_SgNBPDCPpresentExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(full_E_RAB_Level_QoS_Parameters);
		v(max_MCG_admit_E_RAB_Level_QoS_Parameters);
		v(dL_Forwarding);
		v(meNB_DL_GTP_TEIDatMCG);
		v(s1_UL_GTPtunnelEndpoint);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(full_E_RAB_Level_QoS_Parameters);
		v(max_MCG_admit_E_RAB_Level_QoS_Parameters);
		v(dL_Forwarding);
		v(meNB_DL_GTP_TEIDatMCG);
		v(s1_UL_GTPtunnelEndpoint);
		v(iE_Extensions);

	};
	void clear()
	{
		full_E_RAB_Level_QoS_Parameters.clear();
		max_MCG_admit_E_RAB_Level_QoS_Parameters.clear();
		dL_Forwarding.clear();
		meNB_DL_GTP_TEIDatMCG.clear();
		s1_UL_GTPtunnelEndpoint.clear();
		iE_Extensions.clear();

	};
	private:
	full_E_RAB_Level_QoS_Parameters_t	full_E_RAB_Level_QoS_Parameters;
	max_MCG_admit_E_RAB_Level_QoS_Parameters_t	max_MCG_admit_E_RAB_Level_QoS_Parameters;
	dL_Forwarding_t	dL_Forwarding;
	meNB_DL_GTP_TEIDatMCG_t	meNB_DL_GTP_TEIDatMCG;
	s1_UL_GTPtunnelEndpoint_t	s1_UL_GTPtunnelEndpoint;
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-ToBeAdded-SgNBAddReq-Item-SgNBPDCPnotpresentExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	{ ID id-uLpDCPSnLength							CRITICALITY ignore	EXTENSION PDCPSnLength					PRESENCE optional}|
	{ ID id-dLPDCPSnLength							CRITICALITY ignore	EXTENSION PDCPSnLength					PRESENCE optional}|
	{ ID id-duplicationActivation					CRITICALITY ignore	EXTENSION DuplicationActivation	PRESENCE optional},
	...
}
*/

struct E_RABs_ToBeAdded_SgNBAddReq_Item_SgNBPDCPnotpresentExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 4; }
		void clear() {type = 0;}
		void select_id_uLpDCPSnLength() { set(id_uLpDCPSnLength); type=1;}
		void select_id_dLPDCPSnLength() { set(id_dLPDCPSnLength); type=2;}
		void select_id_duplicationActivation() { set(id_duplicationActivation); type=3;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_uLpDCPSnLength)) { type = 1; return true; }
			else if(equal(id_dLPDCPSnLength)) { type = 2; return true; }
			else if(equal(id_duplicationActivation)) { type = 3; return true; }
			else { type = 4; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_uLpDCPSnLength);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_dLPDCPSnLength);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_duplicationActivation);} return false;
			case 4: type = 4; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 4; }
		void clear() {type = 0;}
		void select_id_uLpDCPSnLength() { set(ignore); type=1;}
		void select_id_dLPDCPSnLength() { set(ignore); type=2;}
		void select_id_duplicationActivation() { set(ignore); type=3;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else if(equal(ignore)) { type = 2; return true; }
			else if(equal(ignore)) { type = 3; return true; }
			else { type = 4; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(ignore);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(ignore);} return false;
			case 4: type = 4; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		PDCPSnLength& select_id_uLpDCPSnLength() { return set<PDCPSnLength>(1); }
		PDCPSnLength const* get_id_uLpDCPSnLength() const { return get<PDCPSnLength>(1); }
		PDCPSnLength& select_id_dLPDCPSnLength() { return set<PDCPSnLength>(2); }
		PDCPSnLength const* get_id_dLPDCPSnLength() const { return get<PDCPSnLength>(2); }
		DuplicationActivation& select_id_duplicationActivation() { return set<DuplicationActivation>(3); }
		DuplicationActivation const* get_id_duplicationActivation() const { return get<DuplicationActivation>(3); }
		bool is_unknown() const { return type == 4; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<PDCPSnLength>(); break;
			case 2: var.destroy<PDCPSnLength>(); break;
			case 3: var.destroy<DuplicationActivation>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<PDCPSnLength>(1);
			v.template operator()<PDCPSnLength>(2);
			v.template operator()<DuplicationActivation>(3);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_uLpDCPSnLength()); return true;
			case 2: v(select_id_dLPDCPSnLength()); return true;
			case 3: v(select_id_duplicationActivation()); return true;
			case 4: if(type != 4) {clear(); asn::base::set();} type = 4; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<PDCPSnLength>()); return true;
			case 2: v(var.as<PDCPSnLength>()); return true;
			case 3: v(var.as<DuplicationActivation>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(DuplicationActivation)];
			char dummy2[sizeof(PDCPSnLength)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 4; }
		void clear() {type = 0;}
		void select_id_uLpDCPSnLength() { set(optional); type=1;}
		void select_id_dLPDCPSnLength() { set(optional); type=2;}
		void select_id_duplicationActivation() { set(optional); type=3;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(optional)) { type = 1; return true; }
			else if(equal(optional)) { type = 2; return true; }
			else if(equal(optional)) { type = 3; return true; }
			else { type = 4; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(optional);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(optional);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(optional);} return false;
			case 4: type = 4; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-ToBeAdded-SgNBAddReq-Item-SgNBPDCPnotpresent ::= SEQUENCE {
	requested-SCG-E-RAB-Level-QoS-Parameters		E-RAB-Level-QoS-Parameters,
	meNB-UL-GTP-TEIDatPDCP							GTPtunnelEndpoint,
	secondary-meNB-UL-GTP-TEIDatPDCP				GTPtunnelEndpoint	OPTIONAL,
	rlc-Mode										RLCMode,
	uL-Configuration								ULConfiguration	OPTIONAL,
-- This IE shall be present if MCG resource and SCG resources IEs in the the EN-DC Resource Configuration IE are set to present --
	iE-Extensions					ProtocolExtensionContainer { {E-RABs-ToBeAdded-SgNBAddReq-Item-SgNBPDCPnotpresentExtIEs} }		 OPTIONAL,
	...
}
*/

struct E_RABs_ToBeAdded_SgNBAddReq_Item_SgNBPDCPnotpresent : asn::sequence<6, 0, true, 3>
{
	static constexpr const char* name() {return "E-RABs-ToBeAdded-SgNBAddReq-Item-SgNBPDCPnotpresent";}
	using parent_t = asn::sequence<6, 0, true, 3>;
	struct requested_SCG_E_RAB_Level_QoS_Parameters_t : E_RAB_Level_QoS_Parameters
	{
		static constexpr const char* name() {return "requested_SCG_E_RAB_Level_QoS_Parameters_t";}
		using parent_t = E_RAB_Level_QoS_Parameters;

	};
	requested_SCG_E_RAB_Level_QoS_Parameters_t& ref_requested_SCG_E_RAB_Level_QoS_Parameters() {return requested_SCG_E_RAB_Level_QoS_Parameters;}
	requested_SCG_E_RAB_Level_QoS_Parameters_t const& ref_requested_SCG_E_RAB_Level_QoS_Parameters() const {return requested_SCG_E_RAB_Level_QoS_Parameters;}
	struct meNB_UL_GTP_TEIDatPDCP_t : GTPtunnelEndpoint
	{
		static constexpr const char* name() {return "meNB_UL_GTP_TEIDatPDCP_t";}
		using parent_t = GTPtunnelEndpoint;

	};
	meNB_UL_GTP_TEIDatPDCP_t& ref_meNB_UL_GTP_TEIDatPDCP() {return meNB_UL_GTP_TEIDatPDCP;}
	meNB_UL_GTP_TEIDatPDCP_t const& ref_meNB_UL_GTP_TEIDatPDCP() const {return meNB_UL_GTP_TEIDatPDCP;}
	struct secondary_meNB_UL_GTP_TEIDatPDCP_t : GTPtunnelEndpoint
	{
		static constexpr const char* name() {return "secondary_meNB_UL_GTP_TEIDatPDCP_t";}
		using parent_t = GTPtunnelEndpoint;
		static constexpr bool optional = true;

	};
	secondary_meNB_UL_GTP_TEIDatPDCP_t& set_secondary_meNB_UL_GTP_TEIDatPDCP() { secondary_meNB_UL_GTP_TEIDatPDCP.setpresent(true); return secondary_meNB_UL_GTP_TEIDatPDCP;}
	secondary_meNB_UL_GTP_TEIDatPDCP_t const* get_secondary_meNB_UL_GTP_TEIDatPDCP() const {return secondary_meNB_UL_GTP_TEIDatPDCP.is_valid() ? &secondary_meNB_UL_GTP_TEIDatPDCP : nullptr;}
	struct rlc_Mode_t : RLCMode
	{
		static constexpr const char* name() {return "rlc_Mode_t";}
		using parent_t = RLCMode;

	};
	rlc_Mode_t& ref_rlc_Mode() {return rlc_Mode;}
	rlc_Mode_t const& ref_rlc_Mode() const {return rlc_Mode;}
	struct uL_Configuration_t : ULConfiguration
	{
		static constexpr const char* name() {return "uL_Configuration_t";}
		using parent_t = ULConfiguration;
		static constexpr bool optional = true;

	};
	uL_Configuration_t& set_uL_Configuration() { uL_Configuration.setpresent(true); return uL_Configuration;}
	uL_Configuration_t const* get_uL_Configuration() const {return uL_Configuration.is_valid() ? &uL_Configuration : nullptr;}
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_ToBeAdded_SgNBAddReq_Item_SgNBPDCPnotpresentExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_ToBeAdded_SgNBAddReq_Item_SgNBPDCPnotpresentExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(requested_SCG_E_RAB_Level_QoS_Parameters);
		v(meNB_UL_GTP_TEIDatPDCP);
		v(secondary_meNB_UL_GTP_TEIDatPDCP);
		v(rlc_Mode);
		v(uL_Configuration);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(requested_SCG_E_RAB_Level_QoS_Parameters);
		v(meNB_UL_GTP_TEIDatPDCP);
		v(secondary_meNB_UL_GTP_TEIDatPDCP);
		v(rlc_Mode);
		v(uL_Configuration);
		v(iE_Extensions);

	};
	void clear()
	{
		requested_SCG_E_RAB_Level_QoS_Parameters.clear();
		meNB_UL_GTP_TEIDatPDCP.clear();
		secondary_meNB_UL_GTP_TEIDatPDCP.clear();
		rlc_Mode.clear();
		uL_Configuration.clear();
		iE_Extensions.clear();

	};
	private:
	requested_SCG_E_RAB_Level_QoS_Parameters_t	requested_SCG_E_RAB_Level_QoS_Parameters;
	meNB_UL_GTP_TEIDatPDCP_t	meNB_UL_GTP_TEIDatPDCP;
	secondary_meNB_UL_GTP_TEIDatPDCP_t	secondary_meNB_UL_GTP_TEIDatPDCP;
	rlc_Mode_t	rlc_Mode;
	uL_Configuration_t	uL_Configuration;
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-ToBeAdded-SgNBAddReq-ItemExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct E_RABs_ToBeAdded_SgNBAddReq_ItemExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-ToBeAdded-SgNBAddReq-Item ::= SEQUENCE {
	e-RAB-ID								E-RAB-ID,
	drb-ID								DRB-ID,
	en-DC-ResourceConfiguration			EN-DC-ResourceConfiguration,
	resource-configuration				CHOICE {
		sgNBPDCPpresent						E-RABs-ToBeAdded-SgNBAddReq-Item-SgNBPDCPpresent,
		sgNBPDCPnotpresent					E-RABs-ToBeAdded-SgNBAddReq-Item-SgNBPDCPnotpresent,
		...
	},
	iE-Extensions					ProtocolExtensionContainer { {E-RABs-ToBeAdded-SgNBAddReq-ItemExtIEs} }	OPTIONAL,
	...
}
*/

struct E_RABs_ToBeAdded_SgNBAddReq_Item : asn::sequence<5, 0, true, 1>
{
	static constexpr const char* name() {return "E-RABs-ToBeAdded-SgNBAddReq-Item";}
	using parent_t = asn::sequence<5, 0, true, 1>;
	struct e_RAB_ID_t : E_RAB_ID
	{
		static constexpr const char* name() {return "e_RAB_ID_t";}
		using parent_t = E_RAB_ID;

	};
	e_RAB_ID_t& ref_e_RAB_ID() {return e_RAB_ID;}
	e_RAB_ID_t const& ref_e_RAB_ID() const {return e_RAB_ID;}
	struct drb_ID_t : DRB_ID
	{
		static constexpr const char* name() {return "drb_ID_t";}
		using parent_t = DRB_ID;

	};
	drb_ID_t& ref_drb_ID() {return drb_ID;}
	drb_ID_t const& ref_drb_ID() const {return drb_ID;}
	struct en_DC_ResourceConfiguration_t : EN_DC_ResourceConfiguration
	{
		static constexpr const char* name() {return "en_DC_ResourceConfiguration_t";}
		using parent_t = EN_DC_ResourceConfiguration;

	};
	en_DC_ResourceConfiguration_t& ref_en_DC_ResourceConfiguration() {return en_DC_ResourceConfiguration;}
	en_DC_ResourceConfiguration_t const& ref_en_DC_ResourceConfiguration() const {return en_DC_ResourceConfiguration;}
	struct resource_configuration_t : asn::choice<2, 0, true>
	{
		static constexpr const char* name() {return "resource_configuration_t";}
		using parent_t = asn::choice<2, 0, true>;
		index_type get_index() const {return index;}
		bool is_unknown() const {return index == 3;}
		void set_unknown() { set_index(3);  }
		~resource_configuration_t() {clear();}
		struct sgNBPDCPpresent_t : E_RABs_ToBeAdded_SgNBAddReq_Item_SgNBPDCPpresent
		{
			static constexpr const char* name() {return "sgNBPDCPpresent_t";}
			using parent_t = E_RABs_ToBeAdded_SgNBAddReq_Item_SgNBPDCPpresent;

		};
		struct sgNBPDCPnotpresent_t : E_RABs_ToBeAdded_SgNBAddReq_Item_SgNBPDCPnotpresent
		{
			static constexpr const char* name() {return "sgNBPDCPnotpresent_t";}
			using parent_t = E_RABs_ToBeAdded_SgNBAddReq_Item_SgNBPDCPnotpresent;

		};
		void clear()
		{
			switch(get_index())
			{
			case 1: var.destroy<sgNBPDCPpresent_t>(); break;
			case 2: var.destroy<sgNBPDCPnotpresent_t>(); break;
			}
			index = 0;
			base::clear();
		}
		template<typename V> bool decode(size_t idx, V& v)
		{
			clear();
			switch(idx)
			{
			case 1: set_index(1); return v(var.build<sgNBPDCPpresent_t>());
			case 2: set_index(2); return v(var.build<sgNBPDCPnotpresent_t>());
			}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			switch(get_index())
			{
			case 1: return v(var.as<sgNBPDCPpresent_t>());
			case 2: return v(var.as<sgNBPDCPnotpresent_t>());
			}
			return false;
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<sgNBPDCPpresent_t>(1);
			v.template operator()<sgNBPDCPnotpresent_t>(2);

		}
		sgNBPDCPpresent_t& select_sgNBPDCPpresent() { if(get_index() != 1) { clear(); set_index(1); return var.build<sgNBPDCPpresent_t>();} return var.as<sgNBPDCPpresent_t>();}
		sgNBPDCPpresent_t const* get_sgNBPDCPpresent() const { if(get_index() == 1) { return &var.as<sgNBPDCPpresent_t>();} return nullptr; }
		sgNBPDCPnotpresent_t& select_sgNBPDCPnotpresent() { if(get_index() != 2) { clear(); set_index(2); return var.build<sgNBPDCPnotpresent_t>();} return var.as<sgNBPDCPnotpresent_t>();}
		sgNBPDCPnotpresent_t const* get_sgNBPDCPnotpresent() const { if(get_index() == 2) { return &var.as<sgNBPDCPnotpresent_t>();} return nullptr; }
		private:
		void set_index(index_type i) {index = i; base::set();}
		union union_type
		{
			char dummy1[sizeof(sgNBPDCPpresent_t)];
			char dummy2[sizeof(sgNBPDCPnotpresent_t)];

		};
		asn::variant<sizeof(union_type)>	var;
		index_type	index {0};
	};
	resource_configuration_t& ref_resource_configuration() {return resource_configuration;}
	resource_configuration_t const& ref_resource_configuration() const {return resource_configuration;}
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_ToBeAdded_SgNBAddReq_ItemExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_ToBeAdded_SgNBAddReq_ItemExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(e_RAB_ID);
		v(drb_ID);
		v(en_DC_ResourceConfiguration);
		v(resource_configuration);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(e_RAB_ID);
		v(drb_ID);
		v(en_DC_ResourceConfiguration);
		v(resource_configuration);
		v(iE_Extensions);

	};
	void clear()
	{
		e_RAB_ID.clear();
		drb_ID.clear();
		en_DC_ResourceConfiguration.clear();
		resource_configuration.clear();
		iE_Extensions.clear();

	};
	private:
	e_RAB_ID_t	e_RAB_ID;
	drb_ID_t	drb_ID;
	en_DC_ResourceConfiguration_t	en_DC_ResourceConfiguration;
	resource_configuration_t	resource_configuration;
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-ToBeAdded-SgNBAddReq-ItemIEs	X2AP-PROTOCOL-IES ::= {
	{ ID id-E-RABs-ToBeAdded-SgNBAddReq-Item		CRITICALITY reject	TYPE E-RABs-ToBeAdded-SgNBAddReq-Item		PRESENCE mandatory},
	...
}
*/

struct E_RABs_ToBeAdded_SgNBAddReq_ItemIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_ToBeAdded_SgNBAddReq_Item() { set(id_E_RABs_ToBeAdded_SgNBAddReq_Item); type=1;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_E_RABs_ToBeAdded_SgNBAddReq_Item)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_E_RABs_ToBeAdded_SgNBAddReq_Item);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_ToBeAdded_SgNBAddReq_Item() { set(reject); type=1;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		E_RABs_ToBeAdded_SgNBAddReq_Item& select_id_E_RABs_ToBeAdded_SgNBAddReq_Item() { return set<E_RABs_ToBeAdded_SgNBAddReq_Item>(1); }
		E_RABs_ToBeAdded_SgNBAddReq_Item const* get_id_E_RABs_ToBeAdded_SgNBAddReq_Item() const { return get<E_RABs_ToBeAdded_SgNBAddReq_Item>(1); }
		bool is_unknown() const { return type == 2; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<E_RABs_ToBeAdded_SgNBAddReq_Item>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<E_RABs_ToBeAdded_SgNBAddReq_Item>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_E_RABs_ToBeAdded_SgNBAddReq_Item()); return true;
			case 2: if(type != 2) {clear(); asn::base::set();} type = 2; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<E_RABs_ToBeAdded_SgNBAddReq_Item>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(E_RABs_ToBeAdded_SgNBAddReq_Item)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_ToBeAdded_SgNBAddReq_Item() { set(mandatory); type=1;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-ToBeAdded-SgNBAddReqList ::= SEQUENCE (SIZE(1..maxnoofBearers)) OF ProtocolIE-Single-Container { {E-RABs-ToBeAdded-SgNBAddReq-ItemIEs} }
*/

struct E_RABs_ToBeAdded_SgNBAddReqList_elm : ProtocolIE_Single_Container<E_RABs_ToBeAdded_SgNBAddReq_ItemIEs>
{
	static constexpr const char* name() {return "E_RABs_ToBeAdded_SgNBAddReqList_elm";}
	using parent_t = ProtocolIE_Single_Container<E_RABs_ToBeAdded_SgNBAddReq_ItemIEs>;

};
struct E_RABs_ToBeAdded_SgNBAddReqList : asn::sequenceof<E_RABs_ToBeAdded_SgNBAddReqList_elm>
{
	static constexpr const char* name() {return "E-RABs-ToBeAdded-SgNBAddReqList";}
	using parent_t = asn::sequenceof<E_RABs_ToBeAdded_SgNBAddReqList_elm>;
	using constraint_t = asn::constraints<false,asn::span<1,  maxnoofBearers >>;

};
/*
E-RABs-ToBeAdded-SgNBModReq-Item-SgNBPDCPpresentExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	{ ID id-RLCMode-transferred					CRITICALITY ignore	EXTENSION RLCMode					PRESENCE optional},
	...
}
*/

struct E_RABs_ToBeAdded_SgNBModReq_Item_SgNBPDCPpresentExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_RLCMode_transferred() { set(id_RLCMode_transferred); type=1;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_RLCMode_transferred)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_RLCMode_transferred);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_RLCMode_transferred() { set(ignore); type=1;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		RLCMode& select_id_RLCMode_transferred() { return set<RLCMode>(1); }
		RLCMode const* get_id_RLCMode_transferred() const { return get<RLCMode>(1); }
		bool is_unknown() const { return type == 2; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<RLCMode>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<RLCMode>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_RLCMode_transferred()); return true;
			case 2: if(type != 2) {clear(); asn::base::set();} type = 2; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<RLCMode>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(RLCMode)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_RLCMode_transferred() { set(optional); type=1;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(optional)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(optional);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-ToBeAdded-SgNBModReq-Item-SgNBPDCPpresent ::= SEQUENCE {
	full-E-RAB-Level-QoS-Parameters			E-RAB-Level-QoS-Parameters,
	max-MN-admit-E-RAB-Level-QoS-Parameters	GBR-QosInformation															OPTIONAL,
-- This IE shall be present if MCG resource and SCG resources IEs in the the EN-DC Resource Configuration IE are set to present and GBR QoS Information IE is present in Full E-RAB Level QoS Parameters IE --
	dL-Forwarding							DL-Forwarding																		OPTIONAL,
	meNB-DL-GTP-TEIDatMCG					GTPtunnelEndpoint																	OPTIONAL,
-- This IE shall be present if MCG resource IE in the the EN-DC Resource Configuration IE is set to present --
	s1-UL-GTPtunnelEndpoint					GTPtunnelEndpoint,
	iE-Extensions					ProtocolExtensionContainer { {E-RABs-ToBeAdded-SgNBModReq-Item-SgNBPDCPpresentExtIEs} }		OPTIONAL,
	...
}
*/

struct E_RABs_ToBeAdded_SgNBModReq_Item_SgNBPDCPpresent : asn::sequence<6, 0, true, 4>
{
	static constexpr const char* name() {return "E-RABs-ToBeAdded-SgNBModReq-Item-SgNBPDCPpresent";}
	using parent_t = asn::sequence<6, 0, true, 4>;
	struct full_E_RAB_Level_QoS_Parameters_t : E_RAB_Level_QoS_Parameters
	{
		static constexpr const char* name() {return "full_E_RAB_Level_QoS_Parameters_t";}
		using parent_t = E_RAB_Level_QoS_Parameters;

	};
	full_E_RAB_Level_QoS_Parameters_t& ref_full_E_RAB_Level_QoS_Parameters() {return full_E_RAB_Level_QoS_Parameters;}
	full_E_RAB_Level_QoS_Parameters_t const& ref_full_E_RAB_Level_QoS_Parameters() const {return full_E_RAB_Level_QoS_Parameters;}
	struct max_MN_admit_E_RAB_Level_QoS_Parameters_t : GBR_QosInformation
	{
		static constexpr const char* name() {return "max_MN_admit_E_RAB_Level_QoS_Parameters_t";}
		using parent_t = GBR_QosInformation;
		static constexpr bool optional = true;

	};
	max_MN_admit_E_RAB_Level_QoS_Parameters_t& set_max_MN_admit_E_RAB_Level_QoS_Parameters() { max_MN_admit_E_RAB_Level_QoS_Parameters.setpresent(true); return max_MN_admit_E_RAB_Level_QoS_Parameters;}
	max_MN_admit_E_RAB_Level_QoS_Parameters_t const* get_max_MN_admit_E_RAB_Level_QoS_Parameters() const {return max_MN_admit_E_RAB_Level_QoS_Parameters.is_valid() ? &max_MN_admit_E_RAB_Level_QoS_Parameters : nullptr;}
	struct dL_Forwarding_t : DL_Forwarding
	{
		static constexpr const char* name() {return "dL_Forwarding_t";}
		using parent_t = DL_Forwarding;
		static constexpr bool optional = true;

	};
	dL_Forwarding_t& set_dL_Forwarding() { dL_Forwarding.setpresent(true); return dL_Forwarding;}
	dL_Forwarding_t const* get_dL_Forwarding() const {return dL_Forwarding.is_valid() ? &dL_Forwarding : nullptr;}
	struct meNB_DL_GTP_TEIDatMCG_t : GTPtunnelEndpoint
	{
		static constexpr const char* name() {return "meNB_DL_GTP_TEIDatMCG_t";}
		using parent_t = GTPtunnelEndpoint;
		static constexpr bool optional = true;

	};
	meNB_DL_GTP_TEIDatMCG_t& set_meNB_DL_GTP_TEIDatMCG() { meNB_DL_GTP_TEIDatMCG.setpresent(true); return meNB_DL_GTP_TEIDatMCG;}
	meNB_DL_GTP_TEIDatMCG_t const* get_meNB_DL_GTP_TEIDatMCG() const {return meNB_DL_GTP_TEIDatMCG.is_valid() ? &meNB_DL_GTP_TEIDatMCG : nullptr;}
	struct s1_UL_GTPtunnelEndpoint_t : GTPtunnelEndpoint
	{
		static constexpr const char* name() {return "s1_UL_GTPtunnelEndpoint_t";}
		using parent_t = GTPtunnelEndpoint;

	};
	s1_UL_GTPtunnelEndpoint_t& ref_s1_UL_GTPtunnelEndpoint() {return s1_UL_GTPtunnelEndpoint;}
	s1_UL_GTPtunnelEndpoint_t const& ref_s1_UL_GTPtunnelEndpoint() const {return s1_UL_GTPtunnelEndpoint;}
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_ToBeAdded_SgNBModReq_Item_SgNBPDCPpresentExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_ToBeAdded_SgNBModReq_Item_SgNBPDCPpresentExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(full_E_RAB_Level_QoS_Parameters);
		v(max_MN_admit_E_RAB_Level_QoS_Parameters);
		v(dL_Forwarding);
		v(meNB_DL_GTP_TEIDatMCG);
		v(s1_UL_GTPtunnelEndpoint);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(full_E_RAB_Level_QoS_Parameters);
		v(max_MN_admit_E_RAB_Level_QoS_Parameters);
		v(dL_Forwarding);
		v(meNB_DL_GTP_TEIDatMCG);
		v(s1_UL_GTPtunnelEndpoint);
		v(iE_Extensions);

	};
	void clear()
	{
		full_E_RAB_Level_QoS_Parameters.clear();
		max_MN_admit_E_RAB_Level_QoS_Parameters.clear();
		dL_Forwarding.clear();
		meNB_DL_GTP_TEIDatMCG.clear();
		s1_UL_GTPtunnelEndpoint.clear();
		iE_Extensions.clear();

	};
	private:
	full_E_RAB_Level_QoS_Parameters_t	full_E_RAB_Level_QoS_Parameters;
	max_MN_admit_E_RAB_Level_QoS_Parameters_t	max_MN_admit_E_RAB_Level_QoS_Parameters;
	dL_Forwarding_t	dL_Forwarding;
	meNB_DL_GTP_TEIDatMCG_t	meNB_DL_GTP_TEIDatMCG;
	s1_UL_GTPtunnelEndpoint_t	s1_UL_GTPtunnelEndpoint;
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-ToBeAdded-SgNBModReq-Item-SgNBPDCPnotpresentExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	{ ID id-uLpDCPSnLength							CRITICALITY ignore	EXTENSION PDCPSnLength					PRESENCE optional}|
	{ ID id-dLPDCPSnLength							CRITICALITY ignore	EXTENSION PDCPSnLength					PRESENCE optional}|
	{ ID id-duplicationActivation					CRITICALITY ignore	EXTENSION DuplicationActivation	PRESENCE optional},
	...
}
*/

struct E_RABs_ToBeAdded_SgNBModReq_Item_SgNBPDCPnotpresentExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 4; }
		void clear() {type = 0;}
		void select_id_uLpDCPSnLength() { set(id_uLpDCPSnLength); type=1;}
		void select_id_dLPDCPSnLength() { set(id_dLPDCPSnLength); type=2;}
		void select_id_duplicationActivation() { set(id_duplicationActivation); type=3;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_uLpDCPSnLength)) { type = 1; return true; }
			else if(equal(id_dLPDCPSnLength)) { type = 2; return true; }
			else if(equal(id_duplicationActivation)) { type = 3; return true; }
			else { type = 4; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_uLpDCPSnLength);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_dLPDCPSnLength);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_duplicationActivation);} return false;
			case 4: type = 4; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 4; }
		void clear() {type = 0;}
		void select_id_uLpDCPSnLength() { set(ignore); type=1;}
		void select_id_dLPDCPSnLength() { set(ignore); type=2;}
		void select_id_duplicationActivation() { set(ignore); type=3;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else if(equal(ignore)) { type = 2; return true; }
			else if(equal(ignore)) { type = 3; return true; }
			else { type = 4; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(ignore);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(ignore);} return false;
			case 4: type = 4; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		PDCPSnLength& select_id_uLpDCPSnLength() { return set<PDCPSnLength>(1); }
		PDCPSnLength const* get_id_uLpDCPSnLength() const { return get<PDCPSnLength>(1); }
		PDCPSnLength& select_id_dLPDCPSnLength() { return set<PDCPSnLength>(2); }
		PDCPSnLength const* get_id_dLPDCPSnLength() const { return get<PDCPSnLength>(2); }
		DuplicationActivation& select_id_duplicationActivation() { return set<DuplicationActivation>(3); }
		DuplicationActivation const* get_id_duplicationActivation() const { return get<DuplicationActivation>(3); }
		bool is_unknown() const { return type == 4; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<PDCPSnLength>(); break;
			case 2: var.destroy<PDCPSnLength>(); break;
			case 3: var.destroy<DuplicationActivation>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<PDCPSnLength>(1);
			v.template operator()<PDCPSnLength>(2);
			v.template operator()<DuplicationActivation>(3);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_uLpDCPSnLength()); return true;
			case 2: v(select_id_dLPDCPSnLength()); return true;
			case 3: v(select_id_duplicationActivation()); return true;
			case 4: if(type != 4) {clear(); asn::base::set();} type = 4; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<PDCPSnLength>()); return true;
			case 2: v(var.as<PDCPSnLength>()); return true;
			case 3: v(var.as<DuplicationActivation>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(DuplicationActivation)];
			char dummy2[sizeof(PDCPSnLength)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 4; }
		void clear() {type = 0;}
		void select_id_uLpDCPSnLength() { set(optional); type=1;}
		void select_id_dLPDCPSnLength() { set(optional); type=2;}
		void select_id_duplicationActivation() { set(optional); type=3;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(optional)) { type = 1; return true; }
			else if(equal(optional)) { type = 2; return true; }
			else if(equal(optional)) { type = 3; return true; }
			else { type = 4; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(optional);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(optional);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(optional);} return false;
			case 4: type = 4; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-ToBeAdded-SgNBModReq-Item-SgNBPDCPnotpresent ::= SEQUENCE {
	requested-SCG-E-RAB-Level-QoS-Parameters		E-RAB-Level-QoS-Parameters,
	meNB-UL-GTP-TEIDatPDCP							GTPtunnelEndpoint,
	secondary-meNB-UL-GTP-TEIDatPDCP				GTPtunnelEndpoint		OPTIONAL,
	rlc-Mode										RLCMode,
	uL-Configuration								ULConfiguration																OPTIONAL,
-- This IE shall be present if MCG resource and SCG resources IEs in the the EN-DC Resource Configuration IE are set to present --
	iE-Extensions					ProtocolExtensionContainer { {E-RABs-ToBeAdded-SgNBModReq-Item-SgNBPDCPnotpresentExtIEs} } 		OPTIONAL,
	...
}
*/

struct E_RABs_ToBeAdded_SgNBModReq_Item_SgNBPDCPnotpresent : asn::sequence<6, 0, true, 3>
{
	static constexpr const char* name() {return "E-RABs-ToBeAdded-SgNBModReq-Item-SgNBPDCPnotpresent";}
	using parent_t = asn::sequence<6, 0, true, 3>;
	struct requested_SCG_E_RAB_Level_QoS_Parameters_t : E_RAB_Level_QoS_Parameters
	{
		static constexpr const char* name() {return "requested_SCG_E_RAB_Level_QoS_Parameters_t";}
		using parent_t = E_RAB_Level_QoS_Parameters;

	};
	requested_SCG_E_RAB_Level_QoS_Parameters_t& ref_requested_SCG_E_RAB_Level_QoS_Parameters() {return requested_SCG_E_RAB_Level_QoS_Parameters;}
	requested_SCG_E_RAB_Level_QoS_Parameters_t const& ref_requested_SCG_E_RAB_Level_QoS_Parameters() const {return requested_SCG_E_RAB_Level_QoS_Parameters;}
	struct meNB_UL_GTP_TEIDatPDCP_t : GTPtunnelEndpoint
	{
		static constexpr const char* name() {return "meNB_UL_GTP_TEIDatPDCP_t";}
		using parent_t = GTPtunnelEndpoint;

	};
	meNB_UL_GTP_TEIDatPDCP_t& ref_meNB_UL_GTP_TEIDatPDCP() {return meNB_UL_GTP_TEIDatPDCP;}
	meNB_UL_GTP_TEIDatPDCP_t const& ref_meNB_UL_GTP_TEIDatPDCP() const {return meNB_UL_GTP_TEIDatPDCP;}
	struct secondary_meNB_UL_GTP_TEIDatPDCP_t : GTPtunnelEndpoint
	{
		static constexpr const char* name() {return "secondary_meNB_UL_GTP_TEIDatPDCP_t";}
		using parent_t = GTPtunnelEndpoint;
		static constexpr bool optional = true;

	};
	secondary_meNB_UL_GTP_TEIDatPDCP_t& set_secondary_meNB_UL_GTP_TEIDatPDCP() { secondary_meNB_UL_GTP_TEIDatPDCP.setpresent(true); return secondary_meNB_UL_GTP_TEIDatPDCP;}
	secondary_meNB_UL_GTP_TEIDatPDCP_t const* get_secondary_meNB_UL_GTP_TEIDatPDCP() const {return secondary_meNB_UL_GTP_TEIDatPDCP.is_valid() ? &secondary_meNB_UL_GTP_TEIDatPDCP : nullptr;}
	struct rlc_Mode_t : RLCMode
	{
		static constexpr const char* name() {return "rlc_Mode_t";}
		using parent_t = RLCMode;

	};
	rlc_Mode_t& ref_rlc_Mode() {return rlc_Mode;}
	rlc_Mode_t const& ref_rlc_Mode() const {return rlc_Mode;}
	struct uL_Configuration_t : ULConfiguration
	{
		static constexpr const char* name() {return "uL_Configuration_t";}
		using parent_t = ULConfiguration;
		static constexpr bool optional = true;

	};
	uL_Configuration_t& set_uL_Configuration() { uL_Configuration.setpresent(true); return uL_Configuration;}
	uL_Configuration_t const* get_uL_Configuration() const {return uL_Configuration.is_valid() ? &uL_Configuration : nullptr;}
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_ToBeAdded_SgNBModReq_Item_SgNBPDCPnotpresentExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_ToBeAdded_SgNBModReq_Item_SgNBPDCPnotpresentExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(requested_SCG_E_RAB_Level_QoS_Parameters);
		v(meNB_UL_GTP_TEIDatPDCP);
		v(secondary_meNB_UL_GTP_TEIDatPDCP);
		v(rlc_Mode);
		v(uL_Configuration);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(requested_SCG_E_RAB_Level_QoS_Parameters);
		v(meNB_UL_GTP_TEIDatPDCP);
		v(secondary_meNB_UL_GTP_TEIDatPDCP);
		v(rlc_Mode);
		v(uL_Configuration);
		v(iE_Extensions);

	};
	void clear()
	{
		requested_SCG_E_RAB_Level_QoS_Parameters.clear();
		meNB_UL_GTP_TEIDatPDCP.clear();
		secondary_meNB_UL_GTP_TEIDatPDCP.clear();
		rlc_Mode.clear();
		uL_Configuration.clear();
		iE_Extensions.clear();

	};
	private:
	requested_SCG_E_RAB_Level_QoS_Parameters_t	requested_SCG_E_RAB_Level_QoS_Parameters;
	meNB_UL_GTP_TEIDatPDCP_t	meNB_UL_GTP_TEIDatPDCP;
	secondary_meNB_UL_GTP_TEIDatPDCP_t	secondary_meNB_UL_GTP_TEIDatPDCP;
	rlc_Mode_t	rlc_Mode;
	uL_Configuration_t	uL_Configuration;
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-ToBeAdded-SgNBModReq-ItemExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct E_RABs_ToBeAdded_SgNBModReq_ItemExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-ToBeAdded-SgNBModReq-Item ::= SEQUENCE {
	e-RAB-ID								E-RAB-ID,
	drb-ID									DRB-ID,
	en-DC-ResourceConfiguration				EN-DC-ResourceConfiguration,
	resource-configuration					CHOICE {
		sgNBPDCPpresent						E-RABs-ToBeAdded-SgNBModReq-Item-SgNBPDCPpresent,
		sgNBPDCPnotpresent					E-RABs-ToBeAdded-SgNBModReq-Item-SgNBPDCPnotpresent,
		...
	},
	iE-Extensions					ProtocolExtensionContainer { {E-RABs-ToBeAdded-SgNBModReq-ItemExtIEs} }	OPTIONAL,
	...
}
*/

struct E_RABs_ToBeAdded_SgNBModReq_Item : asn::sequence<5, 0, true, 1>
{
	static constexpr const char* name() {return "E-RABs-ToBeAdded-SgNBModReq-Item";}
	using parent_t = asn::sequence<5, 0, true, 1>;
	struct e_RAB_ID_t : E_RAB_ID
	{
		static constexpr const char* name() {return "e_RAB_ID_t";}
		using parent_t = E_RAB_ID;

	};
	e_RAB_ID_t& ref_e_RAB_ID() {return e_RAB_ID;}
	e_RAB_ID_t const& ref_e_RAB_ID() const {return e_RAB_ID;}
	struct drb_ID_t : DRB_ID
	{
		static constexpr const char* name() {return "drb_ID_t";}
		using parent_t = DRB_ID;

	};
	drb_ID_t& ref_drb_ID() {return drb_ID;}
	drb_ID_t const& ref_drb_ID() const {return drb_ID;}
	struct en_DC_ResourceConfiguration_t : EN_DC_ResourceConfiguration
	{
		static constexpr const char* name() {return "en_DC_ResourceConfiguration_t";}
		using parent_t = EN_DC_ResourceConfiguration;

	};
	en_DC_ResourceConfiguration_t& ref_en_DC_ResourceConfiguration() {return en_DC_ResourceConfiguration;}
	en_DC_ResourceConfiguration_t const& ref_en_DC_ResourceConfiguration() const {return en_DC_ResourceConfiguration;}
	struct resource_configuration_t : asn::choice<2, 0, true>
	{
		static constexpr const char* name() {return "resource_configuration_t";}
		using parent_t = asn::choice<2, 0, true>;
		index_type get_index() const {return index;}
		bool is_unknown() const {return index == 3;}
		void set_unknown() { set_index(3);  }
		~resource_configuration_t() {clear();}
		struct sgNBPDCPpresent_t : E_RABs_ToBeAdded_SgNBModReq_Item_SgNBPDCPpresent
		{
			static constexpr const char* name() {return "sgNBPDCPpresent_t";}
			using parent_t = E_RABs_ToBeAdded_SgNBModReq_Item_SgNBPDCPpresent;

		};
		struct sgNBPDCPnotpresent_t : E_RABs_ToBeAdded_SgNBModReq_Item_SgNBPDCPnotpresent
		{
			static constexpr const char* name() {return "sgNBPDCPnotpresent_t";}
			using parent_t = E_RABs_ToBeAdded_SgNBModReq_Item_SgNBPDCPnotpresent;

		};
		void clear()
		{
			switch(get_index())
			{
			case 1: var.destroy<sgNBPDCPpresent_t>(); break;
			case 2: var.destroy<sgNBPDCPnotpresent_t>(); break;
			}
			index = 0;
			base::clear();
		}
		template<typename V> bool decode(size_t idx, V& v)
		{
			clear();
			switch(idx)
			{
			case 1: set_index(1); return v(var.build<sgNBPDCPpresent_t>());
			case 2: set_index(2); return v(var.build<sgNBPDCPnotpresent_t>());
			}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			switch(get_index())
			{
			case 1: return v(var.as<sgNBPDCPpresent_t>());
			case 2: return v(var.as<sgNBPDCPnotpresent_t>());
			}
			return false;
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<sgNBPDCPpresent_t>(1);
			v.template operator()<sgNBPDCPnotpresent_t>(2);

		}
		sgNBPDCPpresent_t& select_sgNBPDCPpresent() { if(get_index() != 1) { clear(); set_index(1); return var.build<sgNBPDCPpresent_t>();} return var.as<sgNBPDCPpresent_t>();}
		sgNBPDCPpresent_t const* get_sgNBPDCPpresent() const { if(get_index() == 1) { return &var.as<sgNBPDCPpresent_t>();} return nullptr; }
		sgNBPDCPnotpresent_t& select_sgNBPDCPnotpresent() { if(get_index() != 2) { clear(); set_index(2); return var.build<sgNBPDCPnotpresent_t>();} return var.as<sgNBPDCPnotpresent_t>();}
		sgNBPDCPnotpresent_t const* get_sgNBPDCPnotpresent() const { if(get_index() == 2) { return &var.as<sgNBPDCPnotpresent_t>();} return nullptr; }
		private:
		void set_index(index_type i) {index = i; base::set();}
		union union_type
		{
			char dummy1[sizeof(sgNBPDCPpresent_t)];
			char dummy2[sizeof(sgNBPDCPnotpresent_t)];

		};
		asn::variant<sizeof(union_type)>	var;
		index_type	index {0};
	};
	resource_configuration_t& ref_resource_configuration() {return resource_configuration;}
	resource_configuration_t const& ref_resource_configuration() const {return resource_configuration;}
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_ToBeAdded_SgNBModReq_ItemExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_ToBeAdded_SgNBModReq_ItemExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(e_RAB_ID);
		v(drb_ID);
		v(en_DC_ResourceConfiguration);
		v(resource_configuration);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(e_RAB_ID);
		v(drb_ID);
		v(en_DC_ResourceConfiguration);
		v(resource_configuration);
		v(iE_Extensions);

	};
	void clear()
	{
		e_RAB_ID.clear();
		drb_ID.clear();
		en_DC_ResourceConfiguration.clear();
		resource_configuration.clear();
		iE_Extensions.clear();

	};
	private:
	e_RAB_ID_t	e_RAB_ID;
	drb_ID_t	drb_ID;
	en_DC_ResourceConfiguration_t	en_DC_ResourceConfiguration;
	resource_configuration_t	resource_configuration;
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-ToBeAdded-SgNBModReq-ItemIEs X2AP-PROTOCOL-IES ::= {
	{ ID id-E-RABs-ToBeAdded-SgNBModReq-Item		CRITICALITY ignore	TYPE E-RABs-ToBeAdded-SgNBModReq-Item		PRESENCE mandatory},
	...
}
*/

struct E_RABs_ToBeAdded_SgNBModReq_ItemIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_ToBeAdded_SgNBModReq_Item() { set(id_E_RABs_ToBeAdded_SgNBModReq_Item); type=1;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_E_RABs_ToBeAdded_SgNBModReq_Item)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_E_RABs_ToBeAdded_SgNBModReq_Item);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_ToBeAdded_SgNBModReq_Item() { set(ignore); type=1;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		E_RABs_ToBeAdded_SgNBModReq_Item& select_id_E_RABs_ToBeAdded_SgNBModReq_Item() { return set<E_RABs_ToBeAdded_SgNBModReq_Item>(1); }
		E_RABs_ToBeAdded_SgNBModReq_Item const* get_id_E_RABs_ToBeAdded_SgNBModReq_Item() const { return get<E_RABs_ToBeAdded_SgNBModReq_Item>(1); }
		bool is_unknown() const { return type == 2; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<E_RABs_ToBeAdded_SgNBModReq_Item>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<E_RABs_ToBeAdded_SgNBModReq_Item>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_E_RABs_ToBeAdded_SgNBModReq_Item()); return true;
			case 2: if(type != 2) {clear(); asn::base::set();} type = 2; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<E_RABs_ToBeAdded_SgNBModReq_Item>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(E_RABs_ToBeAdded_SgNBModReq_Item)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_ToBeAdded_SgNBModReq_Item() { set(mandatory); type=1;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-ToBeAdded-SgNBModReq-List ::= SEQUENCE (SIZE(1..maxnoofBearers)) OF ProtocolIE-Single-Container { {E-RABs-ToBeAdded-SgNBModReq-ItemIEs} }
*/

struct E_RABs_ToBeAdded_SgNBModReq_List_elm : ProtocolIE_Single_Container<E_RABs_ToBeAdded_SgNBModReq_ItemIEs>
{
	static constexpr const char* name() {return "E_RABs_ToBeAdded_SgNBModReq_List_elm";}
	using parent_t = ProtocolIE_Single_Container<E_RABs_ToBeAdded_SgNBModReq_ItemIEs>;

};
struct E_RABs_ToBeAdded_SgNBModReq_List : asn::sequenceof<E_RABs_ToBeAdded_SgNBModReq_List_elm>
{
	static constexpr const char* name() {return "E-RABs-ToBeAdded-SgNBModReq-List";}
	using parent_t = asn::sequenceof<E_RABs_ToBeAdded_SgNBModReq_List_elm>;
	using constraint_t = asn::constraints<false,asn::span<1,  maxnoofBearers >>;

};
/*
E-RABs-ToBeModified-ModReqItem-SCG-BearerExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct E_RABs_ToBeModified_ModReqItem_SCG_BearerExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-ToBeModified-ModReqItem-SCG-Bearer ::= SEQUENCE {
	e-RAB-ID						E-RAB-ID,
	e-RAB-Level-QoS-Parameters		E-RAB-Level-QoS-Parameters														OPTIONAL,
	s1-UL-GTPtunnelEndpoint			GTPtunnelEndpoint																OPTIONAL,
	iE-Extensions					ProtocolExtensionContainer { {E-RABs-ToBeModified-ModReqItem-SCG-BearerExtIEs} } OPTIONAL,
	...
}
*/

struct E_RABs_ToBeModified_ModReqItem_SCG_Bearer : asn::sequence<4, 0, true, 3>
{
	static constexpr const char* name() {return "E-RABs-ToBeModified-ModReqItem-SCG-Bearer";}
	using parent_t = asn::sequence<4, 0, true, 3>;
	struct e_RAB_ID_t : E_RAB_ID
	{
		static constexpr const char* name() {return "e_RAB_ID_t";}
		using parent_t = E_RAB_ID;

	};
	e_RAB_ID_t& ref_e_RAB_ID() {return e_RAB_ID;}
	e_RAB_ID_t const& ref_e_RAB_ID() const {return e_RAB_ID;}
	struct e_RAB_Level_QoS_Parameters_t : E_RAB_Level_QoS_Parameters
	{
		static constexpr const char* name() {return "e_RAB_Level_QoS_Parameters_t";}
		using parent_t = E_RAB_Level_QoS_Parameters;
		static constexpr bool optional = true;

	};
	e_RAB_Level_QoS_Parameters_t& set_e_RAB_Level_QoS_Parameters() { e_RAB_Level_QoS_Parameters.setpresent(true); return e_RAB_Level_QoS_Parameters;}
	e_RAB_Level_QoS_Parameters_t const* get_e_RAB_Level_QoS_Parameters() const {return e_RAB_Level_QoS_Parameters.is_valid() ? &e_RAB_Level_QoS_Parameters : nullptr;}
	struct s1_UL_GTPtunnelEndpoint_t : GTPtunnelEndpoint
	{
		static constexpr const char* name() {return "s1_UL_GTPtunnelEndpoint_t";}
		using parent_t = GTPtunnelEndpoint;
		static constexpr bool optional = true;

	};
	s1_UL_GTPtunnelEndpoint_t& set_s1_UL_GTPtunnelEndpoint() { s1_UL_GTPtunnelEndpoint.setpresent(true); return s1_UL_GTPtunnelEndpoint;}
	s1_UL_GTPtunnelEndpoint_t const* get_s1_UL_GTPtunnelEndpoint() const {return s1_UL_GTPtunnelEndpoint.is_valid() ? &s1_UL_GTPtunnelEndpoint : nullptr;}
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_ToBeModified_ModReqItem_SCG_BearerExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_ToBeModified_ModReqItem_SCG_BearerExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(e_RAB_ID);
		v(e_RAB_Level_QoS_Parameters);
		v(s1_UL_GTPtunnelEndpoint);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(e_RAB_ID);
		v(e_RAB_Level_QoS_Parameters);
		v(s1_UL_GTPtunnelEndpoint);
		v(iE_Extensions);

	};
	void clear()
	{
		e_RAB_ID.clear();
		e_RAB_Level_QoS_Parameters.clear();
		s1_UL_GTPtunnelEndpoint.clear();
		iE_Extensions.clear();

	};
	private:
	e_RAB_ID_t	e_RAB_ID;
	e_RAB_Level_QoS_Parameters_t	e_RAB_Level_QoS_Parameters;
	s1_UL_GTPtunnelEndpoint_t	s1_UL_GTPtunnelEndpoint;
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-ToBeModified-ModReqItem-Split-BearerExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct E_RABs_ToBeModified_ModReqItem_Split_BearerExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-ToBeModified-ModReqItem-Split-Bearer ::= SEQUENCE {
	e-RAB-ID						E-RAB-ID,
	e-RAB-Level-QoS-Parameters		E-RAB-Level-QoS-Parameters																OPTIONAL,
	meNB-GTPtunnelEndpoint			GTPtunnelEndpoint																		OPTIONAL,
	iE-Extensions					ProtocolExtensionContainer { {E-RABs-ToBeModified-ModReqItem-Split-BearerExtIEs} } OPTIONAL,
	...
}
*/

struct E_RABs_ToBeModified_ModReqItem_Split_Bearer : asn::sequence<4, 0, true, 3>
{
	static constexpr const char* name() {return "E-RABs-ToBeModified-ModReqItem-Split-Bearer";}
	using parent_t = asn::sequence<4, 0, true, 3>;
	struct e_RAB_ID_t : E_RAB_ID
	{
		static constexpr const char* name() {return "e_RAB_ID_t";}
		using parent_t = E_RAB_ID;

	};
	e_RAB_ID_t& ref_e_RAB_ID() {return e_RAB_ID;}
	e_RAB_ID_t const& ref_e_RAB_ID() const {return e_RAB_ID;}
	struct e_RAB_Level_QoS_Parameters_t : E_RAB_Level_QoS_Parameters
	{
		static constexpr const char* name() {return "e_RAB_Level_QoS_Parameters_t";}
		using parent_t = E_RAB_Level_QoS_Parameters;
		static constexpr bool optional = true;

	};
	e_RAB_Level_QoS_Parameters_t& set_e_RAB_Level_QoS_Parameters() { e_RAB_Level_QoS_Parameters.setpresent(true); return e_RAB_Level_QoS_Parameters;}
	e_RAB_Level_QoS_Parameters_t const* get_e_RAB_Level_QoS_Parameters() const {return e_RAB_Level_QoS_Parameters.is_valid() ? &e_RAB_Level_QoS_Parameters : nullptr;}
	struct meNB_GTPtunnelEndpoint_t : GTPtunnelEndpoint
	{
		static constexpr const char* name() {return "meNB_GTPtunnelEndpoint_t";}
		using parent_t = GTPtunnelEndpoint;
		static constexpr bool optional = true;

	};
	meNB_GTPtunnelEndpoint_t& set_meNB_GTPtunnelEndpoint() { meNB_GTPtunnelEndpoint.setpresent(true); return meNB_GTPtunnelEndpoint;}
	meNB_GTPtunnelEndpoint_t const* get_meNB_GTPtunnelEndpoint() const {return meNB_GTPtunnelEndpoint.is_valid() ? &meNB_GTPtunnelEndpoint : nullptr;}
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_ToBeModified_ModReqItem_Split_BearerExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_ToBeModified_ModReqItem_Split_BearerExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(e_RAB_ID);
		v(e_RAB_Level_QoS_Parameters);
		v(meNB_GTPtunnelEndpoint);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(e_RAB_ID);
		v(e_RAB_Level_QoS_Parameters);
		v(meNB_GTPtunnelEndpoint);
		v(iE_Extensions);

	};
	void clear()
	{
		e_RAB_ID.clear();
		e_RAB_Level_QoS_Parameters.clear();
		meNB_GTPtunnelEndpoint.clear();
		iE_Extensions.clear();

	};
	private:
	e_RAB_ID_t	e_RAB_ID;
	e_RAB_Level_QoS_Parameters_t	e_RAB_Level_QoS_Parameters;
	meNB_GTPtunnelEndpoint_t	meNB_GTPtunnelEndpoint;
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-ToBeModified-ModReqItem ::= CHOICE {
	sCG-Bearer		E-RABs-ToBeModified-ModReqItem-SCG-Bearer,
	split-Bearer	E-RABs-ToBeModified-ModReqItem-Split-Bearer,
	...
}
*/

struct E_RABs_ToBeModified_ModReqItem : asn::choice<2, 0, true>
{
	static constexpr const char* name() {return "E-RABs-ToBeModified-ModReqItem";}
	using parent_t = asn::choice<2, 0, true>;
	index_type get_index() const {return index;}
	bool is_unknown() const {return index == 3;}
	void set_unknown() { set_index(3);  }
	~E_RABs_ToBeModified_ModReqItem() {clear();}
	struct sCG_Bearer_t : E_RABs_ToBeModified_ModReqItem_SCG_Bearer
	{
		static constexpr const char* name() {return "sCG_Bearer_t";}
		using parent_t = E_RABs_ToBeModified_ModReqItem_SCG_Bearer;

	};
	struct split_Bearer_t : E_RABs_ToBeModified_ModReqItem_Split_Bearer
	{
		static constexpr const char* name() {return "split_Bearer_t";}
		using parent_t = E_RABs_ToBeModified_ModReqItem_Split_Bearer;

	};
	void clear()
	{
		switch(get_index())
		{
		case 1: var.destroy<sCG_Bearer_t>(); break;
		case 2: var.destroy<split_Bearer_t>(); break;
		}
		index = 0;
		base::clear();
	}
	template<typename V> bool decode(size_t idx, V& v)
	{
		clear();
		switch(idx)
		{
		case 1: set_index(1); return v(var.build<sCG_Bearer_t>());
		case 2: set_index(2); return v(var.build<split_Bearer_t>());
		}
		return false;

	}
	template<typename V> bool encode(V& v) const
	{
		switch(get_index())
		{
		case 1: return v(var.as<sCG_Bearer_t>());
		case 2: return v(var.as<split_Bearer_t>());
		}
		return false;
	}
	template<typename V> static inline void enumerate(V& v)
	{
		v.template operator()<sCG_Bearer_t>(1);
		v.template operator()<split_Bearer_t>(2);

	}
	sCG_Bearer_t& select_sCG_Bearer() { if(get_index() != 1) { clear(); set_index(1); return var.build<sCG_Bearer_t>();} return var.as<sCG_Bearer_t>();}
	sCG_Bearer_t const* get_sCG_Bearer() const { if(get_index() == 1) { return &var.as<sCG_Bearer_t>();} return nullptr; }
	split_Bearer_t& select_split_Bearer() { if(get_index() != 2) { clear(); set_index(2); return var.build<split_Bearer_t>();} return var.as<split_Bearer_t>();}
	split_Bearer_t const* get_split_Bearer() const { if(get_index() == 2) { return &var.as<split_Bearer_t>();} return nullptr; }
	private:
	void set_index(index_type i) {index = i; base::set();}
	union union_type
	{
		char dummy1[sizeof(sCG_Bearer_t)];
		char dummy2[sizeof(split_Bearer_t)];

	};
	asn::variant<sizeof(union_type)>	var;
	index_type	index {0};
};
/*
E-RABs-ToBeModified-ModReqItemIEs X2AP-PROTOCOL-IES ::= {
	{ ID id-E-RABs-ToBeModified-ModReqItem	CRITICALITY ignore	TYPE E-RABs-ToBeModified-ModReqItem		PRESENCE mandatory},
	...
}
*/

struct E_RABs_ToBeModified_ModReqItemIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_ToBeModified_ModReqItem() { set(id_E_RABs_ToBeModified_ModReqItem); type=1;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_E_RABs_ToBeModified_ModReqItem)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_E_RABs_ToBeModified_ModReqItem);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_ToBeModified_ModReqItem() { set(ignore); type=1;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		E_RABs_ToBeModified_ModReqItem& select_id_E_RABs_ToBeModified_ModReqItem() { return set<E_RABs_ToBeModified_ModReqItem>(1); }
		E_RABs_ToBeModified_ModReqItem const* get_id_E_RABs_ToBeModified_ModReqItem() const { return get<E_RABs_ToBeModified_ModReqItem>(1); }
		bool is_unknown() const { return type == 2; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<E_RABs_ToBeModified_ModReqItem>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<E_RABs_ToBeModified_ModReqItem>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_E_RABs_ToBeModified_ModReqItem()); return true;
			case 2: if(type != 2) {clear(); asn::base::set();} type = 2; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<E_RABs_ToBeModified_ModReqItem>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(E_RABs_ToBeModified_ModReqItem)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_ToBeModified_ModReqItem() { set(mandatory); type=1;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-ToBeModified-List-ModReq ::= SEQUENCE (SIZE(1..maxnoofBearers)) OF ProtocolIE-Single-Container { {E-RABs-ToBeModified-ModReqItemIEs} }
*/

struct E_RABs_ToBeModified_List_ModReq_elm : ProtocolIE_Single_Container<E_RABs_ToBeModified_ModReqItemIEs>
{
	static constexpr const char* name() {return "E_RABs_ToBeModified_List_ModReq_elm";}
	using parent_t = ProtocolIE_Single_Container<E_RABs_ToBeModified_ModReqItemIEs>;

};
struct E_RABs_ToBeModified_List_ModReq : asn::sequenceof<E_RABs_ToBeModified_List_ModReq_elm>
{
	static constexpr const char* name() {return "E-RABs-ToBeModified-List-ModReq";}
	using parent_t = asn::sequenceof<E_RABs_ToBeModified_List_ModReq_elm>;
	using constraint_t = asn::constraints<false,asn::span<1,  maxnoofBearers >>;

};
/*
E-RABs-ToBeModified-SgNBModReq-Item-SgNBPDCPpresentExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	{ ID id-RLC-Status			CRITICALITY ignore			EXTENSION RLC-Status				PRESENCE optional },
	...
}
*/

struct E_RABs_ToBeModified_SgNBModReq_Item_SgNBPDCPpresentExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_RLC_Status() { set(id_RLC_Status); type=1;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_RLC_Status)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_RLC_Status);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_RLC_Status() { set(ignore); type=1;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		RLC_Status& select_id_RLC_Status() { return set<RLC_Status>(1); }
		RLC_Status const* get_id_RLC_Status() const { return get<RLC_Status>(1); }
		bool is_unknown() const { return type == 2; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<RLC_Status>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<RLC_Status>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_RLC_Status()); return true;
			case 2: if(type != 2) {clear(); asn::base::set();} type = 2; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<RLC_Status>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(RLC_Status)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_RLC_Status() { set(optional); type=1;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(optional)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(optional);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-ToBeModified-SgNBModReq-Item-SgNBPDCPpresent ::= SEQUENCE {
	full-E-RAB-Level-QoS-Parameters			E-RAB-Level-QoS-Parameters																		OPTIONAL,
	max-MN-admit-E-RAB-Level-QoS-Parameters	GBR-QosInformation																		OPTIONAL,
	meNB-DL-GTP-TEIDatMCG					GTPtunnelEndpoint																				OPTIONAL,
	s1-UL-GTPtunnelEndpoint					GTPtunnelEndpoint																				OPTIONAL,
	iE-Extensions					ProtocolExtensionContainer { {E-RABs-ToBeModified-SgNBModReq-Item-SgNBPDCPpresentExtIEs} } 	OPTIONAL,
	...
}
*/

struct E_RABs_ToBeModified_SgNBModReq_Item_SgNBPDCPpresent : asn::sequence<5, 0, true, 5>
{
	static constexpr const char* name() {return "E-RABs-ToBeModified-SgNBModReq-Item-SgNBPDCPpresent";}
	using parent_t = asn::sequence<5, 0, true, 5>;
	struct full_E_RAB_Level_QoS_Parameters_t : E_RAB_Level_QoS_Parameters
	{
		static constexpr const char* name() {return "full_E_RAB_Level_QoS_Parameters_t";}
		using parent_t = E_RAB_Level_QoS_Parameters;
		static constexpr bool optional = true;

	};
	full_E_RAB_Level_QoS_Parameters_t& set_full_E_RAB_Level_QoS_Parameters() { full_E_RAB_Level_QoS_Parameters.setpresent(true); return full_E_RAB_Level_QoS_Parameters;}
	full_E_RAB_Level_QoS_Parameters_t const* get_full_E_RAB_Level_QoS_Parameters() const {return full_E_RAB_Level_QoS_Parameters.is_valid() ? &full_E_RAB_Level_QoS_Parameters : nullptr;}
	struct max_MN_admit_E_RAB_Level_QoS_Parameters_t : GBR_QosInformation
	{
		static constexpr const char* name() {return "max_MN_admit_E_RAB_Level_QoS_Parameters_t";}
		using parent_t = GBR_QosInformation;
		static constexpr bool optional = true;

	};
	max_MN_admit_E_RAB_Level_QoS_Parameters_t& set_max_MN_admit_E_RAB_Level_QoS_Parameters() { max_MN_admit_E_RAB_Level_QoS_Parameters.setpresent(true); return max_MN_admit_E_RAB_Level_QoS_Parameters;}
	max_MN_admit_E_RAB_Level_QoS_Parameters_t const* get_max_MN_admit_E_RAB_Level_QoS_Parameters() const {return max_MN_admit_E_RAB_Level_QoS_Parameters.is_valid() ? &max_MN_admit_E_RAB_Level_QoS_Parameters : nullptr;}
	struct meNB_DL_GTP_TEIDatMCG_t : GTPtunnelEndpoint
	{
		static constexpr const char* name() {return "meNB_DL_GTP_TEIDatMCG_t";}
		using parent_t = GTPtunnelEndpoint;
		static constexpr bool optional = true;

	};
	meNB_DL_GTP_TEIDatMCG_t& set_meNB_DL_GTP_TEIDatMCG() { meNB_DL_GTP_TEIDatMCG.setpresent(true); return meNB_DL_GTP_TEIDatMCG;}
	meNB_DL_GTP_TEIDatMCG_t const* get_meNB_DL_GTP_TEIDatMCG() const {return meNB_DL_GTP_TEIDatMCG.is_valid() ? &meNB_DL_GTP_TEIDatMCG : nullptr;}
	struct s1_UL_GTPtunnelEndpoint_t : GTPtunnelEndpoint
	{
		static constexpr const char* name() {return "s1_UL_GTPtunnelEndpoint_t";}
		using parent_t = GTPtunnelEndpoint;
		static constexpr bool optional = true;

	};
	s1_UL_GTPtunnelEndpoint_t& set_s1_UL_GTPtunnelEndpoint() { s1_UL_GTPtunnelEndpoint.setpresent(true); return s1_UL_GTPtunnelEndpoint;}
	s1_UL_GTPtunnelEndpoint_t const* get_s1_UL_GTPtunnelEndpoint() const {return s1_UL_GTPtunnelEndpoint.is_valid() ? &s1_UL_GTPtunnelEndpoint : nullptr;}
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_ToBeModified_SgNBModReq_Item_SgNBPDCPpresentExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_ToBeModified_SgNBModReq_Item_SgNBPDCPpresentExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(full_E_RAB_Level_QoS_Parameters);
		v(max_MN_admit_E_RAB_Level_QoS_Parameters);
		v(meNB_DL_GTP_TEIDatMCG);
		v(s1_UL_GTPtunnelEndpoint);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(full_E_RAB_Level_QoS_Parameters);
		v(max_MN_admit_E_RAB_Level_QoS_Parameters);
		v(meNB_DL_GTP_TEIDatMCG);
		v(s1_UL_GTPtunnelEndpoint);
		v(iE_Extensions);

	};
	void clear()
	{
		full_E_RAB_Level_QoS_Parameters.clear();
		max_MN_admit_E_RAB_Level_QoS_Parameters.clear();
		meNB_DL_GTP_TEIDatMCG.clear();
		s1_UL_GTPtunnelEndpoint.clear();
		iE_Extensions.clear();

	};
	private:
	full_E_RAB_Level_QoS_Parameters_t	full_E_RAB_Level_QoS_Parameters;
	max_MN_admit_E_RAB_Level_QoS_Parameters_t	max_MN_admit_E_RAB_Level_QoS_Parameters;
	meNB_DL_GTP_TEIDatMCG_t	meNB_DL_GTP_TEIDatMCG;
	s1_UL_GTPtunnelEndpoint_t	s1_UL_GTPtunnelEndpoint;
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-ToBeModified-SgNBModReq-Item-SgNBPDCPnotpresentExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	{ ID id-uLpDCPSnLength							CRITICALITY ignore	EXTENSION PDCPSnLength					PRESENCE optional}|
	{ ID id-dLPDCPSnLength							CRITICALITY ignore	EXTENSION PDCPSnLength					PRESENCE optional}|
	{ ID id-secondarymeNBULGTPTEIDatPDCP				CRITICALITY ignore	EXTENSION GTPtunnelEndpoint			PRESENCE optional},
	...
}
*/

struct E_RABs_ToBeModified_SgNBModReq_Item_SgNBPDCPnotpresentExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 4; }
		void clear() {type = 0;}
		void select_id_uLpDCPSnLength() { set(id_uLpDCPSnLength); type=1;}
		void select_id_dLPDCPSnLength() { set(id_dLPDCPSnLength); type=2;}
		void select_id_secondarymeNBULGTPTEIDatPDCP() { set(id_secondarymeNBULGTPTEIDatPDCP); type=3;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_uLpDCPSnLength)) { type = 1; return true; }
			else if(equal(id_dLPDCPSnLength)) { type = 2; return true; }
			else if(equal(id_secondarymeNBULGTPTEIDatPDCP)) { type = 3; return true; }
			else { type = 4; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_uLpDCPSnLength);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_dLPDCPSnLength);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_secondarymeNBULGTPTEIDatPDCP);} return false;
			case 4: type = 4; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 4; }
		void clear() {type = 0;}
		void select_id_uLpDCPSnLength() { set(ignore); type=1;}
		void select_id_dLPDCPSnLength() { set(ignore); type=2;}
		void select_id_secondarymeNBULGTPTEIDatPDCP() { set(ignore); type=3;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else if(equal(ignore)) { type = 2; return true; }
			else if(equal(ignore)) { type = 3; return true; }
			else { type = 4; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(ignore);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(ignore);} return false;
			case 4: type = 4; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		PDCPSnLength& select_id_uLpDCPSnLength() { return set<PDCPSnLength>(1); }
		PDCPSnLength const* get_id_uLpDCPSnLength() const { return get<PDCPSnLength>(1); }
		PDCPSnLength& select_id_dLPDCPSnLength() { return set<PDCPSnLength>(2); }
		PDCPSnLength const* get_id_dLPDCPSnLength() const { return get<PDCPSnLength>(2); }
		GTPtunnelEndpoint& select_id_secondarymeNBULGTPTEIDatPDCP() { return set<GTPtunnelEndpoint>(3); }
		GTPtunnelEndpoint const* get_id_secondarymeNBULGTPTEIDatPDCP() const { return get<GTPtunnelEndpoint>(3); }
		bool is_unknown() const { return type == 4; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<PDCPSnLength>(); break;
			case 2: var.destroy<PDCPSnLength>(); break;
			case 3: var.destroy<GTPtunnelEndpoint>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<PDCPSnLength>(1);
			v.template operator()<PDCPSnLength>(2);
			v.template operator()<GTPtunnelEndpoint>(3);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_uLpDCPSnLength()); return true;
			case 2: v(select_id_dLPDCPSnLength()); return true;
			case 3: v(select_id_secondarymeNBULGTPTEIDatPDCP()); return true;
			case 4: if(type != 4) {clear(); asn::base::set();} type = 4; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<PDCPSnLength>()); return true;
			case 2: v(var.as<PDCPSnLength>()); return true;
			case 3: v(var.as<GTPtunnelEndpoint>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(GTPtunnelEndpoint)];
			char dummy2[sizeof(PDCPSnLength)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 4; }
		void clear() {type = 0;}
		void select_id_uLpDCPSnLength() { set(optional); type=1;}
		void select_id_dLPDCPSnLength() { set(optional); type=2;}
		void select_id_secondarymeNBULGTPTEIDatPDCP() { set(optional); type=3;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(optional)) { type = 1; return true; }
			else if(equal(optional)) { type = 2; return true; }
			else if(equal(optional)) { type = 3; return true; }
			else { type = 4; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(optional);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(optional);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(optional);} return false;
			case 4: type = 4; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-ToBeModified-SgNBModReq-Item-SgNBPDCPnotpresent ::= SEQUENCE {
	requested-SCG-E-RAB-Level-QoS-Parameters		E-RAB-Level-QoS-Parameters																			OPTIONAL,
	meNB-UL-GTP-TEIDatPDCP						GTPtunnelEndpoint																					OPTIONAL,
	uL-Configuration								ULConfiguration																						OPTIONAL,
	iE-Extensions					ProtocolExtensionContainer { {E-RABs-ToBeModified-SgNBModReq-Item-SgNBPDCPnotpresentExtIEs} } 	OPTIONAL,
	...
}
*/

struct E_RABs_ToBeModified_SgNBModReq_Item_SgNBPDCPnotpresent : asn::sequence<4, 0, true, 4>
{
	static constexpr const char* name() {return "E-RABs-ToBeModified-SgNBModReq-Item-SgNBPDCPnotpresent";}
	using parent_t = asn::sequence<4, 0, true, 4>;
	struct requested_SCG_E_RAB_Level_QoS_Parameters_t : E_RAB_Level_QoS_Parameters
	{
		static constexpr const char* name() {return "requested_SCG_E_RAB_Level_QoS_Parameters_t";}
		using parent_t = E_RAB_Level_QoS_Parameters;
		static constexpr bool optional = true;

	};
	requested_SCG_E_RAB_Level_QoS_Parameters_t& set_requested_SCG_E_RAB_Level_QoS_Parameters() { requested_SCG_E_RAB_Level_QoS_Parameters.setpresent(true); return requested_SCG_E_RAB_Level_QoS_Parameters;}
	requested_SCG_E_RAB_Level_QoS_Parameters_t const* get_requested_SCG_E_RAB_Level_QoS_Parameters() const {return requested_SCG_E_RAB_Level_QoS_Parameters.is_valid() ? &requested_SCG_E_RAB_Level_QoS_Parameters : nullptr;}
	struct meNB_UL_GTP_TEIDatPDCP_t : GTPtunnelEndpoint
	{
		static constexpr const char* name() {return "meNB_UL_GTP_TEIDatPDCP_t";}
		using parent_t = GTPtunnelEndpoint;
		static constexpr bool optional = true;

	};
	meNB_UL_GTP_TEIDatPDCP_t& set_meNB_UL_GTP_TEIDatPDCP() { meNB_UL_GTP_TEIDatPDCP.setpresent(true); return meNB_UL_GTP_TEIDatPDCP;}
	meNB_UL_GTP_TEIDatPDCP_t const* get_meNB_UL_GTP_TEIDatPDCP() const {return meNB_UL_GTP_TEIDatPDCP.is_valid() ? &meNB_UL_GTP_TEIDatPDCP : nullptr;}
	struct uL_Configuration_t : ULConfiguration
	{
		static constexpr const char* name() {return "uL_Configuration_t";}
		using parent_t = ULConfiguration;
		static constexpr bool optional = true;

	};
	uL_Configuration_t& set_uL_Configuration() { uL_Configuration.setpresent(true); return uL_Configuration;}
	uL_Configuration_t const* get_uL_Configuration() const {return uL_Configuration.is_valid() ? &uL_Configuration : nullptr;}
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_ToBeModified_SgNBModReq_Item_SgNBPDCPnotpresentExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_ToBeModified_SgNBModReq_Item_SgNBPDCPnotpresentExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(requested_SCG_E_RAB_Level_QoS_Parameters);
		v(meNB_UL_GTP_TEIDatPDCP);
		v(uL_Configuration);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(requested_SCG_E_RAB_Level_QoS_Parameters);
		v(meNB_UL_GTP_TEIDatPDCP);
		v(uL_Configuration);
		v(iE_Extensions);

	};
	void clear()
	{
		requested_SCG_E_RAB_Level_QoS_Parameters.clear();
		meNB_UL_GTP_TEIDatPDCP.clear();
		uL_Configuration.clear();
		iE_Extensions.clear();

	};
	private:
	requested_SCG_E_RAB_Level_QoS_Parameters_t	requested_SCG_E_RAB_Level_QoS_Parameters;
	meNB_UL_GTP_TEIDatPDCP_t	meNB_UL_GTP_TEIDatPDCP;
	uL_Configuration_t	uL_Configuration;
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-ToBeModified-SgNBModReq-ItemExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct E_RABs_ToBeModified_SgNBModReq_ItemExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-ToBeModified-SgNBModReq-Item ::= SEQUENCE {
	e-RAB-ID								E-RAB-ID,
	en-DC-ResourceConfiguration			EN-DC-ResourceConfiguration,
	resource-configuration				CHOICE {
		sgNBPDCPpresent						E-RABs-ToBeModified-SgNBModReq-Item-SgNBPDCPpresent,
		sgNBPDCPnotpresent					E-RABs-ToBeModified-SgNBModReq-Item-SgNBPDCPnotpresent,
		...
	},
	iE-Extensions					ProtocolExtensionContainer { {E-RABs-ToBeModified-SgNBModReq-ItemExtIEs} }	OPTIONAL,
	...
}
*/

struct E_RABs_ToBeModified_SgNBModReq_Item : asn::sequence<4, 0, true, 1>
{
	static constexpr const char* name() {return "E-RABs-ToBeModified-SgNBModReq-Item";}
	using parent_t = asn::sequence<4, 0, true, 1>;
	struct e_RAB_ID_t : E_RAB_ID
	{
		static constexpr const char* name() {return "e_RAB_ID_t";}
		using parent_t = E_RAB_ID;

	};
	e_RAB_ID_t& ref_e_RAB_ID() {return e_RAB_ID;}
	e_RAB_ID_t const& ref_e_RAB_ID() const {return e_RAB_ID;}
	struct en_DC_ResourceConfiguration_t : EN_DC_ResourceConfiguration
	{
		static constexpr const char* name() {return "en_DC_ResourceConfiguration_t";}
		using parent_t = EN_DC_ResourceConfiguration;

	};
	en_DC_ResourceConfiguration_t& ref_en_DC_ResourceConfiguration() {return en_DC_ResourceConfiguration;}
	en_DC_ResourceConfiguration_t const& ref_en_DC_ResourceConfiguration() const {return en_DC_ResourceConfiguration;}
	struct resource_configuration_t : asn::choice<2, 0, true>
	{
		static constexpr const char* name() {return "resource_configuration_t";}
		using parent_t = asn::choice<2, 0, true>;
		index_type get_index() const {return index;}
		bool is_unknown() const {return index == 3;}
		void set_unknown() { set_index(3);  }
		~resource_configuration_t() {clear();}
		struct sgNBPDCPpresent_t : E_RABs_ToBeModified_SgNBModReq_Item_SgNBPDCPpresent
		{
			static constexpr const char* name() {return "sgNBPDCPpresent_t";}
			using parent_t = E_RABs_ToBeModified_SgNBModReq_Item_SgNBPDCPpresent;

		};
		struct sgNBPDCPnotpresent_t : E_RABs_ToBeModified_SgNBModReq_Item_SgNBPDCPnotpresent
		{
			static constexpr const char* name() {return "sgNBPDCPnotpresent_t";}
			using parent_t = E_RABs_ToBeModified_SgNBModReq_Item_SgNBPDCPnotpresent;

		};
		void clear()
		{
			switch(get_index())
			{
			case 1: var.destroy<sgNBPDCPpresent_t>(); break;
			case 2: var.destroy<sgNBPDCPnotpresent_t>(); break;
			}
			index = 0;
			base::clear();
		}
		template<typename V> bool decode(size_t idx, V& v)
		{
			clear();
			switch(idx)
			{
			case 1: set_index(1); return v(var.build<sgNBPDCPpresent_t>());
			case 2: set_index(2); return v(var.build<sgNBPDCPnotpresent_t>());
			}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			switch(get_index())
			{
			case 1: return v(var.as<sgNBPDCPpresent_t>());
			case 2: return v(var.as<sgNBPDCPnotpresent_t>());
			}
			return false;
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<sgNBPDCPpresent_t>(1);
			v.template operator()<sgNBPDCPnotpresent_t>(2);

		}
		sgNBPDCPpresent_t& select_sgNBPDCPpresent() { if(get_index() != 1) { clear(); set_index(1); return var.build<sgNBPDCPpresent_t>();} return var.as<sgNBPDCPpresent_t>();}
		sgNBPDCPpresent_t const* get_sgNBPDCPpresent() const { if(get_index() == 1) { return &var.as<sgNBPDCPpresent_t>();} return nullptr; }
		sgNBPDCPnotpresent_t& select_sgNBPDCPnotpresent() { if(get_index() != 2) { clear(); set_index(2); return var.build<sgNBPDCPnotpresent_t>();} return var.as<sgNBPDCPnotpresent_t>();}
		sgNBPDCPnotpresent_t const* get_sgNBPDCPnotpresent() const { if(get_index() == 2) { return &var.as<sgNBPDCPnotpresent_t>();} return nullptr; }
		private:
		void set_index(index_type i) {index = i; base::set();}
		union union_type
		{
			char dummy1[sizeof(sgNBPDCPpresent_t)];
			char dummy2[sizeof(sgNBPDCPnotpresent_t)];

		};
		asn::variant<sizeof(union_type)>	var;
		index_type	index {0};
	};
	resource_configuration_t& ref_resource_configuration() {return resource_configuration;}
	resource_configuration_t const& ref_resource_configuration() const {return resource_configuration;}
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_ToBeModified_SgNBModReq_ItemExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_ToBeModified_SgNBModReq_ItemExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(e_RAB_ID);
		v(en_DC_ResourceConfiguration);
		v(resource_configuration);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(e_RAB_ID);
		v(en_DC_ResourceConfiguration);
		v(resource_configuration);
		v(iE_Extensions);

	};
	void clear()
	{
		e_RAB_ID.clear();
		en_DC_ResourceConfiguration.clear();
		resource_configuration.clear();
		iE_Extensions.clear();

	};
	private:
	e_RAB_ID_t	e_RAB_ID;
	en_DC_ResourceConfiguration_t	en_DC_ResourceConfiguration;
	resource_configuration_t	resource_configuration;
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-ToBeModified-SgNBModReq-ItemIEs X2AP-PROTOCOL-IES ::= {
	{ ID id-E-RABs-ToBeModified-SgNBModReq-Item	CRITICALITY ignore	TYPE E-RABs-ToBeModified-SgNBModReq-Item		PRESENCE mandatory},
	...
}
*/

struct E_RABs_ToBeModified_SgNBModReq_ItemIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_ToBeModified_SgNBModReq_Item() { set(id_E_RABs_ToBeModified_SgNBModReq_Item); type=1;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_E_RABs_ToBeModified_SgNBModReq_Item)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_E_RABs_ToBeModified_SgNBModReq_Item);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_ToBeModified_SgNBModReq_Item() { set(ignore); type=1;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		E_RABs_ToBeModified_SgNBModReq_Item& select_id_E_RABs_ToBeModified_SgNBModReq_Item() { return set<E_RABs_ToBeModified_SgNBModReq_Item>(1); }
		E_RABs_ToBeModified_SgNBModReq_Item const* get_id_E_RABs_ToBeModified_SgNBModReq_Item() const { return get<E_RABs_ToBeModified_SgNBModReq_Item>(1); }
		bool is_unknown() const { return type == 2; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<E_RABs_ToBeModified_SgNBModReq_Item>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<E_RABs_ToBeModified_SgNBModReq_Item>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_E_RABs_ToBeModified_SgNBModReq_Item()); return true;
			case 2: if(type != 2) {clear(); asn::base::set();} type = 2; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<E_RABs_ToBeModified_SgNBModReq_Item>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(E_RABs_ToBeModified_SgNBModReq_Item)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_ToBeModified_SgNBModReq_Item() { set(mandatory); type=1;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-ToBeModified-SgNBModReq-List ::= SEQUENCE (SIZE(1..maxnoofBearers)) OF ProtocolIE-Single-Container { {E-RABs-ToBeModified-SgNBModReq-ItemIEs} }
*/

struct E_RABs_ToBeModified_SgNBModReq_List_elm : ProtocolIE_Single_Container<E_RABs_ToBeModified_SgNBModReq_ItemIEs>
{
	static constexpr const char* name() {return "E_RABs_ToBeModified_SgNBModReq_List_elm";}
	using parent_t = ProtocolIE_Single_Container<E_RABs_ToBeModified_SgNBModReq_ItemIEs>;

};
struct E_RABs_ToBeModified_SgNBModReq_List : asn::sequenceof<E_RABs_ToBeModified_SgNBModReq_List_elm>
{
	static constexpr const char* name() {return "E-RABs-ToBeModified-SgNBModReq-List";}
	using parent_t = asn::sequenceof<E_RABs_ToBeModified_SgNBModReq_List_elm>;
	using constraint_t = asn::constraints<false,asn::span<1,  maxnoofBearers >>;

};
/*
E-RABs-ToBeModified-SgNBModReqd-Item-SgNBPDCPpresentExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	{ ID id-uLpDCPSnLength							CRITICALITY ignore	EXTENSION PDCPSnLength					PRESENCE optional}|
	{ ID id-dLPDCPSnLength							CRITICALITY ignore	EXTENSION PDCPSnLength					PRESENCE optional}|
	{ ID id-new-drb-ID-req							CRITICALITY ignore	EXTENSION NewDRBIDrequest				PRESENCE optional},
	...
}
*/

struct E_RABs_ToBeModified_SgNBModReqd_Item_SgNBPDCPpresentExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 4; }
		void clear() {type = 0;}
		void select_id_uLpDCPSnLength() { set(id_uLpDCPSnLength); type=1;}
		void select_id_dLPDCPSnLength() { set(id_dLPDCPSnLength); type=2;}
		void select_id_new_drb_ID_req() { set(id_new_drb_ID_req); type=3;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_uLpDCPSnLength)) { type = 1; return true; }
			else if(equal(id_dLPDCPSnLength)) { type = 2; return true; }
			else if(equal(id_new_drb_ID_req)) { type = 3; return true; }
			else { type = 4; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_uLpDCPSnLength);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_dLPDCPSnLength);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_new_drb_ID_req);} return false;
			case 4: type = 4; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 4; }
		void clear() {type = 0;}
		void select_id_uLpDCPSnLength() { set(ignore); type=1;}
		void select_id_dLPDCPSnLength() { set(ignore); type=2;}
		void select_id_new_drb_ID_req() { set(ignore); type=3;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else if(equal(ignore)) { type = 2; return true; }
			else if(equal(ignore)) { type = 3; return true; }
			else { type = 4; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(ignore);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(ignore);} return false;
			case 4: type = 4; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		PDCPSnLength& select_id_uLpDCPSnLength() { return set<PDCPSnLength>(1); }
		PDCPSnLength const* get_id_uLpDCPSnLength() const { return get<PDCPSnLength>(1); }
		PDCPSnLength& select_id_dLPDCPSnLength() { return set<PDCPSnLength>(2); }
		PDCPSnLength const* get_id_dLPDCPSnLength() const { return get<PDCPSnLength>(2); }
		NewDRBIDrequest& select_id_new_drb_ID_req() { return set<NewDRBIDrequest>(3); }
		NewDRBIDrequest const* get_id_new_drb_ID_req() const { return get<NewDRBIDrequest>(3); }
		bool is_unknown() const { return type == 4; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<PDCPSnLength>(); break;
			case 2: var.destroy<PDCPSnLength>(); break;
			case 3: var.destroy<NewDRBIDrequest>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<PDCPSnLength>(1);
			v.template operator()<PDCPSnLength>(2);
			v.template operator()<NewDRBIDrequest>(3);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_uLpDCPSnLength()); return true;
			case 2: v(select_id_dLPDCPSnLength()); return true;
			case 3: v(select_id_new_drb_ID_req()); return true;
			case 4: if(type != 4) {clear(); asn::base::set();} type = 4; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<PDCPSnLength>()); return true;
			case 2: v(var.as<PDCPSnLength>()); return true;
			case 3: v(var.as<NewDRBIDrequest>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(NewDRBIDrequest)];
			char dummy2[sizeof(PDCPSnLength)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 4; }
		void clear() {type = 0;}
		void select_id_uLpDCPSnLength() { set(optional); type=1;}
		void select_id_dLPDCPSnLength() { set(optional); type=2;}
		void select_id_new_drb_ID_req() { set(optional); type=3;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(optional)) { type = 1; return true; }
			else if(equal(optional)) { type = 2; return true; }
			else if(equal(optional)) { type = 3; return true; }
			else { type = 4; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(optional);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(optional);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(optional);} return false;
			case 4: type = 4; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-ToBeModified-SgNBModReqd-Item-SgNBPDCPpresent ::= SEQUENCE {
	requested-MCG-E-RAB-Level-QoS-Parameters		E-RAB-Level-QoS-Parameters													OPTIONAL,
	uL-Configuration								ULConfiguration																OPTIONAL,
	sgNB-UL-GTP-TEIDatPDCP						GTPtunnelEndpoint															OPTIONAL,
	s1-DL-GTP-TEIDatSgNB							GTPtunnelEndpoint															OPTIONAL,
	iE-Extensions				ProtocolExtensionContainer { {E-RABs-ToBeModified-SgNBModReqd-Item-SgNBPDCPpresentExtIEs} }		OPTIONAL,
	...
}
*/

struct E_RABs_ToBeModified_SgNBModReqd_Item_SgNBPDCPpresent : asn::sequence<5, 0, true, 5>
{
	static constexpr const char* name() {return "E-RABs-ToBeModified-SgNBModReqd-Item-SgNBPDCPpresent";}
	using parent_t = asn::sequence<5, 0, true, 5>;
	struct requested_MCG_E_RAB_Level_QoS_Parameters_t : E_RAB_Level_QoS_Parameters
	{
		static constexpr const char* name() {return "requested_MCG_E_RAB_Level_QoS_Parameters_t";}
		using parent_t = E_RAB_Level_QoS_Parameters;
		static constexpr bool optional = true;

	};
	requested_MCG_E_RAB_Level_QoS_Parameters_t& set_requested_MCG_E_RAB_Level_QoS_Parameters() { requested_MCG_E_RAB_Level_QoS_Parameters.setpresent(true); return requested_MCG_E_RAB_Level_QoS_Parameters;}
	requested_MCG_E_RAB_Level_QoS_Parameters_t const* get_requested_MCG_E_RAB_Level_QoS_Parameters() const {return requested_MCG_E_RAB_Level_QoS_Parameters.is_valid() ? &requested_MCG_E_RAB_Level_QoS_Parameters : nullptr;}
	struct uL_Configuration_t : ULConfiguration
	{
		static constexpr const char* name() {return "uL_Configuration_t";}
		using parent_t = ULConfiguration;
		static constexpr bool optional = true;

	};
	uL_Configuration_t& set_uL_Configuration() { uL_Configuration.setpresent(true); return uL_Configuration;}
	uL_Configuration_t const* get_uL_Configuration() const {return uL_Configuration.is_valid() ? &uL_Configuration : nullptr;}
	struct sgNB_UL_GTP_TEIDatPDCP_t : GTPtunnelEndpoint
	{
		static constexpr const char* name() {return "sgNB_UL_GTP_TEIDatPDCP_t";}
		using parent_t = GTPtunnelEndpoint;
		static constexpr bool optional = true;

	};
	sgNB_UL_GTP_TEIDatPDCP_t& set_sgNB_UL_GTP_TEIDatPDCP() { sgNB_UL_GTP_TEIDatPDCP.setpresent(true); return sgNB_UL_GTP_TEIDatPDCP;}
	sgNB_UL_GTP_TEIDatPDCP_t const* get_sgNB_UL_GTP_TEIDatPDCP() const {return sgNB_UL_GTP_TEIDatPDCP.is_valid() ? &sgNB_UL_GTP_TEIDatPDCP : nullptr;}
	struct s1_DL_GTP_TEIDatSgNB_t : GTPtunnelEndpoint
	{
		static constexpr const char* name() {return "s1_DL_GTP_TEIDatSgNB_t";}
		using parent_t = GTPtunnelEndpoint;
		static constexpr bool optional = true;

	};
	s1_DL_GTP_TEIDatSgNB_t& set_s1_DL_GTP_TEIDatSgNB() { s1_DL_GTP_TEIDatSgNB.setpresent(true); return s1_DL_GTP_TEIDatSgNB;}
	s1_DL_GTP_TEIDatSgNB_t const* get_s1_DL_GTP_TEIDatSgNB() const {return s1_DL_GTP_TEIDatSgNB.is_valid() ? &s1_DL_GTP_TEIDatSgNB : nullptr;}
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_ToBeModified_SgNBModReqd_Item_SgNBPDCPpresentExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_ToBeModified_SgNBModReqd_Item_SgNBPDCPpresentExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(requested_MCG_E_RAB_Level_QoS_Parameters);
		v(uL_Configuration);
		v(sgNB_UL_GTP_TEIDatPDCP);
		v(s1_DL_GTP_TEIDatSgNB);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(requested_MCG_E_RAB_Level_QoS_Parameters);
		v(uL_Configuration);
		v(sgNB_UL_GTP_TEIDatPDCP);
		v(s1_DL_GTP_TEIDatSgNB);
		v(iE_Extensions);

	};
	void clear()
	{
		requested_MCG_E_RAB_Level_QoS_Parameters.clear();
		uL_Configuration.clear();
		sgNB_UL_GTP_TEIDatPDCP.clear();
		s1_DL_GTP_TEIDatSgNB.clear();
		iE_Extensions.clear();

	};
	private:
	requested_MCG_E_RAB_Level_QoS_Parameters_t	requested_MCG_E_RAB_Level_QoS_Parameters;
	uL_Configuration_t	uL_Configuration;
	sgNB_UL_GTP_TEIDatPDCP_t	sgNB_UL_GTP_TEIDatPDCP;
	s1_DL_GTP_TEIDatSgNB_t	s1_DL_GTP_TEIDatSgNB;
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-ToBeModified-SgNBModReqd-Item-SgNBPDCPnotpresentExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	{ ID id-RLC-Status			CRITICALITY ignore			EXTENSION RLC-Status				PRESENCE optional}|
	{ ID id-lCID				CRITICALITY ignore			EXTENSION LCID						PRESENCE optional},
	...
}
*/

struct E_RABs_ToBeModified_SgNBModReqd_Item_SgNBPDCPnotpresentExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 3; }
		void clear() {type = 0;}
		void select_id_RLC_Status() { set(id_RLC_Status); type=1;}
		void select_id_lCID() { set(id_lCID); type=2;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_RLC_Status)) { type = 1; return true; }
			else if(equal(id_lCID)) { type = 2; return true; }
			else { type = 3; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_RLC_Status);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_lCID);} return false;
			case 3: type = 3; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 3; }
		void clear() {type = 0;}
		void select_id_RLC_Status() { set(ignore); type=1;}
		void select_id_lCID() { set(ignore); type=2;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else if(equal(ignore)) { type = 2; return true; }
			else { type = 3; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(ignore);} return false;
			case 3: type = 3; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		RLC_Status& select_id_RLC_Status() { return set<RLC_Status>(1); }
		RLC_Status const* get_id_RLC_Status() const { return get<RLC_Status>(1); }
		LCID& select_id_lCID() { return set<LCID>(2); }
		LCID const* get_id_lCID() const { return get<LCID>(2); }
		bool is_unknown() const { return type == 3; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<RLC_Status>(); break;
			case 2: var.destroy<LCID>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<RLC_Status>(1);
			v.template operator()<LCID>(2);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_RLC_Status()); return true;
			case 2: v(select_id_lCID()); return true;
			case 3: if(type != 3) {clear(); asn::base::set();} type = 3; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<RLC_Status>()); return true;
			case 2: v(var.as<LCID>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(LCID)];
			char dummy2[sizeof(RLC_Status)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 3; }
		void clear() {type = 0;}
		void select_id_RLC_Status() { set(optional); type=1;}
		void select_id_lCID() { set(optional); type=2;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(optional)) { type = 1; return true; }
			else if(equal(optional)) { type = 2; return true; }
			else { type = 3; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(optional);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(optional);} return false;
			case 3: type = 3; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-ToBeModified-SgNBModReqd-Item-SgNBPDCPnotpresent ::= SEQUENCE {
	sgNB-DL-GTP-TEIDatSCG				GTPtunnelEndpoint				OPTIONAL,
	secondary-sgNB-DL-GTP-TEIDatSCG		GTPtunnelEndpoint				OPTIONAL,
	iE-Extensions				ProtocolExtensionContainer { {E-RABs-ToBeModified-SgNBModReqd-Item-SgNBPDCPnotpresentExtIEs} }		OPTIONAL,
	...
}
*/

struct E_RABs_ToBeModified_SgNBModReqd_Item_SgNBPDCPnotpresent : asn::sequence<3, 0, true, 3>
{
	static constexpr const char* name() {return "E-RABs-ToBeModified-SgNBModReqd-Item-SgNBPDCPnotpresent";}
	using parent_t = asn::sequence<3, 0, true, 3>;
	struct sgNB_DL_GTP_TEIDatSCG_t : GTPtunnelEndpoint
	{
		static constexpr const char* name() {return "sgNB_DL_GTP_TEIDatSCG_t";}
		using parent_t = GTPtunnelEndpoint;
		static constexpr bool optional = true;

	};
	sgNB_DL_GTP_TEIDatSCG_t& set_sgNB_DL_GTP_TEIDatSCG() { sgNB_DL_GTP_TEIDatSCG.setpresent(true); return sgNB_DL_GTP_TEIDatSCG;}
	sgNB_DL_GTP_TEIDatSCG_t const* get_sgNB_DL_GTP_TEIDatSCG() const {return sgNB_DL_GTP_TEIDatSCG.is_valid() ? &sgNB_DL_GTP_TEIDatSCG : nullptr;}
	struct secondary_sgNB_DL_GTP_TEIDatSCG_t : GTPtunnelEndpoint
	{
		static constexpr const char* name() {return "secondary_sgNB_DL_GTP_TEIDatSCG_t";}
		using parent_t = GTPtunnelEndpoint;
		static constexpr bool optional = true;

	};
	secondary_sgNB_DL_GTP_TEIDatSCG_t& set_secondary_sgNB_DL_GTP_TEIDatSCG() { secondary_sgNB_DL_GTP_TEIDatSCG.setpresent(true); return secondary_sgNB_DL_GTP_TEIDatSCG;}
	secondary_sgNB_DL_GTP_TEIDatSCG_t const* get_secondary_sgNB_DL_GTP_TEIDatSCG() const {return secondary_sgNB_DL_GTP_TEIDatSCG.is_valid() ? &secondary_sgNB_DL_GTP_TEIDatSCG : nullptr;}
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_ToBeModified_SgNBModReqd_Item_SgNBPDCPnotpresentExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_ToBeModified_SgNBModReqd_Item_SgNBPDCPnotpresentExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(sgNB_DL_GTP_TEIDatSCG);
		v(secondary_sgNB_DL_GTP_TEIDatSCG);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(sgNB_DL_GTP_TEIDatSCG);
		v(secondary_sgNB_DL_GTP_TEIDatSCG);
		v(iE_Extensions);

	};
	void clear()
	{
		sgNB_DL_GTP_TEIDatSCG.clear();
		secondary_sgNB_DL_GTP_TEIDatSCG.clear();
		iE_Extensions.clear();

	};
	private:
	sgNB_DL_GTP_TEIDatSCG_t	sgNB_DL_GTP_TEIDatSCG;
	secondary_sgNB_DL_GTP_TEIDatSCG_t	secondary_sgNB_DL_GTP_TEIDatSCG;
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-ToBeModified-SgNBModReqd-ItemExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct E_RABs_ToBeModified_SgNBModReqd_ItemExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-ToBeModified-SgNBModReqd-Item ::= SEQUENCE {
	e-RAB-ID								E-RAB-ID,
	en-DC-ResourceConfiguration			EN-DC-ResourceConfiguration,
	resource-configuration				CHOICE {
		sgNBPDCPpresent						E-RABs-ToBeModified-SgNBModReqd-Item-SgNBPDCPpresent,
		sgNBPDCPnotpresent					E-RABs-ToBeModified-SgNBModReqd-Item-SgNBPDCPnotpresent,
		...
	},
	iE-Extensions					ProtocolExtensionContainer { {E-RABs-ToBeModified-SgNBModReqd-ItemExtIEs} }	OPTIONAL,
	...
}
*/

struct E_RABs_ToBeModified_SgNBModReqd_Item : asn::sequence<4, 0, true, 1>
{
	static constexpr const char* name() {return "E-RABs-ToBeModified-SgNBModReqd-Item";}
	using parent_t = asn::sequence<4, 0, true, 1>;
	struct e_RAB_ID_t : E_RAB_ID
	{
		static constexpr const char* name() {return "e_RAB_ID_t";}
		using parent_t = E_RAB_ID;

	};
	e_RAB_ID_t& ref_e_RAB_ID() {return e_RAB_ID;}
	e_RAB_ID_t const& ref_e_RAB_ID() const {return e_RAB_ID;}
	struct en_DC_ResourceConfiguration_t : EN_DC_ResourceConfiguration
	{
		static constexpr const char* name() {return "en_DC_ResourceConfiguration_t";}
		using parent_t = EN_DC_ResourceConfiguration;

	};
	en_DC_ResourceConfiguration_t& ref_en_DC_ResourceConfiguration() {return en_DC_ResourceConfiguration;}
	en_DC_ResourceConfiguration_t const& ref_en_DC_ResourceConfiguration() const {return en_DC_ResourceConfiguration;}
	struct resource_configuration_t : asn::choice<2, 0, true>
	{
		static constexpr const char* name() {return "resource_configuration_t";}
		using parent_t = asn::choice<2, 0, true>;
		index_type get_index() const {return index;}
		bool is_unknown() const {return index == 3;}
		void set_unknown() { set_index(3);  }
		~resource_configuration_t() {clear();}
		struct sgNBPDCPpresent_t : E_RABs_ToBeModified_SgNBModReqd_Item_SgNBPDCPpresent
		{
			static constexpr const char* name() {return "sgNBPDCPpresent_t";}
			using parent_t = E_RABs_ToBeModified_SgNBModReqd_Item_SgNBPDCPpresent;

		};
		struct sgNBPDCPnotpresent_t : E_RABs_ToBeModified_SgNBModReqd_Item_SgNBPDCPnotpresent
		{
			static constexpr const char* name() {return "sgNBPDCPnotpresent_t";}
			using parent_t = E_RABs_ToBeModified_SgNBModReqd_Item_SgNBPDCPnotpresent;

		};
		void clear()
		{
			switch(get_index())
			{
			case 1: var.destroy<sgNBPDCPpresent_t>(); break;
			case 2: var.destroy<sgNBPDCPnotpresent_t>(); break;
			}
			index = 0;
			base::clear();
		}
		template<typename V> bool decode(size_t idx, V& v)
		{
			clear();
			switch(idx)
			{
			case 1: set_index(1); return v(var.build<sgNBPDCPpresent_t>());
			case 2: set_index(2); return v(var.build<sgNBPDCPnotpresent_t>());
			}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			switch(get_index())
			{
			case 1: return v(var.as<sgNBPDCPpresent_t>());
			case 2: return v(var.as<sgNBPDCPnotpresent_t>());
			}
			return false;
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<sgNBPDCPpresent_t>(1);
			v.template operator()<sgNBPDCPnotpresent_t>(2);

		}
		sgNBPDCPpresent_t& select_sgNBPDCPpresent() { if(get_index() != 1) { clear(); set_index(1); return var.build<sgNBPDCPpresent_t>();} return var.as<sgNBPDCPpresent_t>();}
		sgNBPDCPpresent_t const* get_sgNBPDCPpresent() const { if(get_index() == 1) { return &var.as<sgNBPDCPpresent_t>();} return nullptr; }
		sgNBPDCPnotpresent_t& select_sgNBPDCPnotpresent() { if(get_index() != 2) { clear(); set_index(2); return var.build<sgNBPDCPnotpresent_t>();} return var.as<sgNBPDCPnotpresent_t>();}
		sgNBPDCPnotpresent_t const* get_sgNBPDCPnotpresent() const { if(get_index() == 2) { return &var.as<sgNBPDCPnotpresent_t>();} return nullptr; }
		private:
		void set_index(index_type i) {index = i; base::set();}
		union union_type
		{
			char dummy1[sizeof(sgNBPDCPpresent_t)];
			char dummy2[sizeof(sgNBPDCPnotpresent_t)];

		};
		asn::variant<sizeof(union_type)>	var;
		index_type	index {0};
	};
	resource_configuration_t& ref_resource_configuration() {return resource_configuration;}
	resource_configuration_t const& ref_resource_configuration() const {return resource_configuration;}
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_ToBeModified_SgNBModReqd_ItemExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_ToBeModified_SgNBModReqd_ItemExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(e_RAB_ID);
		v(en_DC_ResourceConfiguration);
		v(resource_configuration);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(e_RAB_ID);
		v(en_DC_ResourceConfiguration);
		v(resource_configuration);
		v(iE_Extensions);

	};
	void clear()
	{
		e_RAB_ID.clear();
		en_DC_ResourceConfiguration.clear();
		resource_configuration.clear();
		iE_Extensions.clear();

	};
	private:
	e_RAB_ID_t	e_RAB_ID;
	en_DC_ResourceConfiguration_t	en_DC_ResourceConfiguration;
	resource_configuration_t	resource_configuration;
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-ToBeModified-SgNBModReqd-ItemIEs X2AP-PROTOCOL-IES ::= {
	{ ID id-E-RABs-ToBeModified-SgNBModReqd-Item	 CRITICALITY ignore		TYPE E-RABs-ToBeModified-SgNBModReqd-Item		PRESENCE mandatory },
	...
}
*/

struct E_RABs_ToBeModified_SgNBModReqd_ItemIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_ToBeModified_SgNBModReqd_Item() { set(id_E_RABs_ToBeModified_SgNBModReqd_Item); type=1;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_E_RABs_ToBeModified_SgNBModReqd_Item)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_E_RABs_ToBeModified_SgNBModReqd_Item);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_ToBeModified_SgNBModReqd_Item() { set(ignore); type=1;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		E_RABs_ToBeModified_SgNBModReqd_Item& select_id_E_RABs_ToBeModified_SgNBModReqd_Item() { return set<E_RABs_ToBeModified_SgNBModReqd_Item>(1); }
		E_RABs_ToBeModified_SgNBModReqd_Item const* get_id_E_RABs_ToBeModified_SgNBModReqd_Item() const { return get<E_RABs_ToBeModified_SgNBModReqd_Item>(1); }
		bool is_unknown() const { return type == 2; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<E_RABs_ToBeModified_SgNBModReqd_Item>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<E_RABs_ToBeModified_SgNBModReqd_Item>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_E_RABs_ToBeModified_SgNBModReqd_Item()); return true;
			case 2: if(type != 2) {clear(); asn::base::set();} type = 2; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<E_RABs_ToBeModified_SgNBModReqd_Item>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(E_RABs_ToBeModified_SgNBModReqd_Item)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_ToBeModified_SgNBModReqd_Item() { set(mandatory); type=1;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-ToBeModified-SgNBModReqdList ::= SEQUENCE (SIZE (1..maxnoofBearers)) OF ProtocolIE-Single-Container { {E-RABs-ToBeModified-SgNBModReqd-ItemIEs} }
*/

struct E_RABs_ToBeModified_SgNBModReqdList_elm : ProtocolIE_Single_Container<E_RABs_ToBeModified_SgNBModReqd_ItemIEs>
{
	static constexpr const char* name() {return "E_RABs_ToBeModified_SgNBModReqdList_elm";}
	using parent_t = ProtocolIE_Single_Container<E_RABs_ToBeModified_SgNBModReqd_ItemIEs>;

};
struct E_RABs_ToBeModified_SgNBModReqdList : asn::sequenceof<E_RABs_ToBeModified_SgNBModReqdList_elm>
{
	static constexpr const char* name() {return "E-RABs-ToBeModified-SgNBModReqdList";}
	using parent_t = asn::sequenceof<E_RABs_ToBeModified_SgNBModReqdList_elm>;
	using constraint_t = asn::constraints<false,asn::span<1,  maxnoofBearers >>;

};
/*
E-RABs-ToBeReleased-ModReqItem-SCG-BearerExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct E_RABs_ToBeReleased_ModReqItem_SCG_BearerExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-ToBeReleased-ModReqItem-SCG-Bearer ::= SEQUENCE {
	e-RAB-ID						E-RAB-ID,
	dL-Forwarding-GTPtunnelEndpoint			GTPtunnelEndpoint												OPTIONAL,
	uL-Forwarding-GTPtunnelEndpoint			GTPtunnelEndpoint												OPTIONAL,
	iE-Extensions					ProtocolExtensionContainer { {E-RABs-ToBeReleased-ModReqItem-SCG-BearerExtIEs} } OPTIONAL,
	...
}
*/

struct E_RABs_ToBeReleased_ModReqItem_SCG_Bearer : asn::sequence<4, 0, true, 3>
{
	static constexpr const char* name() {return "E-RABs-ToBeReleased-ModReqItem-SCG-Bearer";}
	using parent_t = asn::sequence<4, 0, true, 3>;
	struct e_RAB_ID_t : E_RAB_ID
	{
		static constexpr const char* name() {return "e_RAB_ID_t";}
		using parent_t = E_RAB_ID;

	};
	e_RAB_ID_t& ref_e_RAB_ID() {return e_RAB_ID;}
	e_RAB_ID_t const& ref_e_RAB_ID() const {return e_RAB_ID;}
	struct dL_Forwarding_GTPtunnelEndpoint_t : GTPtunnelEndpoint
	{
		static constexpr const char* name() {return "dL_Forwarding_GTPtunnelEndpoint_t";}
		using parent_t = GTPtunnelEndpoint;
		static constexpr bool optional = true;

	};
	dL_Forwarding_GTPtunnelEndpoint_t& set_dL_Forwarding_GTPtunnelEndpoint() { dL_Forwarding_GTPtunnelEndpoint.setpresent(true); return dL_Forwarding_GTPtunnelEndpoint;}
	dL_Forwarding_GTPtunnelEndpoint_t const* get_dL_Forwarding_GTPtunnelEndpoint() const {return dL_Forwarding_GTPtunnelEndpoint.is_valid() ? &dL_Forwarding_GTPtunnelEndpoint : nullptr;}
	struct uL_Forwarding_GTPtunnelEndpoint_t : GTPtunnelEndpoint
	{
		static constexpr const char* name() {return "uL_Forwarding_GTPtunnelEndpoint_t";}
		using parent_t = GTPtunnelEndpoint;
		static constexpr bool optional = true;

	};
	uL_Forwarding_GTPtunnelEndpoint_t& set_uL_Forwarding_GTPtunnelEndpoint() { uL_Forwarding_GTPtunnelEndpoint.setpresent(true); return uL_Forwarding_GTPtunnelEndpoint;}
	uL_Forwarding_GTPtunnelEndpoint_t const* get_uL_Forwarding_GTPtunnelEndpoint() const {return uL_Forwarding_GTPtunnelEndpoint.is_valid() ? &uL_Forwarding_GTPtunnelEndpoint : nullptr;}
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_ToBeReleased_ModReqItem_SCG_BearerExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_ToBeReleased_ModReqItem_SCG_BearerExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(e_RAB_ID);
		v(dL_Forwarding_GTPtunnelEndpoint);
		v(uL_Forwarding_GTPtunnelEndpoint);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(e_RAB_ID);
		v(dL_Forwarding_GTPtunnelEndpoint);
		v(uL_Forwarding_GTPtunnelEndpoint);
		v(iE_Extensions);

	};
	void clear()
	{
		e_RAB_ID.clear();
		dL_Forwarding_GTPtunnelEndpoint.clear();
		uL_Forwarding_GTPtunnelEndpoint.clear();
		iE_Extensions.clear();

	};
	private:
	e_RAB_ID_t	e_RAB_ID;
	dL_Forwarding_GTPtunnelEndpoint_t	dL_Forwarding_GTPtunnelEndpoint;
	uL_Forwarding_GTPtunnelEndpoint_t	uL_Forwarding_GTPtunnelEndpoint;
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-ToBeReleased-ModReqItem-Split-BearerExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct E_RABs_ToBeReleased_ModReqItem_Split_BearerExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-ToBeReleased-ModReqItem-Split-Bearer ::= SEQUENCE {
	e-RAB-ID						E-RAB-ID,
	dL-Forwarding-GTPtunnelEndpoint			GTPtunnelEndpoint												OPTIONAL,
	iE-Extensions					ProtocolExtensionContainer { {E-RABs-ToBeReleased-ModReqItem-Split-BearerExtIEs} } OPTIONAL,
	...
}
*/

struct E_RABs_ToBeReleased_ModReqItem_Split_Bearer : asn::sequence<3, 0, true, 2>
{
	static constexpr const char* name() {return "E-RABs-ToBeReleased-ModReqItem-Split-Bearer";}
	using parent_t = asn::sequence<3, 0, true, 2>;
	struct e_RAB_ID_t : E_RAB_ID
	{
		static constexpr const char* name() {return "e_RAB_ID_t";}
		using parent_t = E_RAB_ID;

	};
	e_RAB_ID_t& ref_e_RAB_ID() {return e_RAB_ID;}
	e_RAB_ID_t const& ref_e_RAB_ID() const {return e_RAB_ID;}
	struct dL_Forwarding_GTPtunnelEndpoint_t : GTPtunnelEndpoint
	{
		static constexpr const char* name() {return "dL_Forwarding_GTPtunnelEndpoint_t";}
		using parent_t = GTPtunnelEndpoint;
		static constexpr bool optional = true;

	};
	dL_Forwarding_GTPtunnelEndpoint_t& set_dL_Forwarding_GTPtunnelEndpoint() { dL_Forwarding_GTPtunnelEndpoint.setpresent(true); return dL_Forwarding_GTPtunnelEndpoint;}
	dL_Forwarding_GTPtunnelEndpoint_t const* get_dL_Forwarding_GTPtunnelEndpoint() const {return dL_Forwarding_GTPtunnelEndpoint.is_valid() ? &dL_Forwarding_GTPtunnelEndpoint : nullptr;}
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_ToBeReleased_ModReqItem_Split_BearerExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_ToBeReleased_ModReqItem_Split_BearerExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(e_RAB_ID);
		v(dL_Forwarding_GTPtunnelEndpoint);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(e_RAB_ID);
		v(dL_Forwarding_GTPtunnelEndpoint);
		v(iE_Extensions);

	};
	void clear()
	{
		e_RAB_ID.clear();
		dL_Forwarding_GTPtunnelEndpoint.clear();
		iE_Extensions.clear();

	};
	private:
	e_RAB_ID_t	e_RAB_ID;
	dL_Forwarding_GTPtunnelEndpoint_t	dL_Forwarding_GTPtunnelEndpoint;
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-ToBeReleased-ModReqItem ::= CHOICE {
	sCG-Bearer		E-RABs-ToBeReleased-ModReqItem-SCG-Bearer,
	split-Bearer	E-RABs-ToBeReleased-ModReqItem-Split-Bearer,
	...
}
*/

struct E_RABs_ToBeReleased_ModReqItem : asn::choice<2, 0, true>
{
	static constexpr const char* name() {return "E-RABs-ToBeReleased-ModReqItem";}
	using parent_t = asn::choice<2, 0, true>;
	index_type get_index() const {return index;}
	bool is_unknown() const {return index == 3;}
	void set_unknown() { set_index(3);  }
	~E_RABs_ToBeReleased_ModReqItem() {clear();}
	struct sCG_Bearer_t : E_RABs_ToBeReleased_ModReqItem_SCG_Bearer
	{
		static constexpr const char* name() {return "sCG_Bearer_t";}
		using parent_t = E_RABs_ToBeReleased_ModReqItem_SCG_Bearer;

	};
	struct split_Bearer_t : E_RABs_ToBeReleased_ModReqItem_Split_Bearer
	{
		static constexpr const char* name() {return "split_Bearer_t";}
		using parent_t = E_RABs_ToBeReleased_ModReqItem_Split_Bearer;

	};
	void clear()
	{
		switch(get_index())
		{
		case 1: var.destroy<sCG_Bearer_t>(); break;
		case 2: var.destroy<split_Bearer_t>(); break;
		}
		index = 0;
		base::clear();
	}
	template<typename V> bool decode(size_t idx, V& v)
	{
		clear();
		switch(idx)
		{
		case 1: set_index(1); return v(var.build<sCG_Bearer_t>());
		case 2: set_index(2); return v(var.build<split_Bearer_t>());
		}
		return false;

	}
	template<typename V> bool encode(V& v) const
	{
		switch(get_index())
		{
		case 1: return v(var.as<sCG_Bearer_t>());
		case 2: return v(var.as<split_Bearer_t>());
		}
		return false;
	}
	template<typename V> static inline void enumerate(V& v)
	{
		v.template operator()<sCG_Bearer_t>(1);
		v.template operator()<split_Bearer_t>(2);

	}
	sCG_Bearer_t& select_sCG_Bearer() { if(get_index() != 1) { clear(); set_index(1); return var.build<sCG_Bearer_t>();} return var.as<sCG_Bearer_t>();}
	sCG_Bearer_t const* get_sCG_Bearer() const { if(get_index() == 1) { return &var.as<sCG_Bearer_t>();} return nullptr; }
	split_Bearer_t& select_split_Bearer() { if(get_index() != 2) { clear(); set_index(2); return var.build<split_Bearer_t>();} return var.as<split_Bearer_t>();}
	split_Bearer_t const* get_split_Bearer() const { if(get_index() == 2) { return &var.as<split_Bearer_t>();} return nullptr; }
	private:
	void set_index(index_type i) {index = i; base::set();}
	union union_type
	{
		char dummy1[sizeof(sCG_Bearer_t)];
		char dummy2[sizeof(split_Bearer_t)];

	};
	asn::variant<sizeof(union_type)>	var;
	index_type	index {0};
};
/*
E-RABs-ToBeReleased-ModReqItemIEs X2AP-PROTOCOL-IES ::= {
	{ ID id-E-RABs-ToBeReleased-ModReqItem	CRITICALITY ignore	TYPE E-RABs-ToBeReleased-ModReqItem		PRESENCE mandatory},
	...
}
*/

struct E_RABs_ToBeReleased_ModReqItemIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_ToBeReleased_ModReqItem() { set(id_E_RABs_ToBeReleased_ModReqItem); type=1;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_E_RABs_ToBeReleased_ModReqItem)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_E_RABs_ToBeReleased_ModReqItem);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_ToBeReleased_ModReqItem() { set(ignore); type=1;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		E_RABs_ToBeReleased_ModReqItem& select_id_E_RABs_ToBeReleased_ModReqItem() { return set<E_RABs_ToBeReleased_ModReqItem>(1); }
		E_RABs_ToBeReleased_ModReqItem const* get_id_E_RABs_ToBeReleased_ModReqItem() const { return get<E_RABs_ToBeReleased_ModReqItem>(1); }
		bool is_unknown() const { return type == 2; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<E_RABs_ToBeReleased_ModReqItem>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<E_RABs_ToBeReleased_ModReqItem>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_E_RABs_ToBeReleased_ModReqItem()); return true;
			case 2: if(type != 2) {clear(); asn::base::set();} type = 2; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<E_RABs_ToBeReleased_ModReqItem>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(E_RABs_ToBeReleased_ModReqItem)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_ToBeReleased_ModReqItem() { set(mandatory); type=1;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-ToBeReleased-List-ModReq ::= SEQUENCE (SIZE(1..maxnoofBearers)) OF ProtocolIE-Single-Container { {E-RABs-ToBeReleased-ModReqItemIEs} }
*/

struct E_RABs_ToBeReleased_List_ModReq_elm : ProtocolIE_Single_Container<E_RABs_ToBeReleased_ModReqItemIEs>
{
	static constexpr const char* name() {return "E_RABs_ToBeReleased_List_ModReq_elm";}
	using parent_t = ProtocolIE_Single_Container<E_RABs_ToBeReleased_ModReqItemIEs>;

};
struct E_RABs_ToBeReleased_List_ModReq : asn::sequenceof<E_RABs_ToBeReleased_List_ModReq_elm>
{
	static constexpr const char* name() {return "E-RABs-ToBeReleased-List-ModReq";}
	using parent_t = asn::sequenceof<E_RABs_ToBeReleased_List_ModReq_elm>;
	using constraint_t = asn::constraints<false,asn::span<1,  maxnoofBearers >>;

};
/*
E-RABs-ToBeReleased-RelConfItem-SCG-BearerExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct E_RABs_ToBeReleased_RelConfItem_SCG_BearerExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-ToBeReleased-RelConfItem-SCG-Bearer ::= SEQUENCE {
	e-RAB-ID						E-RAB-ID,
	uL-Forwarding-GTPtunnelEndpoint			GTPtunnelEndpoint												OPTIONAL,
	dL-Forwarding-GTPtunnelEndpoint			GTPtunnelEndpoint												OPTIONAL,
	iE-Extensions					ProtocolExtensionContainer { {E-RABs-ToBeReleased-RelConfItem-SCG-BearerExtIEs} } OPTIONAL,
	...
}
*/

struct E_RABs_ToBeReleased_RelConfItem_SCG_Bearer : asn::sequence<4, 0, true, 3>
{
	static constexpr const char* name() {return "E-RABs-ToBeReleased-RelConfItem-SCG-Bearer";}
	using parent_t = asn::sequence<4, 0, true, 3>;
	struct e_RAB_ID_t : E_RAB_ID
	{
		static constexpr const char* name() {return "e_RAB_ID_t";}
		using parent_t = E_RAB_ID;

	};
	e_RAB_ID_t& ref_e_RAB_ID() {return e_RAB_ID;}
	e_RAB_ID_t const& ref_e_RAB_ID() const {return e_RAB_ID;}
	struct uL_Forwarding_GTPtunnelEndpoint_t : GTPtunnelEndpoint
	{
		static constexpr const char* name() {return "uL_Forwarding_GTPtunnelEndpoint_t";}
		using parent_t = GTPtunnelEndpoint;
		static constexpr bool optional = true;

	};
	uL_Forwarding_GTPtunnelEndpoint_t& set_uL_Forwarding_GTPtunnelEndpoint() { uL_Forwarding_GTPtunnelEndpoint.setpresent(true); return uL_Forwarding_GTPtunnelEndpoint;}
	uL_Forwarding_GTPtunnelEndpoint_t const* get_uL_Forwarding_GTPtunnelEndpoint() const {return uL_Forwarding_GTPtunnelEndpoint.is_valid() ? &uL_Forwarding_GTPtunnelEndpoint : nullptr;}
	struct dL_Forwarding_GTPtunnelEndpoint_t : GTPtunnelEndpoint
	{
		static constexpr const char* name() {return "dL_Forwarding_GTPtunnelEndpoint_t";}
		using parent_t = GTPtunnelEndpoint;
		static constexpr bool optional = true;

	};
	dL_Forwarding_GTPtunnelEndpoint_t& set_dL_Forwarding_GTPtunnelEndpoint() { dL_Forwarding_GTPtunnelEndpoint.setpresent(true); return dL_Forwarding_GTPtunnelEndpoint;}
	dL_Forwarding_GTPtunnelEndpoint_t const* get_dL_Forwarding_GTPtunnelEndpoint() const {return dL_Forwarding_GTPtunnelEndpoint.is_valid() ? &dL_Forwarding_GTPtunnelEndpoint : nullptr;}
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_ToBeReleased_RelConfItem_SCG_BearerExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_ToBeReleased_RelConfItem_SCG_BearerExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(e_RAB_ID);
		v(uL_Forwarding_GTPtunnelEndpoint);
		v(dL_Forwarding_GTPtunnelEndpoint);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(e_RAB_ID);
		v(uL_Forwarding_GTPtunnelEndpoint);
		v(dL_Forwarding_GTPtunnelEndpoint);
		v(iE_Extensions);

	};
	void clear()
	{
		e_RAB_ID.clear();
		uL_Forwarding_GTPtunnelEndpoint.clear();
		dL_Forwarding_GTPtunnelEndpoint.clear();
		iE_Extensions.clear();

	};
	private:
	e_RAB_ID_t	e_RAB_ID;
	uL_Forwarding_GTPtunnelEndpoint_t	uL_Forwarding_GTPtunnelEndpoint;
	dL_Forwarding_GTPtunnelEndpoint_t	dL_Forwarding_GTPtunnelEndpoint;
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-ToBeReleased-RelConfItem-Split-BearerExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct E_RABs_ToBeReleased_RelConfItem_Split_BearerExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-ToBeReleased-RelConfItem-Split-Bearer ::= SEQUENCE {
	e-RAB-ID						E-RAB-ID,
	dL-Forwarding-GTPtunnelEndpoint			GTPtunnelEndpoint													OPTIONAL,
	iE-Extensions					ProtocolExtensionContainer { {E-RABs-ToBeReleased-RelConfItem-Split-BearerExtIEs} } OPTIONAL,
	...
}
*/

struct E_RABs_ToBeReleased_RelConfItem_Split_Bearer : asn::sequence<3, 0, true, 2>
{
	static constexpr const char* name() {return "E-RABs-ToBeReleased-RelConfItem-Split-Bearer";}
	using parent_t = asn::sequence<3, 0, true, 2>;
	struct e_RAB_ID_t : E_RAB_ID
	{
		static constexpr const char* name() {return "e_RAB_ID_t";}
		using parent_t = E_RAB_ID;

	};
	e_RAB_ID_t& ref_e_RAB_ID() {return e_RAB_ID;}
	e_RAB_ID_t const& ref_e_RAB_ID() const {return e_RAB_ID;}
	struct dL_Forwarding_GTPtunnelEndpoint_t : GTPtunnelEndpoint
	{
		static constexpr const char* name() {return "dL_Forwarding_GTPtunnelEndpoint_t";}
		using parent_t = GTPtunnelEndpoint;
		static constexpr bool optional = true;

	};
	dL_Forwarding_GTPtunnelEndpoint_t& set_dL_Forwarding_GTPtunnelEndpoint() { dL_Forwarding_GTPtunnelEndpoint.setpresent(true); return dL_Forwarding_GTPtunnelEndpoint;}
	dL_Forwarding_GTPtunnelEndpoint_t const* get_dL_Forwarding_GTPtunnelEndpoint() const {return dL_Forwarding_GTPtunnelEndpoint.is_valid() ? &dL_Forwarding_GTPtunnelEndpoint : nullptr;}
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_ToBeReleased_RelConfItem_Split_BearerExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_ToBeReleased_RelConfItem_Split_BearerExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(e_RAB_ID);
		v(dL_Forwarding_GTPtunnelEndpoint);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(e_RAB_ID);
		v(dL_Forwarding_GTPtunnelEndpoint);
		v(iE_Extensions);

	};
	void clear()
	{
		e_RAB_ID.clear();
		dL_Forwarding_GTPtunnelEndpoint.clear();
		iE_Extensions.clear();

	};
	private:
	e_RAB_ID_t	e_RAB_ID;
	dL_Forwarding_GTPtunnelEndpoint_t	dL_Forwarding_GTPtunnelEndpoint;
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-ToBeReleased-RelConfItem ::= CHOICE {
	sCG-Bearer		E-RABs-ToBeReleased-RelConfItem-SCG-Bearer,
	split-Bearer	E-RABs-ToBeReleased-RelConfItem-Split-Bearer,
	...
}
*/

struct E_RABs_ToBeReleased_RelConfItem : asn::choice<2, 0, true>
{
	static constexpr const char* name() {return "E-RABs-ToBeReleased-RelConfItem";}
	using parent_t = asn::choice<2, 0, true>;
	index_type get_index() const {return index;}
	bool is_unknown() const {return index == 3;}
	void set_unknown() { set_index(3);  }
	~E_RABs_ToBeReleased_RelConfItem() {clear();}
	struct sCG_Bearer_t : E_RABs_ToBeReleased_RelConfItem_SCG_Bearer
	{
		static constexpr const char* name() {return "sCG_Bearer_t";}
		using parent_t = E_RABs_ToBeReleased_RelConfItem_SCG_Bearer;

	};
	struct split_Bearer_t : E_RABs_ToBeReleased_RelConfItem_Split_Bearer
	{
		static constexpr const char* name() {return "split_Bearer_t";}
		using parent_t = E_RABs_ToBeReleased_RelConfItem_Split_Bearer;

	};
	void clear()
	{
		switch(get_index())
		{
		case 1: var.destroy<sCG_Bearer_t>(); break;
		case 2: var.destroy<split_Bearer_t>(); break;
		}
		index = 0;
		base::clear();
	}
	template<typename V> bool decode(size_t idx, V& v)
	{
		clear();
		switch(idx)
		{
		case 1: set_index(1); return v(var.build<sCG_Bearer_t>());
		case 2: set_index(2); return v(var.build<split_Bearer_t>());
		}
		return false;

	}
	template<typename V> bool encode(V& v) const
	{
		switch(get_index())
		{
		case 1: return v(var.as<sCG_Bearer_t>());
		case 2: return v(var.as<split_Bearer_t>());
		}
		return false;
	}
	template<typename V> static inline void enumerate(V& v)
	{
		v.template operator()<sCG_Bearer_t>(1);
		v.template operator()<split_Bearer_t>(2);

	}
	sCG_Bearer_t& select_sCG_Bearer() { if(get_index() != 1) { clear(); set_index(1); return var.build<sCG_Bearer_t>();} return var.as<sCG_Bearer_t>();}
	sCG_Bearer_t const* get_sCG_Bearer() const { if(get_index() == 1) { return &var.as<sCG_Bearer_t>();} return nullptr; }
	split_Bearer_t& select_split_Bearer() { if(get_index() != 2) { clear(); set_index(2); return var.build<split_Bearer_t>();} return var.as<split_Bearer_t>();}
	split_Bearer_t const* get_split_Bearer() const { if(get_index() == 2) { return &var.as<split_Bearer_t>();} return nullptr; }
	private:
	void set_index(index_type i) {index = i; base::set();}
	union union_type
	{
		char dummy1[sizeof(sCG_Bearer_t)];
		char dummy2[sizeof(split_Bearer_t)];

	};
	asn::variant<sizeof(union_type)>	var;
	index_type	index {0};
};
/*
E-RABs-ToBeReleased-RelConfItemIEs X2AP-PROTOCOL-IES ::= {
	{ ID id-E-RABs-ToBeReleased-RelConfItem		CRITICALITY ignore		TYPE E-RABs-ToBeReleased-RelConfItem		PRESENCE mandatory},
	...
}
*/

struct E_RABs_ToBeReleased_RelConfItemIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_ToBeReleased_RelConfItem() { set(id_E_RABs_ToBeReleased_RelConfItem); type=1;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_E_RABs_ToBeReleased_RelConfItem)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_E_RABs_ToBeReleased_RelConfItem);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_ToBeReleased_RelConfItem() { set(ignore); type=1;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		E_RABs_ToBeReleased_RelConfItem& select_id_E_RABs_ToBeReleased_RelConfItem() { return set<E_RABs_ToBeReleased_RelConfItem>(1); }
		E_RABs_ToBeReleased_RelConfItem const* get_id_E_RABs_ToBeReleased_RelConfItem() const { return get<E_RABs_ToBeReleased_RelConfItem>(1); }
		bool is_unknown() const { return type == 2; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<E_RABs_ToBeReleased_RelConfItem>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<E_RABs_ToBeReleased_RelConfItem>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_E_RABs_ToBeReleased_RelConfItem()); return true;
			case 2: if(type != 2) {clear(); asn::base::set();} type = 2; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<E_RABs_ToBeReleased_RelConfItem>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(E_RABs_ToBeReleased_RelConfItem)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_ToBeReleased_RelConfItem() { set(mandatory); type=1;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-ToBeReleased-List-RelConf ::= SEQUENCE (SIZE(1..maxnoofBearers)) OF ProtocolIE-Single-Container { {E-RABs-ToBeReleased-RelConfItemIEs} }
*/

struct E_RABs_ToBeReleased_List_RelConf_elm : ProtocolIE_Single_Container<E_RABs_ToBeReleased_RelConfItemIEs>
{
	static constexpr const char* name() {return "E_RABs_ToBeReleased_List_RelConf_elm";}
	using parent_t = ProtocolIE_Single_Container<E_RABs_ToBeReleased_RelConfItemIEs>;

};
struct E_RABs_ToBeReleased_List_RelConf : asn::sequenceof<E_RABs_ToBeReleased_List_RelConf_elm>
{
	static constexpr const char* name() {return "E-RABs-ToBeReleased-List-RelConf";}
	using parent_t = asn::sequenceof<E_RABs_ToBeReleased_List_RelConf_elm>;
	using constraint_t = asn::constraints<false,asn::span<1,  maxnoofBearers >>;

};
/*
E-RABs-ToBeReleased-RelReqItem-SCG-BearerExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct E_RABs_ToBeReleased_RelReqItem_SCG_BearerExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-ToBeReleased-RelReqItem-SCG-Bearer ::= SEQUENCE {
	e-RAB-ID						E-RAB-ID,
	uL-Forwarding-GTPtunnelEndpoint			GTPtunnelEndpoint												OPTIONAL,
	dL-Forwarding-GTPtunnelEndpoint			GTPtunnelEndpoint												OPTIONAL,
	iE-Extensions					ProtocolExtensionContainer { {E-RABs-ToBeReleased-RelReqItem-SCG-BearerExtIEs} } OPTIONAL,
	...
}
*/

struct E_RABs_ToBeReleased_RelReqItem_SCG_Bearer : asn::sequence<4, 0, true, 3>
{
	static constexpr const char* name() {return "E-RABs-ToBeReleased-RelReqItem-SCG-Bearer";}
	using parent_t = asn::sequence<4, 0, true, 3>;
	struct e_RAB_ID_t : E_RAB_ID
	{
		static constexpr const char* name() {return "e_RAB_ID_t";}
		using parent_t = E_RAB_ID;

	};
	e_RAB_ID_t& ref_e_RAB_ID() {return e_RAB_ID;}
	e_RAB_ID_t const& ref_e_RAB_ID() const {return e_RAB_ID;}
	struct uL_Forwarding_GTPtunnelEndpoint_t : GTPtunnelEndpoint
	{
		static constexpr const char* name() {return "uL_Forwarding_GTPtunnelEndpoint_t";}
		using parent_t = GTPtunnelEndpoint;
		static constexpr bool optional = true;

	};
	uL_Forwarding_GTPtunnelEndpoint_t& set_uL_Forwarding_GTPtunnelEndpoint() { uL_Forwarding_GTPtunnelEndpoint.setpresent(true); return uL_Forwarding_GTPtunnelEndpoint;}
	uL_Forwarding_GTPtunnelEndpoint_t const* get_uL_Forwarding_GTPtunnelEndpoint() const {return uL_Forwarding_GTPtunnelEndpoint.is_valid() ? &uL_Forwarding_GTPtunnelEndpoint : nullptr;}
	struct dL_Forwarding_GTPtunnelEndpoint_t : GTPtunnelEndpoint
	{
		static constexpr const char* name() {return "dL_Forwarding_GTPtunnelEndpoint_t";}
		using parent_t = GTPtunnelEndpoint;
		static constexpr bool optional = true;

	};
	dL_Forwarding_GTPtunnelEndpoint_t& set_dL_Forwarding_GTPtunnelEndpoint() { dL_Forwarding_GTPtunnelEndpoint.setpresent(true); return dL_Forwarding_GTPtunnelEndpoint;}
	dL_Forwarding_GTPtunnelEndpoint_t const* get_dL_Forwarding_GTPtunnelEndpoint() const {return dL_Forwarding_GTPtunnelEndpoint.is_valid() ? &dL_Forwarding_GTPtunnelEndpoint : nullptr;}
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_ToBeReleased_RelReqItem_SCG_BearerExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_ToBeReleased_RelReqItem_SCG_BearerExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(e_RAB_ID);
		v(uL_Forwarding_GTPtunnelEndpoint);
		v(dL_Forwarding_GTPtunnelEndpoint);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(e_RAB_ID);
		v(uL_Forwarding_GTPtunnelEndpoint);
		v(dL_Forwarding_GTPtunnelEndpoint);
		v(iE_Extensions);

	};
	void clear()
	{
		e_RAB_ID.clear();
		uL_Forwarding_GTPtunnelEndpoint.clear();
		dL_Forwarding_GTPtunnelEndpoint.clear();
		iE_Extensions.clear();

	};
	private:
	e_RAB_ID_t	e_RAB_ID;
	uL_Forwarding_GTPtunnelEndpoint_t	uL_Forwarding_GTPtunnelEndpoint;
	dL_Forwarding_GTPtunnelEndpoint_t	dL_Forwarding_GTPtunnelEndpoint;
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-ToBeReleased-RelReqItem-Split-BearerExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct E_RABs_ToBeReleased_RelReqItem_Split_BearerExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-ToBeReleased-RelReqItem-Split-Bearer ::= SEQUENCE {
	e-RAB-ID						E-RAB-ID,
	dL-Forwarding-GTPtunnelEndpoint			GTPtunnelEndpoint													OPTIONAL,
	iE-Extensions					ProtocolExtensionContainer { {E-RABs-ToBeReleased-RelReqItem-Split-BearerExtIEs} } OPTIONAL,
	...
}
*/

struct E_RABs_ToBeReleased_RelReqItem_Split_Bearer : asn::sequence<3, 0, true, 2>
{
	static constexpr const char* name() {return "E-RABs-ToBeReleased-RelReqItem-Split-Bearer";}
	using parent_t = asn::sequence<3, 0, true, 2>;
	struct e_RAB_ID_t : E_RAB_ID
	{
		static constexpr const char* name() {return "e_RAB_ID_t";}
		using parent_t = E_RAB_ID;

	};
	e_RAB_ID_t& ref_e_RAB_ID() {return e_RAB_ID;}
	e_RAB_ID_t const& ref_e_RAB_ID() const {return e_RAB_ID;}
	struct dL_Forwarding_GTPtunnelEndpoint_t : GTPtunnelEndpoint
	{
		static constexpr const char* name() {return "dL_Forwarding_GTPtunnelEndpoint_t";}
		using parent_t = GTPtunnelEndpoint;
		static constexpr bool optional = true;

	};
	dL_Forwarding_GTPtunnelEndpoint_t& set_dL_Forwarding_GTPtunnelEndpoint() { dL_Forwarding_GTPtunnelEndpoint.setpresent(true); return dL_Forwarding_GTPtunnelEndpoint;}
	dL_Forwarding_GTPtunnelEndpoint_t const* get_dL_Forwarding_GTPtunnelEndpoint() const {return dL_Forwarding_GTPtunnelEndpoint.is_valid() ? &dL_Forwarding_GTPtunnelEndpoint : nullptr;}
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_ToBeReleased_RelReqItem_Split_BearerExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_ToBeReleased_RelReqItem_Split_BearerExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(e_RAB_ID);
		v(dL_Forwarding_GTPtunnelEndpoint);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(e_RAB_ID);
		v(dL_Forwarding_GTPtunnelEndpoint);
		v(iE_Extensions);

	};
	void clear()
	{
		e_RAB_ID.clear();
		dL_Forwarding_GTPtunnelEndpoint.clear();
		iE_Extensions.clear();

	};
	private:
	e_RAB_ID_t	e_RAB_ID;
	dL_Forwarding_GTPtunnelEndpoint_t	dL_Forwarding_GTPtunnelEndpoint;
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-ToBeReleased-RelReqItem ::= CHOICE {
	sCG-Bearer		E-RABs-ToBeReleased-RelReqItem-SCG-Bearer,
	split-Bearer	E-RABs-ToBeReleased-RelReqItem-Split-Bearer,
	...
}
*/

struct E_RABs_ToBeReleased_RelReqItem : asn::choice<2, 0, true>
{
	static constexpr const char* name() {return "E-RABs-ToBeReleased-RelReqItem";}
	using parent_t = asn::choice<2, 0, true>;
	index_type get_index() const {return index;}
	bool is_unknown() const {return index == 3;}
	void set_unknown() { set_index(3);  }
	~E_RABs_ToBeReleased_RelReqItem() {clear();}
	struct sCG_Bearer_t : E_RABs_ToBeReleased_RelReqItem_SCG_Bearer
	{
		static constexpr const char* name() {return "sCG_Bearer_t";}
		using parent_t = E_RABs_ToBeReleased_RelReqItem_SCG_Bearer;

	};
	struct split_Bearer_t : E_RABs_ToBeReleased_RelReqItem_Split_Bearer
	{
		static constexpr const char* name() {return "split_Bearer_t";}
		using parent_t = E_RABs_ToBeReleased_RelReqItem_Split_Bearer;

	};
	void clear()
	{
		switch(get_index())
		{
		case 1: var.destroy<sCG_Bearer_t>(); break;
		case 2: var.destroy<split_Bearer_t>(); break;
		}
		index = 0;
		base::clear();
	}
	template<typename V> bool decode(size_t idx, V& v)
	{
		clear();
		switch(idx)
		{
		case 1: set_index(1); return v(var.build<sCG_Bearer_t>());
		case 2: set_index(2); return v(var.build<split_Bearer_t>());
		}
		return false;

	}
	template<typename V> bool encode(V& v) const
	{
		switch(get_index())
		{
		case 1: return v(var.as<sCG_Bearer_t>());
		case 2: return v(var.as<split_Bearer_t>());
		}
		return false;
	}
	template<typename V> static inline void enumerate(V& v)
	{
		v.template operator()<sCG_Bearer_t>(1);
		v.template operator()<split_Bearer_t>(2);

	}
	sCG_Bearer_t& select_sCG_Bearer() { if(get_index() != 1) { clear(); set_index(1); return var.build<sCG_Bearer_t>();} return var.as<sCG_Bearer_t>();}
	sCG_Bearer_t const* get_sCG_Bearer() const { if(get_index() == 1) { return &var.as<sCG_Bearer_t>();} return nullptr; }
	split_Bearer_t& select_split_Bearer() { if(get_index() != 2) { clear(); set_index(2); return var.build<split_Bearer_t>();} return var.as<split_Bearer_t>();}
	split_Bearer_t const* get_split_Bearer() const { if(get_index() == 2) { return &var.as<split_Bearer_t>();} return nullptr; }
	private:
	void set_index(index_type i) {index = i; base::set();}
	union union_type
	{
		char dummy1[sizeof(sCG_Bearer_t)];
		char dummy2[sizeof(split_Bearer_t)];

	};
	asn::variant<sizeof(union_type)>	var;
	index_type	index {0};
};
/*
E-RABs-ToBeReleased-RelReqItemIEs X2AP-PROTOCOL-IES ::= {
	{ ID id-E-RABs-ToBeReleased-RelReqItem		CRITICALITY ignore	TYPE E-RABs-ToBeReleased-RelReqItem		PRESENCE mandatory},
	...
}
*/

struct E_RABs_ToBeReleased_RelReqItemIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_ToBeReleased_RelReqItem() { set(id_E_RABs_ToBeReleased_RelReqItem); type=1;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_E_RABs_ToBeReleased_RelReqItem)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_E_RABs_ToBeReleased_RelReqItem);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_ToBeReleased_RelReqItem() { set(ignore); type=1;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		E_RABs_ToBeReleased_RelReqItem& select_id_E_RABs_ToBeReleased_RelReqItem() { return set<E_RABs_ToBeReleased_RelReqItem>(1); }
		E_RABs_ToBeReleased_RelReqItem const* get_id_E_RABs_ToBeReleased_RelReqItem() const { return get<E_RABs_ToBeReleased_RelReqItem>(1); }
		bool is_unknown() const { return type == 2; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<E_RABs_ToBeReleased_RelReqItem>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<E_RABs_ToBeReleased_RelReqItem>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_E_RABs_ToBeReleased_RelReqItem()); return true;
			case 2: if(type != 2) {clear(); asn::base::set();} type = 2; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<E_RABs_ToBeReleased_RelReqItem>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(E_RABs_ToBeReleased_RelReqItem)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_ToBeReleased_RelReqItem() { set(mandatory); type=1;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-ToBeReleased-List-RelReq ::= SEQUENCE (SIZE(1..maxnoofBearers)) OF ProtocolIE-Single-Container { {E-RABs-ToBeReleased-RelReqItemIEs} }
*/

struct E_RABs_ToBeReleased_List_RelReq_elm : ProtocolIE_Single_Container<E_RABs_ToBeReleased_RelReqItemIEs>
{
	static constexpr const char* name() {return "E_RABs_ToBeReleased_List_RelReq_elm";}
	using parent_t = ProtocolIE_Single_Container<E_RABs_ToBeReleased_RelReqItemIEs>;

};
struct E_RABs_ToBeReleased_List_RelReq : asn::sequenceof<E_RABs_ToBeReleased_List_RelReq_elm>
{
	static constexpr const char* name() {return "E-RABs-ToBeReleased-List-RelReq";}
	using parent_t = asn::sequenceof<E_RABs_ToBeReleased_List_RelReq_elm>;
	using constraint_t = asn::constraints<false,asn::span<1,  maxnoofBearers >>;

};
/*
E-RABs-ToBeReleased-ModReqdItemExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct E_RABs_ToBeReleased_ModReqdItemExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-ToBeReleased-ModReqdItem ::= SEQUENCE {
	e-RAB-ID						E-RAB-ID,
	cause							Cause,
	iE-Extensions					ProtocolExtensionContainer { {E-RABs-ToBeReleased-ModReqdItemExtIEs} } OPTIONAL,
	...
}
*/

struct E_RABs_ToBeReleased_ModReqdItem : asn::sequence<3, 0, true, 1>
{
	static constexpr const char* name() {return "E-RABs-ToBeReleased-ModReqdItem";}
	using parent_t = asn::sequence<3, 0, true, 1>;
	struct e_RAB_ID_t : E_RAB_ID
	{
		static constexpr const char* name() {return "e_RAB_ID_t";}
		using parent_t = E_RAB_ID;

	};
	e_RAB_ID_t& ref_e_RAB_ID() {return e_RAB_ID;}
	e_RAB_ID_t const& ref_e_RAB_ID() const {return e_RAB_ID;}
	struct cause_t : Cause
	{
		static constexpr const char* name() {return "cause_t";}
		using parent_t = Cause;

	};
	cause_t& ref_cause() {return cause;}
	cause_t const& ref_cause() const {return cause;}
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_ToBeReleased_ModReqdItemExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_ToBeReleased_ModReqdItemExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(e_RAB_ID);
		v(cause);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(e_RAB_ID);
		v(cause);
		v(iE_Extensions);

	};
	void clear()
	{
		e_RAB_ID.clear();
		cause.clear();
		iE_Extensions.clear();

	};
	private:
	e_RAB_ID_t	e_RAB_ID;
	cause_t	cause;
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-ToBeReleased-ModReqdItemIEs X2AP-PROTOCOL-IES ::= {
	{ ID id-E-RABs-ToBeReleased-ModReqdItem	 CRITICALITY ignore		TYPE E-RABs-ToBeReleased-ModReqdItem	PRESENCE mandatory },
	...
}
*/

struct E_RABs_ToBeReleased_ModReqdItemIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_ToBeReleased_ModReqdItem() { set(id_E_RABs_ToBeReleased_ModReqdItem); type=1;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_E_RABs_ToBeReleased_ModReqdItem)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_E_RABs_ToBeReleased_ModReqdItem);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_ToBeReleased_ModReqdItem() { set(ignore); type=1;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		E_RABs_ToBeReleased_ModReqdItem& select_id_E_RABs_ToBeReleased_ModReqdItem() { return set<E_RABs_ToBeReleased_ModReqdItem>(1); }
		E_RABs_ToBeReleased_ModReqdItem const* get_id_E_RABs_ToBeReleased_ModReqdItem() const { return get<E_RABs_ToBeReleased_ModReqdItem>(1); }
		bool is_unknown() const { return type == 2; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<E_RABs_ToBeReleased_ModReqdItem>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<E_RABs_ToBeReleased_ModReqdItem>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_E_RABs_ToBeReleased_ModReqdItem()); return true;
			case 2: if(type != 2) {clear(); asn::base::set();} type = 2; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<E_RABs_ToBeReleased_ModReqdItem>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(E_RABs_ToBeReleased_ModReqdItem)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_ToBeReleased_ModReqdItem() { set(mandatory); type=1;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-ToBeReleased-ModReqd ::= SEQUENCE (SIZE (1..maxnoofBearers)) OF ProtocolIE-Single-Container { {E-RABs-ToBeReleased-ModReqdItemIEs} }
*/

struct E_RABs_ToBeReleased_ModReqd_elm : ProtocolIE_Single_Container<E_RABs_ToBeReleased_ModReqdItemIEs>
{
	static constexpr const char* name() {return "E_RABs_ToBeReleased_ModReqd_elm";}
	using parent_t = ProtocolIE_Single_Container<E_RABs_ToBeReleased_ModReqdItemIEs>;

};
struct E_RABs_ToBeReleased_ModReqd : asn::sequenceof<E_RABs_ToBeReleased_ModReqd_elm>
{
	static constexpr const char* name() {return "E-RABs-ToBeReleased-ModReqd";}
	using parent_t = asn::sequenceof<E_RABs_ToBeReleased_ModReqd_elm>;
	using constraint_t = asn::constraints<false,asn::span<1,  maxnoofBearers >>;

};
/*
E-RABs-ToBeReleased-SgNBChaConf-Item-SgNBPDCPpresentExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct E_RABs_ToBeReleased_SgNBChaConf_Item_SgNBPDCPpresentExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-ToBeReleased-SgNBChaConf-Item-SgNBPDCPpresent ::= SEQUENCE {
	uL-GTPtunnelEndpoint			GTPtunnelEndpoint																				OPTIONAL,
	dL-GTPtunnelEndpoint			GTPtunnelEndpoint																				OPTIONAL,
	iE-Extensions					ProtocolExtensionContainer { {E-RABs-ToBeReleased-SgNBChaConf-Item-SgNBPDCPpresentExtIEs} } OPTIONAL,
	...
}
*/

struct E_RABs_ToBeReleased_SgNBChaConf_Item_SgNBPDCPpresent : asn::sequence<3, 0, true, 3>
{
	static constexpr const char* name() {return "E-RABs-ToBeReleased-SgNBChaConf-Item-SgNBPDCPpresent";}
	using parent_t = asn::sequence<3, 0, true, 3>;
	struct uL_GTPtunnelEndpoint_t : GTPtunnelEndpoint
	{
		static constexpr const char* name() {return "uL_GTPtunnelEndpoint_t";}
		using parent_t = GTPtunnelEndpoint;
		static constexpr bool optional = true;

	};
	uL_GTPtunnelEndpoint_t& set_uL_GTPtunnelEndpoint() { uL_GTPtunnelEndpoint.setpresent(true); return uL_GTPtunnelEndpoint;}
	uL_GTPtunnelEndpoint_t const* get_uL_GTPtunnelEndpoint() const {return uL_GTPtunnelEndpoint.is_valid() ? &uL_GTPtunnelEndpoint : nullptr;}
	struct dL_GTPtunnelEndpoint_t : GTPtunnelEndpoint
	{
		static constexpr const char* name() {return "dL_GTPtunnelEndpoint_t";}
		using parent_t = GTPtunnelEndpoint;
		static constexpr bool optional = true;

	};
	dL_GTPtunnelEndpoint_t& set_dL_GTPtunnelEndpoint() { dL_GTPtunnelEndpoint.setpresent(true); return dL_GTPtunnelEndpoint;}
	dL_GTPtunnelEndpoint_t const* get_dL_GTPtunnelEndpoint() const {return dL_GTPtunnelEndpoint.is_valid() ? &dL_GTPtunnelEndpoint : nullptr;}
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_ToBeReleased_SgNBChaConf_Item_SgNBPDCPpresentExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_ToBeReleased_SgNBChaConf_Item_SgNBPDCPpresentExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(uL_GTPtunnelEndpoint);
		v(dL_GTPtunnelEndpoint);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(uL_GTPtunnelEndpoint);
		v(dL_GTPtunnelEndpoint);
		v(iE_Extensions);

	};
	void clear()
	{
		uL_GTPtunnelEndpoint.clear();
		dL_GTPtunnelEndpoint.clear();
		iE_Extensions.clear();

	};
	private:
	uL_GTPtunnelEndpoint_t	uL_GTPtunnelEndpoint;
	dL_GTPtunnelEndpoint_t	dL_GTPtunnelEndpoint;
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-ToBeReleased-SgNBChaConf-Item-SgNBPDCPnotpresentExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct E_RABs_ToBeReleased_SgNBChaConf_Item_SgNBPDCPnotpresentExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-ToBeReleased-SgNBChaConf-Item-SgNBPDCPnotpresent ::= SEQUENCE {
	iE-Extensions					ProtocolExtensionContainer { {E-RABs-ToBeReleased-SgNBChaConf-Item-SgNBPDCPnotpresentExtIEs} } 	OPTIONAL,
	...
}
*/

struct E_RABs_ToBeReleased_SgNBChaConf_Item_SgNBPDCPnotpresent : asn::sequence<1, 0, true, 1>
{
	static constexpr const char* name() {return "E-RABs-ToBeReleased-SgNBChaConf-Item-SgNBPDCPnotpresent";}
	using parent_t = asn::sequence<1, 0, true, 1>;
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_ToBeReleased_SgNBChaConf_Item_SgNBPDCPnotpresentExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_ToBeReleased_SgNBChaConf_Item_SgNBPDCPnotpresentExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(iE_Extensions);

	};
	void clear()
	{
		iE_Extensions.clear();

	};
	private:
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-ToBeReleased-SgNBChaConf-ItemExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct E_RABs_ToBeReleased_SgNBChaConf_ItemExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-ToBeReleased-SgNBChaConf-Item ::= SEQUENCE {
	e-RAB-ID							E-RAB-ID,
	en-DC-ResourceConfiguration			EN-DC-ResourceConfiguration,
	resource-configuration				CHOICE {
		sgNBPDCPpresent						E-RABs-ToBeReleased-SgNBChaConf-Item-SgNBPDCPpresent,
		sgNBPDCPnotpresent					E-RABs-ToBeReleased-SgNBChaConf-Item-SgNBPDCPnotpresent,
		...
	},
	iE-Extensions					ProtocolExtensionContainer { {E-RABs-ToBeReleased-SgNBChaConf-ItemExtIEs} }	OPTIONAL,
	...
}
*/

struct E_RABs_ToBeReleased_SgNBChaConf_Item : asn::sequence<4, 0, true, 1>
{
	static constexpr const char* name() {return "E-RABs-ToBeReleased-SgNBChaConf-Item";}
	using parent_t = asn::sequence<4, 0, true, 1>;
	struct e_RAB_ID_t : E_RAB_ID
	{
		static constexpr const char* name() {return "e_RAB_ID_t";}
		using parent_t = E_RAB_ID;

	};
	e_RAB_ID_t& ref_e_RAB_ID() {return e_RAB_ID;}
	e_RAB_ID_t const& ref_e_RAB_ID() const {return e_RAB_ID;}
	struct en_DC_ResourceConfiguration_t : EN_DC_ResourceConfiguration
	{
		static constexpr const char* name() {return "en_DC_ResourceConfiguration_t";}
		using parent_t = EN_DC_ResourceConfiguration;

	};
	en_DC_ResourceConfiguration_t& ref_en_DC_ResourceConfiguration() {return en_DC_ResourceConfiguration;}
	en_DC_ResourceConfiguration_t const& ref_en_DC_ResourceConfiguration() const {return en_DC_ResourceConfiguration;}
	struct resource_configuration_t : asn::choice<2, 0, true>
	{
		static constexpr const char* name() {return "resource_configuration_t";}
		using parent_t = asn::choice<2, 0, true>;
		index_type get_index() const {return index;}
		bool is_unknown() const {return index == 3;}
		void set_unknown() { set_index(3);  }
		~resource_configuration_t() {clear();}
		struct sgNBPDCPpresent_t : E_RABs_ToBeReleased_SgNBChaConf_Item_SgNBPDCPpresent
		{
			static constexpr const char* name() {return "sgNBPDCPpresent_t";}
			using parent_t = E_RABs_ToBeReleased_SgNBChaConf_Item_SgNBPDCPpresent;

		};
		struct sgNBPDCPnotpresent_t : E_RABs_ToBeReleased_SgNBChaConf_Item_SgNBPDCPnotpresent
		{
			static constexpr const char* name() {return "sgNBPDCPnotpresent_t";}
			using parent_t = E_RABs_ToBeReleased_SgNBChaConf_Item_SgNBPDCPnotpresent;

		};
		void clear()
		{
			switch(get_index())
			{
			case 1: var.destroy<sgNBPDCPpresent_t>(); break;
			case 2: var.destroy<sgNBPDCPnotpresent_t>(); break;
			}
			index = 0;
			base::clear();
		}
		template<typename V> bool decode(size_t idx, V& v)
		{
			clear();
			switch(idx)
			{
			case 1: set_index(1); return v(var.build<sgNBPDCPpresent_t>());
			case 2: set_index(2); return v(var.build<sgNBPDCPnotpresent_t>());
			}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			switch(get_index())
			{
			case 1: return v(var.as<sgNBPDCPpresent_t>());
			case 2: return v(var.as<sgNBPDCPnotpresent_t>());
			}
			return false;
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<sgNBPDCPpresent_t>(1);
			v.template operator()<sgNBPDCPnotpresent_t>(2);

		}
		sgNBPDCPpresent_t& select_sgNBPDCPpresent() { if(get_index() != 1) { clear(); set_index(1); return var.build<sgNBPDCPpresent_t>();} return var.as<sgNBPDCPpresent_t>();}
		sgNBPDCPpresent_t const* get_sgNBPDCPpresent() const { if(get_index() == 1) { return &var.as<sgNBPDCPpresent_t>();} return nullptr; }
		sgNBPDCPnotpresent_t& select_sgNBPDCPnotpresent() { if(get_index() != 2) { clear(); set_index(2); return var.build<sgNBPDCPnotpresent_t>();} return var.as<sgNBPDCPnotpresent_t>();}
		sgNBPDCPnotpresent_t const* get_sgNBPDCPnotpresent() const { if(get_index() == 2) { return &var.as<sgNBPDCPnotpresent_t>();} return nullptr; }
		private:
		void set_index(index_type i) {index = i; base::set();}
		union union_type
		{
			char dummy1[sizeof(sgNBPDCPpresent_t)];
			char dummy2[sizeof(sgNBPDCPnotpresent_t)];

		};
		asn::variant<sizeof(union_type)>	var;
		index_type	index {0};
	};
	resource_configuration_t& ref_resource_configuration() {return resource_configuration;}
	resource_configuration_t const& ref_resource_configuration() const {return resource_configuration;}
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_ToBeReleased_SgNBChaConf_ItemExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_ToBeReleased_SgNBChaConf_ItemExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(e_RAB_ID);
		v(en_DC_ResourceConfiguration);
		v(resource_configuration);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(e_RAB_ID);
		v(en_DC_ResourceConfiguration);
		v(resource_configuration);
		v(iE_Extensions);

	};
	void clear()
	{
		e_RAB_ID.clear();
		en_DC_ResourceConfiguration.clear();
		resource_configuration.clear();
		iE_Extensions.clear();

	};
	private:
	e_RAB_ID_t	e_RAB_ID;
	en_DC_ResourceConfiguration_t	en_DC_ResourceConfiguration;
	resource_configuration_t	resource_configuration;
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-ToBeReleased-SgNBChaConf-ItemIEs X2AP-PROTOCOL-IES ::= {
	{ ID id-E-RABs-ToBeReleased-SgNBChaConf-Item		CRITICALITY ignore		TYPE E-RABs-ToBeReleased-SgNBChaConf-Item		PRESENCE mandatory},
	...
}
*/

struct E_RABs_ToBeReleased_SgNBChaConf_ItemIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_ToBeReleased_SgNBChaConf_Item() { set(id_E_RABs_ToBeReleased_SgNBChaConf_Item); type=1;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_E_RABs_ToBeReleased_SgNBChaConf_Item)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_E_RABs_ToBeReleased_SgNBChaConf_Item);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_ToBeReleased_SgNBChaConf_Item() { set(ignore); type=1;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		E_RABs_ToBeReleased_SgNBChaConf_Item& select_id_E_RABs_ToBeReleased_SgNBChaConf_Item() { return set<E_RABs_ToBeReleased_SgNBChaConf_Item>(1); }
		E_RABs_ToBeReleased_SgNBChaConf_Item const* get_id_E_RABs_ToBeReleased_SgNBChaConf_Item() const { return get<E_RABs_ToBeReleased_SgNBChaConf_Item>(1); }
		bool is_unknown() const { return type == 2; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<E_RABs_ToBeReleased_SgNBChaConf_Item>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<E_RABs_ToBeReleased_SgNBChaConf_Item>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_E_RABs_ToBeReleased_SgNBChaConf_Item()); return true;
			case 2: if(type != 2) {clear(); asn::base::set();} type = 2; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<E_RABs_ToBeReleased_SgNBChaConf_Item>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(E_RABs_ToBeReleased_SgNBChaConf_Item)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_ToBeReleased_SgNBChaConf_Item() { set(mandatory); type=1;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-ToBeReleased-SgNBChaConfList ::= SEQUENCE (SIZE(1..maxnoofBearers)) OF ProtocolIE-Single-Container { {E-RABs-ToBeReleased-SgNBChaConf-ItemIEs} }
*/

struct E_RABs_ToBeReleased_SgNBChaConfList_elm : ProtocolIE_Single_Container<E_RABs_ToBeReleased_SgNBChaConf_ItemIEs>
{
	static constexpr const char* name() {return "E_RABs_ToBeReleased_SgNBChaConfList_elm";}
	using parent_t = ProtocolIE_Single_Container<E_RABs_ToBeReleased_SgNBChaConf_ItemIEs>;

};
struct E_RABs_ToBeReleased_SgNBChaConfList : asn::sequenceof<E_RABs_ToBeReleased_SgNBChaConfList_elm>
{
	static constexpr const char* name() {return "E-RABs-ToBeReleased-SgNBChaConfList";}
	using parent_t = asn::sequenceof<E_RABs_ToBeReleased_SgNBChaConfList_elm>;
	using constraint_t = asn::constraints<false,asn::span<1,  maxnoofBearers >>;

};
/*
E-RABs-ToBeReleased-SgNBModReq-Item-SgNBPDCPpresentExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct E_RABs_ToBeReleased_SgNBModReq_Item_SgNBPDCPpresentExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-ToBeReleased-SgNBModReq-Item-SgNBPDCPpresent ::= SEQUENCE {
	dL-GTPtunnelEndpoint			GTPtunnelEndpoint																				OPTIONAL,
	uL-GTPtunnelEndpoint			GTPtunnelEndpoint																				OPTIONAL,
	iE-Extensions					ProtocolExtensionContainer { {E-RABs-ToBeReleased-SgNBModReq-Item-SgNBPDCPpresentExtIEs} } 	OPTIONAL,
	...
}
*/

struct E_RABs_ToBeReleased_SgNBModReq_Item_SgNBPDCPpresent : asn::sequence<3, 0, true, 3>
{
	static constexpr const char* name() {return "E-RABs-ToBeReleased-SgNBModReq-Item-SgNBPDCPpresent";}
	using parent_t = asn::sequence<3, 0, true, 3>;
	struct dL_GTPtunnelEndpoint_t : GTPtunnelEndpoint
	{
		static constexpr const char* name() {return "dL_GTPtunnelEndpoint_t";}
		using parent_t = GTPtunnelEndpoint;
		static constexpr bool optional = true;

	};
	dL_GTPtunnelEndpoint_t& set_dL_GTPtunnelEndpoint() { dL_GTPtunnelEndpoint.setpresent(true); return dL_GTPtunnelEndpoint;}
	dL_GTPtunnelEndpoint_t const* get_dL_GTPtunnelEndpoint() const {return dL_GTPtunnelEndpoint.is_valid() ? &dL_GTPtunnelEndpoint : nullptr;}
	struct uL_GTPtunnelEndpoint_t : GTPtunnelEndpoint
	{
		static constexpr const char* name() {return "uL_GTPtunnelEndpoint_t";}
		using parent_t = GTPtunnelEndpoint;
		static constexpr bool optional = true;

	};
	uL_GTPtunnelEndpoint_t& set_uL_GTPtunnelEndpoint() { uL_GTPtunnelEndpoint.setpresent(true); return uL_GTPtunnelEndpoint;}
	uL_GTPtunnelEndpoint_t const* get_uL_GTPtunnelEndpoint() const {return uL_GTPtunnelEndpoint.is_valid() ? &uL_GTPtunnelEndpoint : nullptr;}
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_ToBeReleased_SgNBModReq_Item_SgNBPDCPpresentExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_ToBeReleased_SgNBModReq_Item_SgNBPDCPpresentExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(dL_GTPtunnelEndpoint);
		v(uL_GTPtunnelEndpoint);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(dL_GTPtunnelEndpoint);
		v(uL_GTPtunnelEndpoint);
		v(iE_Extensions);

	};
	void clear()
	{
		dL_GTPtunnelEndpoint.clear();
		uL_GTPtunnelEndpoint.clear();
		iE_Extensions.clear();

	};
	private:
	dL_GTPtunnelEndpoint_t	dL_GTPtunnelEndpoint;
	uL_GTPtunnelEndpoint_t	uL_GTPtunnelEndpoint;
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-ToBeReleased-SgNBModReq-Item-SgNBPDCPnotpresentExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct E_RABs_ToBeReleased_SgNBModReq_Item_SgNBPDCPnotpresentExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-ToBeReleased-SgNBModReq-Item-SgNBPDCPnotpresent ::= SEQUENCE {
	iE-Extensions					ProtocolExtensionContainer { {E-RABs-ToBeReleased-SgNBModReq-Item-SgNBPDCPnotpresentExtIEs} } 	OPTIONAL,
	...
}
*/

struct E_RABs_ToBeReleased_SgNBModReq_Item_SgNBPDCPnotpresent : asn::sequence<1, 0, true, 1>
{
	static constexpr const char* name() {return "E-RABs-ToBeReleased-SgNBModReq-Item-SgNBPDCPnotpresent";}
	using parent_t = asn::sequence<1, 0, true, 1>;
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_ToBeReleased_SgNBModReq_Item_SgNBPDCPnotpresentExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_ToBeReleased_SgNBModReq_Item_SgNBPDCPnotpresentExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(iE_Extensions);

	};
	void clear()
	{
		iE_Extensions.clear();

	};
	private:
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-ToBeReleased-SgNBModReq-ItemExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct E_RABs_ToBeReleased_SgNBModReq_ItemExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-ToBeReleased-SgNBModReq-Item ::= SEQUENCE {
	e-RAB-ID								E-RAB-ID,
	en-DC-ResourceConfiguration			EN-DC-ResourceConfiguration,
	resource-configuration				CHOICE {
		sgNBPDCPpresent						E-RABs-ToBeReleased-SgNBModReq-Item-SgNBPDCPpresent,
		sgNBPDCPnotpresent					E-RABs-ToBeReleased-SgNBModReq-Item-SgNBPDCPnotpresent,
		...
	},
	iE-Extensions					ProtocolExtensionContainer { {E-RABs-ToBeReleased-SgNBModReq-ItemExtIEs} }	OPTIONAL,
	...
}
*/

struct E_RABs_ToBeReleased_SgNBModReq_Item : asn::sequence<4, 0, true, 1>
{
	static constexpr const char* name() {return "E-RABs-ToBeReleased-SgNBModReq-Item";}
	using parent_t = asn::sequence<4, 0, true, 1>;
	struct e_RAB_ID_t : E_RAB_ID
	{
		static constexpr const char* name() {return "e_RAB_ID_t";}
		using parent_t = E_RAB_ID;

	};
	e_RAB_ID_t& ref_e_RAB_ID() {return e_RAB_ID;}
	e_RAB_ID_t const& ref_e_RAB_ID() const {return e_RAB_ID;}
	struct en_DC_ResourceConfiguration_t : EN_DC_ResourceConfiguration
	{
		static constexpr const char* name() {return "en_DC_ResourceConfiguration_t";}
		using parent_t = EN_DC_ResourceConfiguration;

	};
	en_DC_ResourceConfiguration_t& ref_en_DC_ResourceConfiguration() {return en_DC_ResourceConfiguration;}
	en_DC_ResourceConfiguration_t const& ref_en_DC_ResourceConfiguration() const {return en_DC_ResourceConfiguration;}
	struct resource_configuration_t : asn::choice<2, 0, true>
	{
		static constexpr const char* name() {return "resource_configuration_t";}
		using parent_t = asn::choice<2, 0, true>;
		index_type get_index() const {return index;}
		bool is_unknown() const {return index == 3;}
		void set_unknown() { set_index(3);  }
		~resource_configuration_t() {clear();}
		struct sgNBPDCPpresent_t : E_RABs_ToBeReleased_SgNBModReq_Item_SgNBPDCPpresent
		{
			static constexpr const char* name() {return "sgNBPDCPpresent_t";}
			using parent_t = E_RABs_ToBeReleased_SgNBModReq_Item_SgNBPDCPpresent;

		};
		struct sgNBPDCPnotpresent_t : E_RABs_ToBeReleased_SgNBModReq_Item_SgNBPDCPnotpresent
		{
			static constexpr const char* name() {return "sgNBPDCPnotpresent_t";}
			using parent_t = E_RABs_ToBeReleased_SgNBModReq_Item_SgNBPDCPnotpresent;

		};
		void clear()
		{
			switch(get_index())
			{
			case 1: var.destroy<sgNBPDCPpresent_t>(); break;
			case 2: var.destroy<sgNBPDCPnotpresent_t>(); break;
			}
			index = 0;
			base::clear();
		}
		template<typename V> bool decode(size_t idx, V& v)
		{
			clear();
			switch(idx)
			{
			case 1: set_index(1); return v(var.build<sgNBPDCPpresent_t>());
			case 2: set_index(2); return v(var.build<sgNBPDCPnotpresent_t>());
			}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			switch(get_index())
			{
			case 1: return v(var.as<sgNBPDCPpresent_t>());
			case 2: return v(var.as<sgNBPDCPnotpresent_t>());
			}
			return false;
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<sgNBPDCPpresent_t>(1);
			v.template operator()<sgNBPDCPnotpresent_t>(2);

		}
		sgNBPDCPpresent_t& select_sgNBPDCPpresent() { if(get_index() != 1) { clear(); set_index(1); return var.build<sgNBPDCPpresent_t>();} return var.as<sgNBPDCPpresent_t>();}
		sgNBPDCPpresent_t const* get_sgNBPDCPpresent() const { if(get_index() == 1) { return &var.as<sgNBPDCPpresent_t>();} return nullptr; }
		sgNBPDCPnotpresent_t& select_sgNBPDCPnotpresent() { if(get_index() != 2) { clear(); set_index(2); return var.build<sgNBPDCPnotpresent_t>();} return var.as<sgNBPDCPnotpresent_t>();}
		sgNBPDCPnotpresent_t const* get_sgNBPDCPnotpresent() const { if(get_index() == 2) { return &var.as<sgNBPDCPnotpresent_t>();} return nullptr; }
		private:
		void set_index(index_type i) {index = i; base::set();}
		union union_type
		{
			char dummy1[sizeof(sgNBPDCPpresent_t)];
			char dummy2[sizeof(sgNBPDCPnotpresent_t)];

		};
		asn::variant<sizeof(union_type)>	var;
		index_type	index {0};
	};
	resource_configuration_t& ref_resource_configuration() {return resource_configuration;}
	resource_configuration_t const& ref_resource_configuration() const {return resource_configuration;}
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_ToBeReleased_SgNBModReq_ItemExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_ToBeReleased_SgNBModReq_ItemExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(e_RAB_ID);
		v(en_DC_ResourceConfiguration);
		v(resource_configuration);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(e_RAB_ID);
		v(en_DC_ResourceConfiguration);
		v(resource_configuration);
		v(iE_Extensions);

	};
	void clear()
	{
		e_RAB_ID.clear();
		en_DC_ResourceConfiguration.clear();
		resource_configuration.clear();
		iE_Extensions.clear();

	};
	private:
	e_RAB_ID_t	e_RAB_ID;
	en_DC_ResourceConfiguration_t	en_DC_ResourceConfiguration;
	resource_configuration_t	resource_configuration;
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-ToBeReleased-SgNBModReq-ItemIEs X2AP-PROTOCOL-IES ::= {
	{ ID id-E-RABs-ToBeReleased-SgNBModReq-Item	CRITICALITY ignore	TYPE E-RABs-ToBeReleased-SgNBModReq-Item		PRESENCE mandatory},
	...
}
*/

struct E_RABs_ToBeReleased_SgNBModReq_ItemIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_ToBeReleased_SgNBModReq_Item() { set(id_E_RABs_ToBeReleased_SgNBModReq_Item); type=1;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_E_RABs_ToBeReleased_SgNBModReq_Item)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_E_RABs_ToBeReleased_SgNBModReq_Item);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_ToBeReleased_SgNBModReq_Item() { set(ignore); type=1;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		E_RABs_ToBeReleased_SgNBModReq_Item& select_id_E_RABs_ToBeReleased_SgNBModReq_Item() { return set<E_RABs_ToBeReleased_SgNBModReq_Item>(1); }
		E_RABs_ToBeReleased_SgNBModReq_Item const* get_id_E_RABs_ToBeReleased_SgNBModReq_Item() const { return get<E_RABs_ToBeReleased_SgNBModReq_Item>(1); }
		bool is_unknown() const { return type == 2; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<E_RABs_ToBeReleased_SgNBModReq_Item>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<E_RABs_ToBeReleased_SgNBModReq_Item>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_E_RABs_ToBeReleased_SgNBModReq_Item()); return true;
			case 2: if(type != 2) {clear(); asn::base::set();} type = 2; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<E_RABs_ToBeReleased_SgNBModReq_Item>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(E_RABs_ToBeReleased_SgNBModReq_Item)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_ToBeReleased_SgNBModReq_Item() { set(mandatory); type=1;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-ToBeReleased-SgNBModReq-List ::= SEQUENCE (SIZE(1..maxnoofBearers)) OF ProtocolIE-Single-Container { {E-RABs-ToBeReleased-SgNBModReq-ItemIEs} }
*/

struct E_RABs_ToBeReleased_SgNBModReq_List_elm : ProtocolIE_Single_Container<E_RABs_ToBeReleased_SgNBModReq_ItemIEs>
{
	static constexpr const char* name() {return "E_RABs_ToBeReleased_SgNBModReq_List_elm";}
	using parent_t = ProtocolIE_Single_Container<E_RABs_ToBeReleased_SgNBModReq_ItemIEs>;

};
struct E_RABs_ToBeReleased_SgNBModReq_List : asn::sequenceof<E_RABs_ToBeReleased_SgNBModReq_List_elm>
{
	static constexpr const char* name() {return "E-RABs-ToBeReleased-SgNBModReq-List";}
	using parent_t = asn::sequenceof<E_RABs_ToBeReleased_SgNBModReq_List_elm>;
	using constraint_t = asn::constraints<false,asn::span<1,  maxnoofBearers >>;

};
/*
E-RABs-ToBeReleased-SgNBModReqd-ItemExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	{ ID id-RLCMode-transferred					CRITICALITY ignore	EXTENSION RLCMode					PRESENCE optional},
	...
}
*/

struct E_RABs_ToBeReleased_SgNBModReqd_ItemExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_RLCMode_transferred() { set(id_RLCMode_transferred); type=1;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_RLCMode_transferred)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_RLCMode_transferred);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_RLCMode_transferred() { set(ignore); type=1;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		RLCMode& select_id_RLCMode_transferred() { return set<RLCMode>(1); }
		RLCMode const* get_id_RLCMode_transferred() const { return get<RLCMode>(1); }
		bool is_unknown() const { return type == 2; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<RLCMode>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<RLCMode>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_RLCMode_transferred()); return true;
			case 2: if(type != 2) {clear(); asn::base::set();} type = 2; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<RLCMode>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(RLCMode)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_RLCMode_transferred() { set(optional); type=1;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(optional)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(optional);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-ToBeReleased-SgNBModReqd-Item ::= SEQUENCE {
	e-RAB-ID							E-RAB-ID,
	cause							Cause,
	iE-Extensions					ProtocolExtensionContainer { {E-RABs-ToBeReleased-SgNBModReqd-ItemExtIEs} } OPTIONAL,
	...
}
*/

struct E_RABs_ToBeReleased_SgNBModReqd_Item : asn::sequence<3, 0, true, 1>
{
	static constexpr const char* name() {return "E-RABs-ToBeReleased-SgNBModReqd-Item";}
	using parent_t = asn::sequence<3, 0, true, 1>;
	struct e_RAB_ID_t : E_RAB_ID
	{
		static constexpr const char* name() {return "e_RAB_ID_t";}
		using parent_t = E_RAB_ID;

	};
	e_RAB_ID_t& ref_e_RAB_ID() {return e_RAB_ID;}
	e_RAB_ID_t const& ref_e_RAB_ID() const {return e_RAB_ID;}
	struct cause_t : Cause
	{
		static constexpr const char* name() {return "cause_t";}
		using parent_t = Cause;

	};
	cause_t& ref_cause() {return cause;}
	cause_t const& ref_cause() const {return cause;}
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_ToBeReleased_SgNBModReqd_ItemExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_ToBeReleased_SgNBModReqd_ItemExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(e_RAB_ID);
		v(cause);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(e_RAB_ID);
		v(cause);
		v(iE_Extensions);

	};
	void clear()
	{
		e_RAB_ID.clear();
		cause.clear();
		iE_Extensions.clear();

	};
	private:
	e_RAB_ID_t	e_RAB_ID;
	cause_t	cause;
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-ToBeReleased-SgNBModReqd-ItemIEs X2AP-PROTOCOL-IES ::= {
	{ ID id-E-RABs-ToBeReleased-SgNBModReqd-Item	 CRITICALITY ignore		TYPE E-RABs-ToBeReleased-SgNBModReqd-Item		PRESENCE mandatory },
	...
}
*/

struct E_RABs_ToBeReleased_SgNBModReqd_ItemIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_ToBeReleased_SgNBModReqd_Item() { set(id_E_RABs_ToBeReleased_SgNBModReqd_Item); type=1;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_E_RABs_ToBeReleased_SgNBModReqd_Item)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_E_RABs_ToBeReleased_SgNBModReqd_Item);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_ToBeReleased_SgNBModReqd_Item() { set(ignore); type=1;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		E_RABs_ToBeReleased_SgNBModReqd_Item& select_id_E_RABs_ToBeReleased_SgNBModReqd_Item() { return set<E_RABs_ToBeReleased_SgNBModReqd_Item>(1); }
		E_RABs_ToBeReleased_SgNBModReqd_Item const* get_id_E_RABs_ToBeReleased_SgNBModReqd_Item() const { return get<E_RABs_ToBeReleased_SgNBModReqd_Item>(1); }
		bool is_unknown() const { return type == 2; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<E_RABs_ToBeReleased_SgNBModReqd_Item>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<E_RABs_ToBeReleased_SgNBModReqd_Item>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_E_RABs_ToBeReleased_SgNBModReqd_Item()); return true;
			case 2: if(type != 2) {clear(); asn::base::set();} type = 2; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<E_RABs_ToBeReleased_SgNBModReqd_Item>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(E_RABs_ToBeReleased_SgNBModReqd_Item)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_ToBeReleased_SgNBModReqd_Item() { set(mandatory); type=1;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-ToBeReleased-SgNBModReqdList ::= SEQUENCE (SIZE (1..maxnoofBearers)) OF ProtocolIE-Single-Container { {E-RABs-ToBeReleased-SgNBModReqd-ItemIEs} }
*/

struct E_RABs_ToBeReleased_SgNBModReqdList_elm : ProtocolIE_Single_Container<E_RABs_ToBeReleased_SgNBModReqd_ItemIEs>
{
	static constexpr const char* name() {return "E_RABs_ToBeReleased_SgNBModReqdList_elm";}
	using parent_t = ProtocolIE_Single_Container<E_RABs_ToBeReleased_SgNBModReqd_ItemIEs>;

};
struct E_RABs_ToBeReleased_SgNBModReqdList : asn::sequenceof<E_RABs_ToBeReleased_SgNBModReqdList_elm>
{
	static constexpr const char* name() {return "E-RABs-ToBeReleased-SgNBModReqdList";}
	using parent_t = asn::sequenceof<E_RABs_ToBeReleased_SgNBModReqdList_elm>;
	using constraint_t = asn::constraints<false,asn::span<1,  maxnoofBearers >>;

};
/*
E-RABs-ToBeReleased-SgNBRelConf-Item-SgNBPDCPpresentExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct E_RABs_ToBeReleased_SgNBRelConf_Item_SgNBPDCPpresentExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-ToBeReleased-SgNBRelConf-Item-SgNBPDCPpresent ::= SEQUENCE {
	uL-GTPtunnelEndpoint			GTPtunnelEndpoint																				OPTIONAL,
	dL-GTPtunnelEndpoint			GTPtunnelEndpoint																				OPTIONAL,
	iE-Extensions					ProtocolExtensionContainer { {E-RABs-ToBeReleased-SgNBRelConf-Item-SgNBPDCPpresentExtIEs} } OPTIONAL,
	...
}
*/

struct E_RABs_ToBeReleased_SgNBRelConf_Item_SgNBPDCPpresent : asn::sequence<3, 0, true, 3>
{
	static constexpr const char* name() {return "E-RABs-ToBeReleased-SgNBRelConf-Item-SgNBPDCPpresent";}
	using parent_t = asn::sequence<3, 0, true, 3>;
	struct uL_GTPtunnelEndpoint_t : GTPtunnelEndpoint
	{
		static constexpr const char* name() {return "uL_GTPtunnelEndpoint_t";}
		using parent_t = GTPtunnelEndpoint;
		static constexpr bool optional = true;

	};
	uL_GTPtunnelEndpoint_t& set_uL_GTPtunnelEndpoint() { uL_GTPtunnelEndpoint.setpresent(true); return uL_GTPtunnelEndpoint;}
	uL_GTPtunnelEndpoint_t const* get_uL_GTPtunnelEndpoint() const {return uL_GTPtunnelEndpoint.is_valid() ? &uL_GTPtunnelEndpoint : nullptr;}
	struct dL_GTPtunnelEndpoint_t : GTPtunnelEndpoint
	{
		static constexpr const char* name() {return "dL_GTPtunnelEndpoint_t";}
		using parent_t = GTPtunnelEndpoint;
		static constexpr bool optional = true;

	};
	dL_GTPtunnelEndpoint_t& set_dL_GTPtunnelEndpoint() { dL_GTPtunnelEndpoint.setpresent(true); return dL_GTPtunnelEndpoint;}
	dL_GTPtunnelEndpoint_t const* get_dL_GTPtunnelEndpoint() const {return dL_GTPtunnelEndpoint.is_valid() ? &dL_GTPtunnelEndpoint : nullptr;}
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_ToBeReleased_SgNBRelConf_Item_SgNBPDCPpresentExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_ToBeReleased_SgNBRelConf_Item_SgNBPDCPpresentExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(uL_GTPtunnelEndpoint);
		v(dL_GTPtunnelEndpoint);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(uL_GTPtunnelEndpoint);
		v(dL_GTPtunnelEndpoint);
		v(iE_Extensions);

	};
	void clear()
	{
		uL_GTPtunnelEndpoint.clear();
		dL_GTPtunnelEndpoint.clear();
		iE_Extensions.clear();

	};
	private:
	uL_GTPtunnelEndpoint_t	uL_GTPtunnelEndpoint;
	dL_GTPtunnelEndpoint_t	dL_GTPtunnelEndpoint;
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-ToBeReleased-SgNBRelConf-Item-SgNBPDCPnotpresentExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct E_RABs_ToBeReleased_SgNBRelConf_Item_SgNBPDCPnotpresentExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-ToBeReleased-SgNBRelConf-Item-SgNBPDCPnotpresent ::= SEQUENCE {
	iE-Extensions					ProtocolExtensionContainer { {E-RABs-ToBeReleased-SgNBRelConf-Item-SgNBPDCPnotpresentExtIEs} } 	OPTIONAL,
	...
}
*/

struct E_RABs_ToBeReleased_SgNBRelConf_Item_SgNBPDCPnotpresent : asn::sequence<1, 0, true, 1>
{
	static constexpr const char* name() {return "E-RABs-ToBeReleased-SgNBRelConf-Item-SgNBPDCPnotpresent";}
	using parent_t = asn::sequence<1, 0, true, 1>;
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_ToBeReleased_SgNBRelConf_Item_SgNBPDCPnotpresentExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_ToBeReleased_SgNBRelConf_Item_SgNBPDCPnotpresentExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(iE_Extensions);

	};
	void clear()
	{
		iE_Extensions.clear();

	};
	private:
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-ToBeReleased-SgNBRelConf-ItemExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct E_RABs_ToBeReleased_SgNBRelConf_ItemExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-ToBeReleased-SgNBRelConf-Item ::= SEQUENCE {
	e-RAB-ID							E-RAB-ID,
	en-DC-ResourceConfiguration			EN-DC-ResourceConfiguration,
	resource-configuration				CHOICE {
		sgNBPDCPpresent						E-RABs-ToBeReleased-SgNBRelConf-Item-SgNBPDCPpresent,
		sgNBPDCPnotpresent					E-RABs-ToBeReleased-SgNBRelConf-Item-SgNBPDCPnotpresent,
		...
	},
	iE-Extensions					ProtocolExtensionContainer { {E-RABs-ToBeReleased-SgNBRelConf-ItemExtIEs} }	OPTIONAL,
	...
}
*/

struct E_RABs_ToBeReleased_SgNBRelConf_Item : asn::sequence<4, 0, true, 1>
{
	static constexpr const char* name() {return "E-RABs-ToBeReleased-SgNBRelConf-Item";}
	using parent_t = asn::sequence<4, 0, true, 1>;
	struct e_RAB_ID_t : E_RAB_ID
	{
		static constexpr const char* name() {return "e_RAB_ID_t";}
		using parent_t = E_RAB_ID;

	};
	e_RAB_ID_t& ref_e_RAB_ID() {return e_RAB_ID;}
	e_RAB_ID_t const& ref_e_RAB_ID() const {return e_RAB_ID;}
	struct en_DC_ResourceConfiguration_t : EN_DC_ResourceConfiguration
	{
		static constexpr const char* name() {return "en_DC_ResourceConfiguration_t";}
		using parent_t = EN_DC_ResourceConfiguration;

	};
	en_DC_ResourceConfiguration_t& ref_en_DC_ResourceConfiguration() {return en_DC_ResourceConfiguration;}
	en_DC_ResourceConfiguration_t const& ref_en_DC_ResourceConfiguration() const {return en_DC_ResourceConfiguration;}
	struct resource_configuration_t : asn::choice<2, 0, true>
	{
		static constexpr const char* name() {return "resource_configuration_t";}
		using parent_t = asn::choice<2, 0, true>;
		index_type get_index() const {return index;}
		bool is_unknown() const {return index == 3;}
		void set_unknown() { set_index(3);  }
		~resource_configuration_t() {clear();}
		struct sgNBPDCPpresent_t : E_RABs_ToBeReleased_SgNBRelConf_Item_SgNBPDCPpresent
		{
			static constexpr const char* name() {return "sgNBPDCPpresent_t";}
			using parent_t = E_RABs_ToBeReleased_SgNBRelConf_Item_SgNBPDCPpresent;

		};
		struct sgNBPDCPnotpresent_t : E_RABs_ToBeReleased_SgNBRelConf_Item_SgNBPDCPnotpresent
		{
			static constexpr const char* name() {return "sgNBPDCPnotpresent_t";}
			using parent_t = E_RABs_ToBeReleased_SgNBRelConf_Item_SgNBPDCPnotpresent;

		};
		void clear()
		{
			switch(get_index())
			{
			case 1: var.destroy<sgNBPDCPpresent_t>(); break;
			case 2: var.destroy<sgNBPDCPnotpresent_t>(); break;
			}
			index = 0;
			base::clear();
		}
		template<typename V> bool decode(size_t idx, V& v)
		{
			clear();
			switch(idx)
			{
			case 1: set_index(1); return v(var.build<sgNBPDCPpresent_t>());
			case 2: set_index(2); return v(var.build<sgNBPDCPnotpresent_t>());
			}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			switch(get_index())
			{
			case 1: return v(var.as<sgNBPDCPpresent_t>());
			case 2: return v(var.as<sgNBPDCPnotpresent_t>());
			}
			return false;
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<sgNBPDCPpresent_t>(1);
			v.template operator()<sgNBPDCPnotpresent_t>(2);

		}
		sgNBPDCPpresent_t& select_sgNBPDCPpresent() { if(get_index() != 1) { clear(); set_index(1); return var.build<sgNBPDCPpresent_t>();} return var.as<sgNBPDCPpresent_t>();}
		sgNBPDCPpresent_t const* get_sgNBPDCPpresent() const { if(get_index() == 1) { return &var.as<sgNBPDCPpresent_t>();} return nullptr; }
		sgNBPDCPnotpresent_t& select_sgNBPDCPnotpresent() { if(get_index() != 2) { clear(); set_index(2); return var.build<sgNBPDCPnotpresent_t>();} return var.as<sgNBPDCPnotpresent_t>();}
		sgNBPDCPnotpresent_t const* get_sgNBPDCPnotpresent() const { if(get_index() == 2) { return &var.as<sgNBPDCPnotpresent_t>();} return nullptr; }
		private:
		void set_index(index_type i) {index = i; base::set();}
		union union_type
		{
			char dummy1[sizeof(sgNBPDCPpresent_t)];
			char dummy2[sizeof(sgNBPDCPnotpresent_t)];

		};
		asn::variant<sizeof(union_type)>	var;
		index_type	index {0};
	};
	resource_configuration_t& ref_resource_configuration() {return resource_configuration;}
	resource_configuration_t const& ref_resource_configuration() const {return resource_configuration;}
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_ToBeReleased_SgNBRelConf_ItemExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_ToBeReleased_SgNBRelConf_ItemExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(e_RAB_ID);
		v(en_DC_ResourceConfiguration);
		v(resource_configuration);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(e_RAB_ID);
		v(en_DC_ResourceConfiguration);
		v(resource_configuration);
		v(iE_Extensions);

	};
	void clear()
	{
		e_RAB_ID.clear();
		en_DC_ResourceConfiguration.clear();
		resource_configuration.clear();
		iE_Extensions.clear();

	};
	private:
	e_RAB_ID_t	e_RAB_ID;
	en_DC_ResourceConfiguration_t	en_DC_ResourceConfiguration;
	resource_configuration_t	resource_configuration;
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-ToBeReleased-SgNBRelConf-ItemIEs X2AP-PROTOCOL-IES ::= {
	{ ID id-E-RABs-ToBeReleased-SgNBRelConf-Item		CRITICALITY ignore		TYPE E-RABs-ToBeReleased-SgNBRelConf-Item		PRESENCE mandatory},
	...
}
*/

struct E_RABs_ToBeReleased_SgNBRelConf_ItemIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_ToBeReleased_SgNBRelConf_Item() { set(id_E_RABs_ToBeReleased_SgNBRelConf_Item); type=1;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_E_RABs_ToBeReleased_SgNBRelConf_Item)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_E_RABs_ToBeReleased_SgNBRelConf_Item);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_ToBeReleased_SgNBRelConf_Item() { set(ignore); type=1;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		E_RABs_ToBeReleased_SgNBRelConf_Item& select_id_E_RABs_ToBeReleased_SgNBRelConf_Item() { return set<E_RABs_ToBeReleased_SgNBRelConf_Item>(1); }
		E_RABs_ToBeReleased_SgNBRelConf_Item const* get_id_E_RABs_ToBeReleased_SgNBRelConf_Item() const { return get<E_RABs_ToBeReleased_SgNBRelConf_Item>(1); }
		bool is_unknown() const { return type == 2; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<E_RABs_ToBeReleased_SgNBRelConf_Item>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<E_RABs_ToBeReleased_SgNBRelConf_Item>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_E_RABs_ToBeReleased_SgNBRelConf_Item()); return true;
			case 2: if(type != 2) {clear(); asn::base::set();} type = 2; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<E_RABs_ToBeReleased_SgNBRelConf_Item>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(E_RABs_ToBeReleased_SgNBRelConf_Item)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_ToBeReleased_SgNBRelConf_Item() { set(mandatory); type=1;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-ToBeReleased-SgNBRelConfList ::= SEQUENCE (SIZE(1..maxnoofBearers)) OF ProtocolIE-Single-Container { {E-RABs-ToBeReleased-SgNBRelConf-ItemIEs} }
*/

struct E_RABs_ToBeReleased_SgNBRelConfList_elm : ProtocolIE_Single_Container<E_RABs_ToBeReleased_SgNBRelConf_ItemIEs>
{
	static constexpr const char* name() {return "E_RABs_ToBeReleased_SgNBRelConfList_elm";}
	using parent_t = ProtocolIE_Single_Container<E_RABs_ToBeReleased_SgNBRelConf_ItemIEs>;

};
struct E_RABs_ToBeReleased_SgNBRelConfList : asn::sequenceof<E_RABs_ToBeReleased_SgNBRelConfList_elm>
{
	static constexpr const char* name() {return "E-RABs-ToBeReleased-SgNBRelConfList";}
	using parent_t = asn::sequenceof<E_RABs_ToBeReleased_SgNBRelConfList_elm>;
	using constraint_t = asn::constraints<false,asn::span<1,  maxnoofBearers >>;

};
/*
E-RABs-ToBeReleased-SgNBRelReq-Item-SgNBPDCPpresentExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct E_RABs_ToBeReleased_SgNBRelReq_Item_SgNBPDCPpresentExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-ToBeReleased-SgNBRelReq-Item-SgNBPDCPpresent ::= SEQUENCE {
	uL-GTPtunnelEndpoint			GTPtunnelEndpoint																	OPTIONAL,
	dL-GTPtunnelEndpoint			GTPtunnelEndpoint																				OPTIONAL,
	iE-Extensions					ProtocolExtensionContainer { {E-RABs-ToBeReleased-SgNBRelReq-Item-SgNBPDCPpresentExtIEs} } 	OPTIONAL,
	...
}
*/

struct E_RABs_ToBeReleased_SgNBRelReq_Item_SgNBPDCPpresent : asn::sequence<3, 0, true, 3>
{
	static constexpr const char* name() {return "E-RABs-ToBeReleased-SgNBRelReq-Item-SgNBPDCPpresent";}
	using parent_t = asn::sequence<3, 0, true, 3>;
	struct uL_GTPtunnelEndpoint_t : GTPtunnelEndpoint
	{
		static constexpr const char* name() {return "uL_GTPtunnelEndpoint_t";}
		using parent_t = GTPtunnelEndpoint;
		static constexpr bool optional = true;

	};
	uL_GTPtunnelEndpoint_t& set_uL_GTPtunnelEndpoint() { uL_GTPtunnelEndpoint.setpresent(true); return uL_GTPtunnelEndpoint;}
	uL_GTPtunnelEndpoint_t const* get_uL_GTPtunnelEndpoint() const {return uL_GTPtunnelEndpoint.is_valid() ? &uL_GTPtunnelEndpoint : nullptr;}
	struct dL_GTPtunnelEndpoint_t : GTPtunnelEndpoint
	{
		static constexpr const char* name() {return "dL_GTPtunnelEndpoint_t";}
		using parent_t = GTPtunnelEndpoint;
		static constexpr bool optional = true;

	};
	dL_GTPtunnelEndpoint_t& set_dL_GTPtunnelEndpoint() { dL_GTPtunnelEndpoint.setpresent(true); return dL_GTPtunnelEndpoint;}
	dL_GTPtunnelEndpoint_t const* get_dL_GTPtunnelEndpoint() const {return dL_GTPtunnelEndpoint.is_valid() ? &dL_GTPtunnelEndpoint : nullptr;}
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_ToBeReleased_SgNBRelReq_Item_SgNBPDCPpresentExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_ToBeReleased_SgNBRelReq_Item_SgNBPDCPpresentExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(uL_GTPtunnelEndpoint);
		v(dL_GTPtunnelEndpoint);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(uL_GTPtunnelEndpoint);
		v(dL_GTPtunnelEndpoint);
		v(iE_Extensions);

	};
	void clear()
	{
		uL_GTPtunnelEndpoint.clear();
		dL_GTPtunnelEndpoint.clear();
		iE_Extensions.clear();

	};
	private:
	uL_GTPtunnelEndpoint_t	uL_GTPtunnelEndpoint;
	dL_GTPtunnelEndpoint_t	dL_GTPtunnelEndpoint;
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-ToBeReleased-SgNBRelReq-Item-SgNBPDCPnotpresentExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct E_RABs_ToBeReleased_SgNBRelReq_Item_SgNBPDCPnotpresentExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-ToBeReleased-SgNBRelReq-Item-SgNBPDCPnotpresent ::= SEQUENCE {
	iE-Extensions					ProtocolExtensionContainer { {E-RABs-ToBeReleased-SgNBRelReq-Item-SgNBPDCPnotpresentExtIEs} } 	OPTIONAL,
	...
}
*/

struct E_RABs_ToBeReleased_SgNBRelReq_Item_SgNBPDCPnotpresent : asn::sequence<1, 0, true, 1>
{
	static constexpr const char* name() {return "E-RABs-ToBeReleased-SgNBRelReq-Item-SgNBPDCPnotpresent";}
	using parent_t = asn::sequence<1, 0, true, 1>;
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_ToBeReleased_SgNBRelReq_Item_SgNBPDCPnotpresentExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_ToBeReleased_SgNBRelReq_Item_SgNBPDCPnotpresentExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(iE_Extensions);

	};
	void clear()
	{
		iE_Extensions.clear();

	};
	private:
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-ToBeReleased-SgNBRelReq-ItemExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct E_RABs_ToBeReleased_SgNBRelReq_ItemExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-ToBeReleased-SgNBRelReq-Item ::= SEQUENCE {
	e-RAB-ID							E-RAB-ID,
	en-DC-ResourceConfiguration			EN-DC-ResourceConfiguration,
	resource-configuration				CHOICE {
		sgNBPDCPpresent						E-RABs-ToBeReleased-SgNBRelReq-Item-SgNBPDCPpresent,
		sgNBPDCPnotpresent					E-RABs-ToBeReleased-SgNBRelReq-Item-SgNBPDCPnotpresent,
		...
	},
	iE-Extensions					ProtocolExtensionContainer { {E-RABs-ToBeReleased-SgNBRelReq-ItemExtIEs} }	OPTIONAL,
	...
}
*/

struct E_RABs_ToBeReleased_SgNBRelReq_Item : asn::sequence<4, 0, true, 1>
{
	static constexpr const char* name() {return "E-RABs-ToBeReleased-SgNBRelReq-Item";}
	using parent_t = asn::sequence<4, 0, true, 1>;
	struct e_RAB_ID_t : E_RAB_ID
	{
		static constexpr const char* name() {return "e_RAB_ID_t";}
		using parent_t = E_RAB_ID;

	};
	e_RAB_ID_t& ref_e_RAB_ID() {return e_RAB_ID;}
	e_RAB_ID_t const& ref_e_RAB_ID() const {return e_RAB_ID;}
	struct en_DC_ResourceConfiguration_t : EN_DC_ResourceConfiguration
	{
		static constexpr const char* name() {return "en_DC_ResourceConfiguration_t";}
		using parent_t = EN_DC_ResourceConfiguration;

	};
	en_DC_ResourceConfiguration_t& ref_en_DC_ResourceConfiguration() {return en_DC_ResourceConfiguration;}
	en_DC_ResourceConfiguration_t const& ref_en_DC_ResourceConfiguration() const {return en_DC_ResourceConfiguration;}
	struct resource_configuration_t : asn::choice<2, 0, true>
	{
		static constexpr const char* name() {return "resource_configuration_t";}
		using parent_t = asn::choice<2, 0, true>;
		index_type get_index() const {return index;}
		bool is_unknown() const {return index == 3;}
		void set_unknown() { set_index(3);  }
		~resource_configuration_t() {clear();}
		struct sgNBPDCPpresent_t : E_RABs_ToBeReleased_SgNBRelReq_Item_SgNBPDCPpresent
		{
			static constexpr const char* name() {return "sgNBPDCPpresent_t";}
			using parent_t = E_RABs_ToBeReleased_SgNBRelReq_Item_SgNBPDCPpresent;

		};
		struct sgNBPDCPnotpresent_t : E_RABs_ToBeReleased_SgNBRelReq_Item_SgNBPDCPnotpresent
		{
			static constexpr const char* name() {return "sgNBPDCPnotpresent_t";}
			using parent_t = E_RABs_ToBeReleased_SgNBRelReq_Item_SgNBPDCPnotpresent;

		};
		void clear()
		{
			switch(get_index())
			{
			case 1: var.destroy<sgNBPDCPpresent_t>(); break;
			case 2: var.destroy<sgNBPDCPnotpresent_t>(); break;
			}
			index = 0;
			base::clear();
		}
		template<typename V> bool decode(size_t idx, V& v)
		{
			clear();
			switch(idx)
			{
			case 1: set_index(1); return v(var.build<sgNBPDCPpresent_t>());
			case 2: set_index(2); return v(var.build<sgNBPDCPnotpresent_t>());
			}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			switch(get_index())
			{
			case 1: return v(var.as<sgNBPDCPpresent_t>());
			case 2: return v(var.as<sgNBPDCPnotpresent_t>());
			}
			return false;
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<sgNBPDCPpresent_t>(1);
			v.template operator()<sgNBPDCPnotpresent_t>(2);

		}
		sgNBPDCPpresent_t& select_sgNBPDCPpresent() { if(get_index() != 1) { clear(); set_index(1); return var.build<sgNBPDCPpresent_t>();} return var.as<sgNBPDCPpresent_t>();}
		sgNBPDCPpresent_t const* get_sgNBPDCPpresent() const { if(get_index() == 1) { return &var.as<sgNBPDCPpresent_t>();} return nullptr; }
		sgNBPDCPnotpresent_t& select_sgNBPDCPnotpresent() { if(get_index() != 2) { clear(); set_index(2); return var.build<sgNBPDCPnotpresent_t>();} return var.as<sgNBPDCPnotpresent_t>();}
		sgNBPDCPnotpresent_t const* get_sgNBPDCPnotpresent() const { if(get_index() == 2) { return &var.as<sgNBPDCPnotpresent_t>();} return nullptr; }
		private:
		void set_index(index_type i) {index = i; base::set();}
		union union_type
		{
			char dummy1[sizeof(sgNBPDCPpresent_t)];
			char dummy2[sizeof(sgNBPDCPnotpresent_t)];

		};
		asn::variant<sizeof(union_type)>	var;
		index_type	index {0};
	};
	resource_configuration_t& ref_resource_configuration() {return resource_configuration;}
	resource_configuration_t const& ref_resource_configuration() const {return resource_configuration;}
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_ToBeReleased_SgNBRelReq_ItemExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_ToBeReleased_SgNBRelReq_ItemExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(e_RAB_ID);
		v(en_DC_ResourceConfiguration);
		v(resource_configuration);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(e_RAB_ID);
		v(en_DC_ResourceConfiguration);
		v(resource_configuration);
		v(iE_Extensions);

	};
	void clear()
	{
		e_RAB_ID.clear();
		en_DC_ResourceConfiguration.clear();
		resource_configuration.clear();
		iE_Extensions.clear();

	};
	private:
	e_RAB_ID_t	e_RAB_ID;
	en_DC_ResourceConfiguration_t	en_DC_ResourceConfiguration;
	resource_configuration_t	resource_configuration;
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-ToBeReleased-SgNBRelReq-ItemIEs X2AP-PROTOCOL-IES ::= {
	{ ID id-E-RABs-ToBeReleased-SgNBRelReq-Item		CRITICALITY ignore	TYPE E-RABs-ToBeReleased-SgNBRelReq-Item		PRESENCE mandatory},
	...
}
*/

struct E_RABs_ToBeReleased_SgNBRelReq_ItemIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_ToBeReleased_SgNBRelReq_Item() { set(id_E_RABs_ToBeReleased_SgNBRelReq_Item); type=1;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_E_RABs_ToBeReleased_SgNBRelReq_Item)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_E_RABs_ToBeReleased_SgNBRelReq_Item);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_ToBeReleased_SgNBRelReq_Item() { set(ignore); type=1;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		E_RABs_ToBeReleased_SgNBRelReq_Item& select_id_E_RABs_ToBeReleased_SgNBRelReq_Item() { return set<E_RABs_ToBeReleased_SgNBRelReq_Item>(1); }
		E_RABs_ToBeReleased_SgNBRelReq_Item const* get_id_E_RABs_ToBeReleased_SgNBRelReq_Item() const { return get<E_RABs_ToBeReleased_SgNBRelReq_Item>(1); }
		bool is_unknown() const { return type == 2; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<E_RABs_ToBeReleased_SgNBRelReq_Item>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<E_RABs_ToBeReleased_SgNBRelReq_Item>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_E_RABs_ToBeReleased_SgNBRelReq_Item()); return true;
			case 2: if(type != 2) {clear(); asn::base::set();} type = 2; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<E_RABs_ToBeReleased_SgNBRelReq_Item>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(E_RABs_ToBeReleased_SgNBRelReq_Item)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_ToBeReleased_SgNBRelReq_Item() { set(mandatory); type=1;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-ToBeReleased-SgNBRelReqList ::= SEQUENCE (SIZE(1..maxnoofBearers)) OF ProtocolIE-Single-Container { {E-RABs-ToBeReleased-SgNBRelReq-ItemIEs} }
*/

struct E_RABs_ToBeReleased_SgNBRelReqList_elm : ProtocolIE_Single_Container<E_RABs_ToBeReleased_SgNBRelReq_ItemIEs>
{
	static constexpr const char* name() {return "E_RABs_ToBeReleased_SgNBRelReqList_elm";}
	using parent_t = ProtocolIE_Single_Container<E_RABs_ToBeReleased_SgNBRelReq_ItemIEs>;

};
struct E_RABs_ToBeReleased_SgNBRelReqList : asn::sequenceof<E_RABs_ToBeReleased_SgNBRelReqList_elm>
{
	static constexpr const char* name() {return "E-RABs-ToBeReleased-SgNBRelReqList";}
	using parent_t = asn::sequenceof<E_RABs_ToBeReleased_SgNBRelReqList_elm>;
	using constraint_t = asn::constraints<false,asn::span<1,  maxnoofBearers >>;

};
/*
E-RABs-ToBeReleased-SgNBRelReqd-ItemExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct E_RABs_ToBeReleased_SgNBRelReqd_ItemExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-ToBeReleased-SgNBRelReqd-Item ::= SEQUENCE {
	e-RAB-ID							E-RAB-ID,
	rlc-Mode-transferred			RLCMode,
	iE-Extensions					ProtocolExtensionContainer { {E-RABs-ToBeReleased-SgNBRelReqd-ItemExtIEs} }	OPTIONAL,
	...
}
*/

struct E_RABs_ToBeReleased_SgNBRelReqd_Item : asn::sequence<3, 0, true, 1>
{
	static constexpr const char* name() {return "E-RABs-ToBeReleased-SgNBRelReqd-Item";}
	using parent_t = asn::sequence<3, 0, true, 1>;
	struct e_RAB_ID_t : E_RAB_ID
	{
		static constexpr const char* name() {return "e_RAB_ID_t";}
		using parent_t = E_RAB_ID;

	};
	e_RAB_ID_t& ref_e_RAB_ID() {return e_RAB_ID;}
	e_RAB_ID_t const& ref_e_RAB_ID() const {return e_RAB_ID;}
	struct rlc_Mode_transferred_t : RLCMode
	{
		static constexpr const char* name() {return "rlc_Mode_transferred_t";}
		using parent_t = RLCMode;

	};
	rlc_Mode_transferred_t& ref_rlc_Mode_transferred() {return rlc_Mode_transferred;}
	rlc_Mode_transferred_t const& ref_rlc_Mode_transferred() const {return rlc_Mode_transferred;}
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_ToBeReleased_SgNBRelReqd_ItemExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_ToBeReleased_SgNBRelReqd_ItemExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(e_RAB_ID);
		v(rlc_Mode_transferred);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(e_RAB_ID);
		v(rlc_Mode_transferred);
		v(iE_Extensions);

	};
	void clear()
	{
		e_RAB_ID.clear();
		rlc_Mode_transferred.clear();
		iE_Extensions.clear();

	};
	private:
	e_RAB_ID_t	e_RAB_ID;
	rlc_Mode_transferred_t	rlc_Mode_transferred;
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-ToBeReleased-SgNBRelReqd-ItemIEs X2AP-PROTOCOL-IES ::= {
	{ ID id-E-RABs-ToBeReleased-SgNBRelReqd-Item		CRITICALITY ignore	TYPE E-RABs-ToBeReleased-SgNBRelReqd-Item		PRESENCE mandatory},
	...
}
*/

struct E_RABs_ToBeReleased_SgNBRelReqd_ItemIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_ToBeReleased_SgNBRelReqd_Item() { set(id_E_RABs_ToBeReleased_SgNBRelReqd_Item); type=1;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_E_RABs_ToBeReleased_SgNBRelReqd_Item)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_E_RABs_ToBeReleased_SgNBRelReqd_Item);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_ToBeReleased_SgNBRelReqd_Item() { set(ignore); type=1;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		E_RABs_ToBeReleased_SgNBRelReqd_Item& select_id_E_RABs_ToBeReleased_SgNBRelReqd_Item() { return set<E_RABs_ToBeReleased_SgNBRelReqd_Item>(1); }
		E_RABs_ToBeReleased_SgNBRelReqd_Item const* get_id_E_RABs_ToBeReleased_SgNBRelReqd_Item() const { return get<E_RABs_ToBeReleased_SgNBRelReqd_Item>(1); }
		bool is_unknown() const { return type == 2; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<E_RABs_ToBeReleased_SgNBRelReqd_Item>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<E_RABs_ToBeReleased_SgNBRelReqd_Item>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_E_RABs_ToBeReleased_SgNBRelReqd_Item()); return true;
			case 2: if(type != 2) {clear(); asn::base::set();} type = 2; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<E_RABs_ToBeReleased_SgNBRelReqd_Item>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(E_RABs_ToBeReleased_SgNBRelReqd_Item)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_ToBeReleased_SgNBRelReqd_Item() { set(mandatory); type=1;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-ToBeReleased-SgNBRelReqdList ::= SEQUENCE (SIZE(1..maxnoofBearers)) OF ProtocolIE-Single-Container { {E-RABs-ToBeReleased-SgNBRelReqd-ItemIEs} }
*/

struct E_RABs_ToBeReleased_SgNBRelReqdList_elm : ProtocolIE_Single_Container<E_RABs_ToBeReleased_SgNBRelReqd_ItemIEs>
{
	static constexpr const char* name() {return "E_RABs_ToBeReleased_SgNBRelReqdList_elm";}
	using parent_t = ProtocolIE_Single_Container<E_RABs_ToBeReleased_SgNBRelReqd_ItemIEs>;

};
struct E_RABs_ToBeReleased_SgNBRelReqdList : asn::sequenceof<E_RABs_ToBeReleased_SgNBRelReqdList_elm>
{
	static constexpr const char* name() {return "E-RABs-ToBeReleased-SgNBRelReqdList";}
	using parent_t = asn::sequenceof<E_RABs_ToBeReleased_SgNBRelReqdList_elm>;
	using constraint_t = asn::constraints<false,asn::span<1,  maxnoofBearers >>;

};
/*
E-RABs-ToBeSetup-ItemExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	{ ID id-BearerType		CRITICALITY reject	EXTENSION BearerType		PRESENCE optional},
	...
}
*/

struct E_RABs_ToBeSetup_ItemExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_BearerType() { set(id_BearerType); type=1;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_BearerType)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_BearerType);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_BearerType() { set(reject); type=1;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		BearerType& select_id_BearerType() { return set<BearerType>(1); }
		BearerType const* get_id_BearerType() const { return get<BearerType>(1); }
		bool is_unknown() const { return type == 2; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<BearerType>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<BearerType>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_BearerType()); return true;
			case 2: if(type != 2) {clear(); asn::base::set();} type = 2; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<BearerType>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(BearerType)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_BearerType() { set(optional); type=1;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(optional)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(optional);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-ToBeSetup-Item ::= SEQUENCE {
	e-RAB-ID					E-RAB-ID,
	e-RAB-Level-QoS-Parameters		E-RAB-Level-QoS-Parameters,
	dL-Forwarding					DL-Forwarding													OPTIONAL,
	uL-GTPtunnelEndpoint			GTPtunnelEndpoint,
	iE-Extensions					ProtocolExtensionContainer { {E-RABs-ToBeSetup-ItemExtIEs} } OPTIONAL,
	...
}
*/

struct E_RABs_ToBeSetup_Item : asn::sequence<5, 0, true, 2>
{
	static constexpr const char* name() {return "E-RABs-ToBeSetup-Item";}
	using parent_t = asn::sequence<5, 0, true, 2>;
	struct e_RAB_ID_t : E_RAB_ID
	{
		static constexpr const char* name() {return "e_RAB_ID_t";}
		using parent_t = E_RAB_ID;

	};
	e_RAB_ID_t& ref_e_RAB_ID() {return e_RAB_ID;}
	e_RAB_ID_t const& ref_e_RAB_ID() const {return e_RAB_ID;}
	struct e_RAB_Level_QoS_Parameters_t : E_RAB_Level_QoS_Parameters
	{
		static constexpr const char* name() {return "e_RAB_Level_QoS_Parameters_t";}
		using parent_t = E_RAB_Level_QoS_Parameters;

	};
	e_RAB_Level_QoS_Parameters_t& ref_e_RAB_Level_QoS_Parameters() {return e_RAB_Level_QoS_Parameters;}
	e_RAB_Level_QoS_Parameters_t const& ref_e_RAB_Level_QoS_Parameters() const {return e_RAB_Level_QoS_Parameters;}
	struct dL_Forwarding_t : DL_Forwarding
	{
		static constexpr const char* name() {return "dL_Forwarding_t";}
		using parent_t = DL_Forwarding;
		static constexpr bool optional = true;

	};
	dL_Forwarding_t& set_dL_Forwarding() { dL_Forwarding.setpresent(true); return dL_Forwarding;}
	dL_Forwarding_t const* get_dL_Forwarding() const {return dL_Forwarding.is_valid() ? &dL_Forwarding : nullptr;}
	struct uL_GTPtunnelEndpoint_t : GTPtunnelEndpoint
	{
		static constexpr const char* name() {return "uL_GTPtunnelEndpoint_t";}
		using parent_t = GTPtunnelEndpoint;

	};
	uL_GTPtunnelEndpoint_t& ref_uL_GTPtunnelEndpoint() {return uL_GTPtunnelEndpoint;}
	uL_GTPtunnelEndpoint_t const& ref_uL_GTPtunnelEndpoint() const {return uL_GTPtunnelEndpoint;}
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_ToBeSetup_ItemExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_ToBeSetup_ItemExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(e_RAB_ID);
		v(e_RAB_Level_QoS_Parameters);
		v(dL_Forwarding);
		v(uL_GTPtunnelEndpoint);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(e_RAB_ID);
		v(e_RAB_Level_QoS_Parameters);
		v(dL_Forwarding);
		v(uL_GTPtunnelEndpoint);
		v(iE_Extensions);

	};
	void clear()
	{
		e_RAB_ID.clear();
		e_RAB_Level_QoS_Parameters.clear();
		dL_Forwarding.clear();
		uL_GTPtunnelEndpoint.clear();
		iE_Extensions.clear();

	};
	private:
	e_RAB_ID_t	e_RAB_ID;
	e_RAB_Level_QoS_Parameters_t	e_RAB_Level_QoS_Parameters;
	dL_Forwarding_t	dL_Forwarding;
	uL_GTPtunnelEndpoint_t	uL_GTPtunnelEndpoint;
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-ToBeSetup-ItemIEs 	X2AP-PROTOCOL-IES ::= {
	{ ID id-E-RABs-ToBeSetup-Item	 CRITICALITY ignore 	TYPE E-RABs-ToBeSetup-Item 	PRESENCE mandatory },
	...
}
*/

struct E_RABs_ToBeSetup_ItemIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_ToBeSetup_Item() { set(id_E_RABs_ToBeSetup_Item); type=1;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_E_RABs_ToBeSetup_Item)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_E_RABs_ToBeSetup_Item);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_ToBeSetup_Item() { set(ignore); type=1;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		E_RABs_ToBeSetup_Item& select_id_E_RABs_ToBeSetup_Item() { return set<E_RABs_ToBeSetup_Item>(1); }
		E_RABs_ToBeSetup_Item const* get_id_E_RABs_ToBeSetup_Item() const { return get<E_RABs_ToBeSetup_Item>(1); }
		bool is_unknown() const { return type == 2; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<E_RABs_ToBeSetup_Item>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<E_RABs_ToBeSetup_Item>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_E_RABs_ToBeSetup_Item()); return true;
			case 2: if(type != 2) {clear(); asn::base::set();} type = 2; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<E_RABs_ToBeSetup_Item>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(E_RABs_ToBeSetup_Item)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_ToBeSetup_Item() { set(mandatory); type=1;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-ToBeSetup-List ::= SEQUENCE (SIZE(1..maxnoofBearers)) OF ProtocolIE-Single-Container { {E-RABs-ToBeSetup-ItemIEs} }
*/

struct E_RABs_ToBeSetup_List_elm : ProtocolIE_Single_Container<E_RABs_ToBeSetup_ItemIEs>
{
	static constexpr const char* name() {return "E_RABs_ToBeSetup_List_elm";}
	using parent_t = ProtocolIE_Single_Container<E_RABs_ToBeSetup_ItemIEs>;

};
struct E_RABs_ToBeSetup_List : asn::sequenceof<E_RABs_ToBeSetup_List_elm>
{
	static constexpr const char* name() {return "E-RABs-ToBeSetup-List";}
	using parent_t = asn::sequenceof<E_RABs_ToBeSetup_List_elm>;
	using constraint_t = asn::constraints<false,asn::span<1,  maxnoofBearers >>;

};
/*
E-RABs-ToBeSetupRetrieve-ItemExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	{ ID id-uL-GTPtunnelEndpoint		CRITICALITY reject	EXTENSION GTPtunnelEndpoint		PRESENCE mandatory}|
	{ ID id-dL-Forwarding		CRITICALITY ignore	EXTENSION DL-Forwarding		PRESENCE optional },
	...
}
*/

struct E_RABs_ToBeSetupRetrieve_ItemExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 3; }
		void clear() {type = 0;}
		void select_id_uL_GTPtunnelEndpoint() { set(id_uL_GTPtunnelEndpoint); type=1;}
		void select_id_dL_Forwarding() { set(id_dL_Forwarding); type=2;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_uL_GTPtunnelEndpoint)) { type = 1; return true; }
			else if(equal(id_dL_Forwarding)) { type = 2; return true; }
			else { type = 3; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_uL_GTPtunnelEndpoint);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_dL_Forwarding);} return false;
			case 3: type = 3; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 3; }
		void clear() {type = 0;}
		void select_id_uL_GTPtunnelEndpoint() { set(reject); type=1;}
		void select_id_dL_Forwarding() { set(ignore); type=2;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else if(equal(ignore)) { type = 2; return true; }
			else { type = 3; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(ignore);} return false;
			case 3: type = 3; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		GTPtunnelEndpoint& select_id_uL_GTPtunnelEndpoint() { return set<GTPtunnelEndpoint>(1); }
		GTPtunnelEndpoint const* get_id_uL_GTPtunnelEndpoint() const { return get<GTPtunnelEndpoint>(1); }
		DL_Forwarding& select_id_dL_Forwarding() { return set<DL_Forwarding>(2); }
		DL_Forwarding const* get_id_dL_Forwarding() const { return get<DL_Forwarding>(2); }
		bool is_unknown() const { return type == 3; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<GTPtunnelEndpoint>(); break;
			case 2: var.destroy<DL_Forwarding>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<GTPtunnelEndpoint>(1);
			v.template operator()<DL_Forwarding>(2);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_uL_GTPtunnelEndpoint()); return true;
			case 2: v(select_id_dL_Forwarding()); return true;
			case 3: if(type != 3) {clear(); asn::base::set();} type = 3; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<GTPtunnelEndpoint>()); return true;
			case 2: v(var.as<DL_Forwarding>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(DL_Forwarding)];
			char dummy2[sizeof(GTPtunnelEndpoint)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 3; }
		void clear() {type = 0;}
		void select_id_uL_GTPtunnelEndpoint() { set(mandatory); type=1;}
		void select_id_dL_Forwarding() { set(optional); type=2;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(optional)) { type = 2; return true; }
			else { type = 3; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(optional);} return false;
			case 3: type = 3; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-ToBeSetupRetrieve-Item ::= SEQUENCE {
	e-RAB-ID						E-RAB-ID,
	e-RAB-Level-QoS-Parameters		E-RAB-Level-QoS-Parameters,
	bearerType						BearerType	OPTIONAL,
	iE-Extensions					ProtocolExtensionContainer { {E-RABs-ToBeSetupRetrieve-ItemExtIEs} } OPTIONAL,
	...
}
*/

struct E_RABs_ToBeSetupRetrieve_Item : asn::sequence<4, 0, true, 2>
{
	static constexpr const char* name() {return "E-RABs-ToBeSetupRetrieve-Item";}
	using parent_t = asn::sequence<4, 0, true, 2>;
	struct e_RAB_ID_t : E_RAB_ID
	{
		static constexpr const char* name() {return "e_RAB_ID_t";}
		using parent_t = E_RAB_ID;

	};
	e_RAB_ID_t& ref_e_RAB_ID() {return e_RAB_ID;}
	e_RAB_ID_t const& ref_e_RAB_ID() const {return e_RAB_ID;}
	struct e_RAB_Level_QoS_Parameters_t : E_RAB_Level_QoS_Parameters
	{
		static constexpr const char* name() {return "e_RAB_Level_QoS_Parameters_t";}
		using parent_t = E_RAB_Level_QoS_Parameters;

	};
	e_RAB_Level_QoS_Parameters_t& ref_e_RAB_Level_QoS_Parameters() {return e_RAB_Level_QoS_Parameters;}
	e_RAB_Level_QoS_Parameters_t const& ref_e_RAB_Level_QoS_Parameters() const {return e_RAB_Level_QoS_Parameters;}
	struct bearerType_t : BearerType
	{
		static constexpr const char* name() {return "bearerType_t";}
		using parent_t = BearerType;
		static constexpr bool optional = true;

	};
	bearerType_t& set_bearerType() { bearerType.setpresent(true); return bearerType;}
	bearerType_t const* get_bearerType() const {return bearerType.is_valid() ? &bearerType : nullptr;}
	struct iE_Extensions_t : ProtocolExtensionContainer<E_RABs_ToBeSetupRetrieve_ItemExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<E_RABs_ToBeSetupRetrieve_ItemExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(e_RAB_ID);
		v(e_RAB_Level_QoS_Parameters);
		v(bearerType);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(e_RAB_ID);
		v(e_RAB_Level_QoS_Parameters);
		v(bearerType);
		v(iE_Extensions);

	};
	void clear()
	{
		e_RAB_ID.clear();
		e_RAB_Level_QoS_Parameters.clear();
		bearerType.clear();
		iE_Extensions.clear();

	};
	private:
	e_RAB_ID_t	e_RAB_ID;
	e_RAB_Level_QoS_Parameters_t	e_RAB_Level_QoS_Parameters;
	bearerType_t	bearerType;
	iE_Extensions_t	iE_Extensions;

};
/*
E-RABs-ToBeSetupRetrieve-ItemIEs	X2AP-PROTOCOL-IES ::= {
	{ ID id-E-RABs-ToBeSetupRetrieve-Item	CRITICALITY ignore	TYPE E-RABs-ToBeSetupRetrieve-Item	PRESENCE mandatory},
	...
}
*/

struct E_RABs_ToBeSetupRetrieve_ItemIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_ToBeSetupRetrieve_Item() { set(id_E_RABs_ToBeSetupRetrieve_Item); type=1;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_E_RABs_ToBeSetupRetrieve_Item)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_E_RABs_ToBeSetupRetrieve_Item);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_ToBeSetupRetrieve_Item() { set(ignore); type=1;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		E_RABs_ToBeSetupRetrieve_Item& select_id_E_RABs_ToBeSetupRetrieve_Item() { return set<E_RABs_ToBeSetupRetrieve_Item>(1); }
		E_RABs_ToBeSetupRetrieve_Item const* get_id_E_RABs_ToBeSetupRetrieve_Item() const { return get<E_RABs_ToBeSetupRetrieve_Item>(1); }
		bool is_unknown() const { return type == 2; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<E_RABs_ToBeSetupRetrieve_Item>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<E_RABs_ToBeSetupRetrieve_Item>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_E_RABs_ToBeSetupRetrieve_Item()); return true;
			case 2: if(type != 2) {clear(); asn::base::set();} type = 2; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<E_RABs_ToBeSetupRetrieve_Item>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(E_RABs_ToBeSetupRetrieve_Item)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_E_RABs_ToBeSetupRetrieve_Item() { set(mandatory); type=1;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
E-RABs-ToBeSetup-ListRetrieve ::= SEQUENCE (SIZE(1..maxnoofBearers)) OF ProtocolIE-Single-Container { {E-RABs-ToBeSetupRetrieve-ItemIEs} }
*/

struct E_RABs_ToBeSetup_ListRetrieve_elm : ProtocolIE_Single_Container<E_RABs_ToBeSetupRetrieve_ItemIEs>
{
	static constexpr const char* name() {return "E_RABs_ToBeSetup_ListRetrieve_elm";}
	using parent_t = ProtocolIE_Single_Container<E_RABs_ToBeSetupRetrieve_ItemIEs>;

};
struct E_RABs_ToBeSetup_ListRetrieve : asn::sequenceof<E_RABs_ToBeSetup_ListRetrieve_elm>
{
	static constexpr const char* name() {return "E-RABs-ToBeSetup-ListRetrieve";}
	using parent_t = asn::sequenceof<E_RABs_ToBeSetup_ListRetrieve_elm>;
	using constraint_t = asn::constraints<false,asn::span<1,  maxnoofBearers >>;

};
/*
ENB-ENDCConfigUpdateAckIEs X2AP-PROTOCOL-IES ::= {
	...
}
*/

struct ENB_ENDCConfigUpdateAckIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
FDD-InfoNeighbourServedNRCell-Information-ExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct FDD_InfoNeighbourServedNRCell_Information_ExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
FDD-InfoNeighbourServedNRCell-Information ::= SEQUENCE {
	ul-NRFreqInfo			NRFreqInfo,
	dl-NRFreqInfo			NRFreqInfo,
	iE-Extensions			ProtocolExtensionContainer { {FDD-InfoNeighbourServedNRCell-Information-ExtIEs} }		OPTIONAL,
	...
}
*/

struct FDD_InfoNeighbourServedNRCell_Information : asn::sequence<3, 0, true, 1>
{
	static constexpr const char* name() {return "FDD-InfoNeighbourServedNRCell-Information";}
	using parent_t = asn::sequence<3, 0, true, 1>;
	struct ul_NRFreqInfo_t : NRFreqInfo
	{
		static constexpr const char* name() {return "ul_NRFreqInfo_t";}
		using parent_t = NRFreqInfo;

	};
	ul_NRFreqInfo_t& ref_ul_NRFreqInfo() {return ul_NRFreqInfo;}
	ul_NRFreqInfo_t const& ref_ul_NRFreqInfo() const {return ul_NRFreqInfo;}
	struct dl_NRFreqInfo_t : NRFreqInfo
	{
		static constexpr const char* name() {return "dl_NRFreqInfo_t";}
		using parent_t = NRFreqInfo;

	};
	dl_NRFreqInfo_t& ref_dl_NRFreqInfo() {return dl_NRFreqInfo;}
	dl_NRFreqInfo_t const& ref_dl_NRFreqInfo() const {return dl_NRFreqInfo;}
	struct iE_Extensions_t : ProtocolExtensionContainer<FDD_InfoNeighbourServedNRCell_Information_ExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<FDD_InfoNeighbourServedNRCell_Information_ExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(ul_NRFreqInfo);
		v(dl_NRFreqInfo);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(ul_NRFreqInfo);
		v(dl_NRFreqInfo);
		v(iE_Extensions);

	};
	void clear()
	{
		ul_NRFreqInfo.clear();
		dl_NRFreqInfo.clear();
		iE_Extensions.clear();

	};
	private:
	ul_NRFreqInfo_t	ul_NRFreqInfo;
	dl_NRFreqInfo_t	dl_NRFreqInfo;
	iE_Extensions_t	iE_Extensions;

};
/*
TDD-InfoNeighbourServedNRCell-Information-ExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct TDD_InfoNeighbourServedNRCell_Information_ExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
TDD-InfoNeighbourServedNRCell-Information ::= SEQUENCE {
	nRFreqInfo				NRFreqInfo,
	iE-Extensions			ProtocolExtensionContainer { {TDD-InfoNeighbourServedNRCell-Information-ExtIEs} }		OPTIONAL,
	...
}
*/

struct TDD_InfoNeighbourServedNRCell_Information : asn::sequence<2, 0, true, 1>
{
	static constexpr const char* name() {return "TDD-InfoNeighbourServedNRCell-Information";}
	using parent_t = asn::sequence<2, 0, true, 1>;
	struct nRFreqInfo_t : NRFreqInfo
	{
		static constexpr const char* name() {return "nRFreqInfo_t";}
		using parent_t = NRFreqInfo;

	};
	nRFreqInfo_t& ref_nRFreqInfo() {return nRFreqInfo;}
	nRFreqInfo_t const& ref_nRFreqInfo() const {return nRFreqInfo;}
	struct iE_Extensions_t : ProtocolExtensionContainer<TDD_InfoNeighbourServedNRCell_Information_ExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<TDD_InfoNeighbourServedNRCell_Information_ExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(nRFreqInfo);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(nRFreqInfo);
		v(iE_Extensions);

	};
	void clear()
	{
		nRFreqInfo.clear();
		iE_Extensions.clear();

	};
	private:
	nRFreqInfo_t	nRFreqInfo;
	iE_Extensions_t	iE_Extensions;

};
/*
NRNeighbour-Information-ExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct NRNeighbour_Information_ExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
NRNeighbour-Information ::= SEQUENCE (SIZE (1.. maxofNRNeighbours))OF SEQUENCE {
	nrpCI				NRPCI,
	nrCellID				NRCGI,
	fiveGS-TAC			FiveGS-TAC	OPTIONAL,
	configured-TAC		TAC			OPTIONAL,
	measurementTimingConfiguration	OCTET STRING,
	nRNeighbourModeInfo			CHOICE {
		fdd		FDD-InfoNeighbourServedNRCell-Information,
		tdd		TDD-InfoNeighbourServedNRCell-Information,
		...
	},
	iE-Extensions						ProtocolExtensionContainer { {NRNeighbour-Information-ExtIEs} } OPTIONAL,
	...
}
*/

struct NRNeighbour_Information_elm : asn::sequence<7, 0, true, 3>
{
	static constexpr const char* name() {return "NRNeighbour_Information_elm";}
	using parent_t = asn::sequence<7, 0, true, 3>;
	struct nrpCI_t : NRPCI
	{
		static constexpr const char* name() {return "nrpCI_t";}
		using parent_t = NRPCI;

	};
	nrpCI_t& ref_nrpCI() {return nrpCI;}
	nrpCI_t const& ref_nrpCI() const {return nrpCI;}
	struct nrCellID_t : NRCGI
	{
		static constexpr const char* name() {return "nrCellID_t";}
		using parent_t = NRCGI;

	};
	nrCellID_t& ref_nrCellID() {return nrCellID;}
	nrCellID_t const& ref_nrCellID() const {return nrCellID;}
	struct fiveGS_TAC_t : FiveGS_TAC
	{
		static constexpr const char* name() {return "fiveGS_TAC_t";}
		using parent_t = FiveGS_TAC;
		static constexpr bool optional = true;

	};
	fiveGS_TAC_t& set_fiveGS_TAC() { fiveGS_TAC.setpresent(true); return fiveGS_TAC;}
	fiveGS_TAC_t const* get_fiveGS_TAC() const {return fiveGS_TAC.is_valid() ? &fiveGS_TAC : nullptr;}
	struct configured_TAC_t : TAC
	{
		static constexpr const char* name() {return "configured_TAC_t";}
		using parent_t = TAC;
		static constexpr bool optional = true;

	};
	configured_TAC_t& set_configured_TAC() { configured_TAC.setpresent(true); return configured_TAC;}
	configured_TAC_t const* get_configured_TAC() const {return configured_TAC.is_valid() ? &configured_TAC : nullptr;}
	struct measurementTimingConfiguration_t : asn::ostring<>
	{
		static constexpr const char* name() {return "measurementTimingConfiguration_t";}
		using parent_t = asn::ostring<>;

	};

	measurementTimingConfiguration_t& ref_measurementTimingConfiguration() {return measurementTimingConfiguration;}
	measurementTimingConfiguration_t const& ref_measurementTimingConfiguration() const {return measurementTimingConfiguration;}
	struct nRNeighbourModeInfo_t : asn::choice<2, 0, true>
	{
		static constexpr const char* name() {return "nRNeighbourModeInfo_t";}
		using parent_t = asn::choice<2, 0, true>;
		index_type get_index() const {return index;}
		bool is_unknown() const {return index == 3;}
		void set_unknown() { set_index(3);  }
		~nRNeighbourModeInfo_t() {clear();}
		struct fdd_t : FDD_InfoNeighbourServedNRCell_Information
		{
			static constexpr const char* name() {return "fdd_t";}
			using parent_t = FDD_InfoNeighbourServedNRCell_Information;

		};
		struct tdd_t : TDD_InfoNeighbourServedNRCell_Information
		{
			static constexpr const char* name() {return "tdd_t";}
			using parent_t = TDD_InfoNeighbourServedNRCell_Information;

		};
		void clear()
		{
			switch(get_index())
			{
			case 1: var.destroy<fdd_t>(); break;
			case 2: var.destroy<tdd_t>(); break;
			}
			index = 0;
			base::clear();
		}
		template<typename V> bool decode(size_t idx, V& v)
		{
			clear();
			switch(idx)
			{
			case 1: set_index(1); return v(var.build<fdd_t>());
			case 2: set_index(2); return v(var.build<tdd_t>());
			}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			switch(get_index())
			{
			case 1: return v(var.as<fdd_t>());
			case 2: return v(var.as<tdd_t>());
			}
			return false;
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<fdd_t>(1);
			v.template operator()<tdd_t>(2);

		}
		fdd_t& select_fdd() { if(get_index() != 1) { clear(); set_index(1); return var.build<fdd_t>();} return var.as<fdd_t>();}
		fdd_t const* get_fdd() const { if(get_index() == 1) { return &var.as<fdd_t>();} return nullptr; }
		tdd_t& select_tdd() { if(get_index() != 2) { clear(); set_index(2); return var.build<tdd_t>();} return var.as<tdd_t>();}
		tdd_t const* get_tdd() const { if(get_index() == 2) { return &var.as<tdd_t>();} return nullptr; }
		private:
		void set_index(index_type i) {index = i; base::set();}
		union union_type
		{
			char dummy1[sizeof(fdd_t)];
			char dummy2[sizeof(tdd_t)];

		};
		asn::variant<sizeof(union_type)>	var;
		index_type	index {0};
	};
	nRNeighbourModeInfo_t& ref_nRNeighbourModeInfo() {return nRNeighbourModeInfo;}
	nRNeighbourModeInfo_t const& ref_nRNeighbourModeInfo() const {return nRNeighbourModeInfo;}
	struct iE_Extensions_t : ProtocolExtensionContainer<NRNeighbour_Information_ExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<NRNeighbour_Information_ExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(nrpCI);
		v(nrCellID);
		v(fiveGS_TAC);
		v(configured_TAC);
		v(measurementTimingConfiguration);
		v(nRNeighbourModeInfo);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(nrpCI);
		v(nrCellID);
		v(fiveGS_TAC);
		v(configured_TAC);
		v(measurementTimingConfiguration);
		v(nRNeighbourModeInfo);
		v(iE_Extensions);

	};
	void clear()
	{
		nrpCI.clear();
		nrCellID.clear();
		fiveGS_TAC.clear();
		configured_TAC.clear();
		measurementTimingConfiguration.clear();
		nRNeighbourModeInfo.clear();
		iE_Extensions.clear();

	};
	private:
	nrpCI_t	nrpCI;
	nrCellID_t	nrCellID;
	fiveGS_TAC_t	fiveGS_TAC;
	configured_TAC_t	configured_TAC;
	measurementTimingConfiguration_t	measurementTimingConfiguration;
	nRNeighbourModeInfo_t	nRNeighbourModeInfo;
	iE_Extensions_t	iE_Extensions;

};
struct NRNeighbour_Information : asn::sequenceof<NRNeighbour_Information_elm>
{
	static constexpr const char* name() {return "NRNeighbour-Information";}
	using parent_t = asn::sequenceof<NRNeighbour_Information_elm>;
	using constraint_t = asn::constraints<false,asn::span<1,  maxofNRNeighbours >>;

};
/*
ServedEUTRAcellsENDCX2Management-ExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct ServedEUTRAcellsENDCX2Management_ExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
ServedEUTRAcellsENDCX2ManagementList ::= SEQUENCE (SIZE (1.. maxCellineNB)) OF SEQUENCE {
	servedEUTRACellInfo					ServedCell-Information,
	nrNeighbourInfo						NRNeighbour-Information		OPTIONAL,
	iE-Extensions						ProtocolExtensionContainer { {ServedEUTRAcellsENDCX2Management-ExtIEs} } OPTIONAL,
	...
}
*/

struct ServedEUTRAcellsENDCX2ManagementList_elm : asn::sequence<3, 0, true, 2>
{
	static constexpr const char* name() {return "ServedEUTRAcellsENDCX2ManagementList_elm";}
	using parent_t = asn::sequence<3, 0, true, 2>;
	struct servedEUTRACellInfo_t : ServedCell_Information
	{
		static constexpr const char* name() {return "servedEUTRACellInfo_t";}
		using parent_t = ServedCell_Information;

	};
	servedEUTRACellInfo_t& ref_servedEUTRACellInfo() {return servedEUTRACellInfo;}
	servedEUTRACellInfo_t const& ref_servedEUTRACellInfo() const {return servedEUTRACellInfo;}
	struct nrNeighbourInfo_t : NRNeighbour_Information
	{
		static constexpr const char* name() {return "nrNeighbourInfo_t";}
		using parent_t = NRNeighbour_Information;
		static constexpr bool optional = true;

	};
	nrNeighbourInfo_t& set_nrNeighbourInfo() { nrNeighbourInfo.setpresent(true); return nrNeighbourInfo;}
	nrNeighbourInfo_t const* get_nrNeighbourInfo() const {return nrNeighbourInfo.is_valid() ? &nrNeighbourInfo : nullptr;}
	struct iE_Extensions_t : ProtocolExtensionContainer<ServedEUTRAcellsENDCX2Management_ExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<ServedEUTRAcellsENDCX2Management_ExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(servedEUTRACellInfo);
		v(nrNeighbourInfo);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(servedEUTRACellInfo);
		v(nrNeighbourInfo);
		v(iE_Extensions);

	};
	void clear()
	{
		servedEUTRACellInfo.clear();
		nrNeighbourInfo.clear();
		iE_Extensions.clear();

	};
	private:
	servedEUTRACellInfo_t	servedEUTRACellInfo;
	nrNeighbourInfo_t	nrNeighbourInfo;
	iE_Extensions_t	iE_Extensions;

};
struct ServedEUTRAcellsENDCX2ManagementList : asn::sequenceof<ServedEUTRAcellsENDCX2ManagementList_elm>
{
	static constexpr const char* name() {return "ServedEUTRAcellsENDCX2ManagementList";}
	using parent_t = asn::sequenceof<ServedEUTRAcellsENDCX2ManagementList_elm>;
	using constraint_t = asn::constraints<false,asn::span<1,  maxCellineNB >>;

};
/*
ServedEUTRAcellsToModifyListENDCConfUpd-ExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct ServedEUTRAcellsToModifyListENDCConfUpd_ExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
ServedEUTRAcellsToModifyListENDCConfUpd ::= SEQUENCE (SIZE (1.. maxCellineNB)) OF SEQUENCE {
	old-ECGI								ECGI,
	servedEUTRACellInfo					ServedCell-Information,
	nrNeighbourInfo						NRNeighbour-Information		OPTIONAL,
	iE-Extensions						ProtocolExtensionContainer { {ServedEUTRAcellsToModifyListENDCConfUpd-ExtIEs} } OPTIONAL,
	...
}
*/

struct ServedEUTRAcellsToModifyListENDCConfUpd_elm : asn::sequence<4, 0, true, 2>
{
	static constexpr const char* name() {return "ServedEUTRAcellsToModifyListENDCConfUpd_elm";}
	using parent_t = asn::sequence<4, 0, true, 2>;
	struct old_ECGI_t : ECGI
	{
		static constexpr const char* name() {return "old_ECGI_t";}
		using parent_t = ECGI;

	};
	old_ECGI_t& ref_old_ECGI() {return old_ECGI;}
	old_ECGI_t const& ref_old_ECGI() const {return old_ECGI;}
	struct servedEUTRACellInfo_t : ServedCell_Information
	{
		static constexpr const char* name() {return "servedEUTRACellInfo_t";}
		using parent_t = ServedCell_Information;

	};
	servedEUTRACellInfo_t& ref_servedEUTRACellInfo() {return servedEUTRACellInfo;}
	servedEUTRACellInfo_t const& ref_servedEUTRACellInfo() const {return servedEUTRACellInfo;}
	struct nrNeighbourInfo_t : NRNeighbour_Information
	{
		static constexpr const char* name() {return "nrNeighbourInfo_t";}
		using parent_t = NRNeighbour_Information;
		static constexpr bool optional = true;

	};
	nrNeighbourInfo_t& set_nrNeighbourInfo() { nrNeighbourInfo.setpresent(true); return nrNeighbourInfo;}
	nrNeighbourInfo_t const* get_nrNeighbourInfo() const {return nrNeighbourInfo.is_valid() ? &nrNeighbourInfo : nullptr;}
	struct iE_Extensions_t : ProtocolExtensionContainer<ServedEUTRAcellsToModifyListENDCConfUpd_ExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<ServedEUTRAcellsToModifyListENDCConfUpd_ExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(old_ECGI);
		v(servedEUTRACellInfo);
		v(nrNeighbourInfo);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(old_ECGI);
		v(servedEUTRACellInfo);
		v(nrNeighbourInfo);
		v(iE_Extensions);

	};
	void clear()
	{
		old_ECGI.clear();
		servedEUTRACellInfo.clear();
		nrNeighbourInfo.clear();
		iE_Extensions.clear();

	};
	private:
	old_ECGI_t	old_ECGI;
	servedEUTRACellInfo_t	servedEUTRACellInfo;
	nrNeighbourInfo_t	nrNeighbourInfo;
	iE_Extensions_t	iE_Extensions;

};
struct ServedEUTRAcellsToModifyListENDCConfUpd : asn::sequenceof<ServedEUTRAcellsToModifyListENDCConfUpd_elm>
{
	static constexpr const char* name() {return "ServedEUTRAcellsToModifyListENDCConfUpd";}
	using parent_t = asn::sequenceof<ServedEUTRAcellsToModifyListENDCConfUpd_elm>;
	using constraint_t = asn::constraints<false,asn::span<1,  maxCellineNB >>;

};
/*
ServedEUTRAcellsToDeleteListENDCConfUpd ::= SEQUENCE (SIZE (1..maxCellineNB)) OF ECGI
*/

struct ServedEUTRAcellsToDeleteListENDCConfUpd_elm : ECGI
{
	static constexpr const char* name() {return "ServedEUTRAcellsToDeleteListENDCConfUpd_elm";}
	using parent_t = ECGI;

};
struct ServedEUTRAcellsToDeleteListENDCConfUpd : asn::sequenceof<ServedEUTRAcellsToDeleteListENDCConfUpd_elm>
{
	static constexpr const char* name() {return "ServedEUTRAcellsToDeleteListENDCConfUpd";}
	using parent_t = asn::sequenceof<ServedEUTRAcellsToDeleteListENDCConfUpd_elm>;
	using constraint_t = asn::constraints<false,asn::span<1,  maxCellineNB >>;

};
/*
ENB-ENDCConfigUpdateIEs X2AP-PROTOCOL-IES ::= {
	{ ID id-CellAssistanceInformation				CRITICALITY reject	TYPE CellAssistanceInformation							PRESENCE optional }|
	{ ID id-ServedEUTRAcellsENDCX2ManagementList		CRITICALITY reject	TYPE ServedEUTRAcellsENDCX2ManagementList			PRESENCE optional }|
	{ ID id-ServedEUTRAcellsToModifyListENDCConfUpd	CRITICALITY reject	TYPE ServedEUTRAcellsToModifyListENDCConfUpd		PRESENCE optional }|
	{ ID id-ServedEUTRAcellsToDeleteListENDCConfUpd	CRITICALITY reject	TYPE ServedEUTRAcellsToDeleteListENDCConfUpd		PRESENCE optional },
	...
}
*/

struct ENB_ENDCConfigUpdateIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 5; }
		void clear() {type = 0;}
		void select_id_CellAssistanceInformation() { set(id_CellAssistanceInformation); type=1;}
		void select_id_ServedEUTRAcellsENDCX2ManagementList() { set(id_ServedEUTRAcellsENDCX2ManagementList); type=2;}
		void select_id_ServedEUTRAcellsToModifyListENDCConfUpd() { set(id_ServedEUTRAcellsToModifyListENDCConfUpd); type=3;}
		void select_id_ServedEUTRAcellsToDeleteListENDCConfUpd() { set(id_ServedEUTRAcellsToDeleteListENDCConfUpd); type=4;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_CellAssistanceInformation)) { type = 1; return true; }
			else if(equal(id_ServedEUTRAcellsENDCX2ManagementList)) { type = 2; return true; }
			else if(equal(id_ServedEUTRAcellsToModifyListENDCConfUpd)) { type = 3; return true; }
			else if(equal(id_ServedEUTRAcellsToDeleteListENDCConfUpd)) { type = 4; return true; }
			else { type = 5; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_CellAssistanceInformation);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_ServedEUTRAcellsENDCX2ManagementList);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_ServedEUTRAcellsToModifyListENDCConfUpd);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(id_ServedEUTRAcellsToDeleteListENDCConfUpd);} return false;
			case 5: type = 5; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 5; }
		void clear() {type = 0;}
		void select_id_CellAssistanceInformation() { set(reject); type=1;}
		void select_id_ServedEUTRAcellsENDCX2ManagementList() { set(reject); type=2;}
		void select_id_ServedEUTRAcellsToModifyListENDCConfUpd() { set(reject); type=3;}
		void select_id_ServedEUTRAcellsToDeleteListENDCConfUpd() { set(reject); type=4;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else if(equal(reject)) { type = 2; return true; }
			else if(equal(reject)) { type = 3; return true; }
			else if(equal(reject)) { type = 4; return true; }
			else { type = 5; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(reject);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(reject);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(reject);} return false;
			case 5: type = 5; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		CellAssistanceInformation& select_id_CellAssistanceInformation() { return set<CellAssistanceInformation>(1); }
		CellAssistanceInformation const* get_id_CellAssistanceInformation() const { return get<CellAssistanceInformation>(1); }
		ServedEUTRAcellsENDCX2ManagementList& select_id_ServedEUTRAcellsENDCX2ManagementList() { return set<ServedEUTRAcellsENDCX2ManagementList>(2); }
		ServedEUTRAcellsENDCX2ManagementList const* get_id_ServedEUTRAcellsENDCX2ManagementList() const { return get<ServedEUTRAcellsENDCX2ManagementList>(2); }
		ServedEUTRAcellsToModifyListENDCConfUpd& select_id_ServedEUTRAcellsToModifyListENDCConfUpd() { return set<ServedEUTRAcellsToModifyListENDCConfUpd>(3); }
		ServedEUTRAcellsToModifyListENDCConfUpd const* get_id_ServedEUTRAcellsToModifyListENDCConfUpd() const { return get<ServedEUTRAcellsToModifyListENDCConfUpd>(3); }
		ServedEUTRAcellsToDeleteListENDCConfUpd& select_id_ServedEUTRAcellsToDeleteListENDCConfUpd() { return set<ServedEUTRAcellsToDeleteListENDCConfUpd>(4); }
		ServedEUTRAcellsToDeleteListENDCConfUpd const* get_id_ServedEUTRAcellsToDeleteListENDCConfUpd() const { return get<ServedEUTRAcellsToDeleteListENDCConfUpd>(4); }
		bool is_unknown() const { return type == 5; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<CellAssistanceInformation>(); break;
			case 2: var.destroy<ServedEUTRAcellsENDCX2ManagementList>(); break;
			case 3: var.destroy<ServedEUTRAcellsToModifyListENDCConfUpd>(); break;
			case 4: var.destroy<ServedEUTRAcellsToDeleteListENDCConfUpd>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<CellAssistanceInformation>(1);
			v.template operator()<ServedEUTRAcellsENDCX2ManagementList>(2);
			v.template operator()<ServedEUTRAcellsToModifyListENDCConfUpd>(3);
			v.template operator()<ServedEUTRAcellsToDeleteListENDCConfUpd>(4);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_CellAssistanceInformation()); return true;
			case 2: v(select_id_ServedEUTRAcellsENDCX2ManagementList()); return true;
			case 3: v(select_id_ServedEUTRAcellsToModifyListENDCConfUpd()); return true;
			case 4: v(select_id_ServedEUTRAcellsToDeleteListENDCConfUpd()); return true;
			case 5: if(type != 5) {clear(); asn::base::set();} type = 5; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<CellAssistanceInformation>()); return true;
			case 2: v(var.as<ServedEUTRAcellsENDCX2ManagementList>()); return true;
			case 3: v(var.as<ServedEUTRAcellsToModifyListENDCConfUpd>()); return true;
			case 4: v(var.as<ServedEUTRAcellsToDeleteListENDCConfUpd>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(CellAssistanceInformation)];
			char dummy2[sizeof(ServedEUTRAcellsENDCX2ManagementList)];
			char dummy3[sizeof(ServedEUTRAcellsToDeleteListENDCConfUpd)];
			char dummy4[sizeof(ServedEUTRAcellsToModifyListENDCConfUpd)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 5; }
		void clear() {type = 0;}
		void select_id_CellAssistanceInformation() { set(optional); type=1;}
		void select_id_ServedEUTRAcellsENDCX2ManagementList() { set(optional); type=2;}
		void select_id_ServedEUTRAcellsToModifyListENDCConfUpd() { set(optional); type=3;}
		void select_id_ServedEUTRAcellsToDeleteListENDCConfUpd() { set(optional); type=4;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(optional)) { type = 1; return true; }
			else if(equal(optional)) { type = 2; return true; }
			else if(equal(optional)) { type = 3; return true; }
			else if(equal(optional)) { type = 4; return true; }
			else { type = 5; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(optional);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(optional);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(optional);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(optional);} return false;
			case 5: type = 5; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
ENB-ENDCX2RemovalReqAckIEs X2AP-PROTOCOL-IES ::= {
	{ ID id-GlobalENB-ID								CRITICALITY reject	TYPE GlobalENB-ID										PRESENCE mandatory},
	...
}
*/

struct ENB_ENDCX2RemovalReqAckIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_GlobalENB_ID() { set(id_GlobalENB_ID); type=1;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_GlobalENB_ID)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_GlobalENB_ID);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_GlobalENB_ID() { set(reject); type=1;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		GlobalENB_ID& select_id_GlobalENB_ID() { return set<GlobalENB_ID>(1); }
		GlobalENB_ID const* get_id_GlobalENB_ID() const { return get<GlobalENB_ID>(1); }
		bool is_unknown() const { return type == 2; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<GlobalENB_ID>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<GlobalENB_ID>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_GlobalENB_ID()); return true;
			case 2: if(type != 2) {clear(); asn::base::set();} type = 2; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<GlobalENB_ID>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(GlobalENB_ID)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_GlobalENB_ID() { set(mandatory); type=1;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
ENB-ENDCX2RemovalReqIEs X2AP-PROTOCOL-IES ::= {
	{ ID id-GlobalENB-ID								CRITICALITY reject	TYPE GlobalENB-ID										PRESENCE mandatory},
	...
}
*/

struct ENB_ENDCX2RemovalReqIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_GlobalENB_ID() { set(id_GlobalENB_ID); type=1;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_GlobalENB_ID)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_GlobalENB_ID);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_GlobalENB_ID() { set(reject); type=1;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		GlobalENB_ID& select_id_GlobalENB_ID() { return set<GlobalENB_ID>(1); }
		GlobalENB_ID const* get_id_GlobalENB_ID() const { return get<GlobalENB_ID>(1); }
		bool is_unknown() const { return type == 2; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<GlobalENB_ID>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<GlobalENB_ID>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_GlobalENB_ID()); return true;
			case 2: if(type != 2) {clear(); asn::base::set();} type = 2; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<GlobalENB_ID>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(GlobalENB_ID)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_GlobalENB_ID() { set(mandatory); type=1;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
ENB-ENDCX2SetupReqAckIEs X2AP-PROTOCOL-IES ::= {
	{ ID id-GlobalENB-ID								CRITICALITY reject	TYPE GlobalENB-ID										PRESENCE mandatory}|
	{ ID id-ServedEUTRAcellsENDCX2ManagementList		CRITICALITY reject	TYPE ServedEUTRAcellsENDCX2ManagementList		PRESENCE mandatory},
	...
}
*/

struct ENB_ENDCX2SetupReqAckIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 3; }
		void clear() {type = 0;}
		void select_id_GlobalENB_ID() { set(id_GlobalENB_ID); type=1;}
		void select_id_ServedEUTRAcellsENDCX2ManagementList() { set(id_ServedEUTRAcellsENDCX2ManagementList); type=2;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_GlobalENB_ID)) { type = 1; return true; }
			else if(equal(id_ServedEUTRAcellsENDCX2ManagementList)) { type = 2; return true; }
			else { type = 3; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_GlobalENB_ID);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_ServedEUTRAcellsENDCX2ManagementList);} return false;
			case 3: type = 3; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 3; }
		void clear() {type = 0;}
		void select_id_GlobalENB_ID() { set(reject); type=1;}
		void select_id_ServedEUTRAcellsENDCX2ManagementList() { set(reject); type=2;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else if(equal(reject)) { type = 2; return true; }
			else { type = 3; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(reject);} return false;
			case 3: type = 3; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		GlobalENB_ID& select_id_GlobalENB_ID() { return set<GlobalENB_ID>(1); }
		GlobalENB_ID const* get_id_GlobalENB_ID() const { return get<GlobalENB_ID>(1); }
		ServedEUTRAcellsENDCX2ManagementList& select_id_ServedEUTRAcellsENDCX2ManagementList() { return set<ServedEUTRAcellsENDCX2ManagementList>(2); }
		ServedEUTRAcellsENDCX2ManagementList const* get_id_ServedEUTRAcellsENDCX2ManagementList() const { return get<ServedEUTRAcellsENDCX2ManagementList>(2); }
		bool is_unknown() const { return type == 3; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<GlobalENB_ID>(); break;
			case 2: var.destroy<ServedEUTRAcellsENDCX2ManagementList>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<GlobalENB_ID>(1);
			v.template operator()<ServedEUTRAcellsENDCX2ManagementList>(2);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_GlobalENB_ID()); return true;
			case 2: v(select_id_ServedEUTRAcellsENDCX2ManagementList()); return true;
			case 3: if(type != 3) {clear(); asn::base::set();} type = 3; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<GlobalENB_ID>()); return true;
			case 2: v(var.as<ServedEUTRAcellsENDCX2ManagementList>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(GlobalENB_ID)];
			char dummy2[sizeof(ServedEUTRAcellsENDCX2ManagementList)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 3; }
		void clear() {type = 0;}
		void select_id_GlobalENB_ID() { set(mandatory); type=1;}
		void select_id_ServedEUTRAcellsENDCX2ManagementList() { set(mandatory); type=2;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(mandatory)) { type = 2; return true; }
			else { type = 3; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 3: type = 3; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
ENB-ENDCX2SetupReqIEs X2AP-PROTOCOL-IES ::= {
	{ ID id-GlobalENB-ID								CRITICALITY reject	TYPE GlobalENB-ID										PRESENCE mandatory}|
	{ ID id-ServedEUTRAcellsENDCX2ManagementList		CRITICALITY reject	TYPE ServedEUTRAcellsENDCX2ManagementList		PRESENCE mandatory},
	...
}
*/

struct ENB_ENDCX2SetupReqIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 3; }
		void clear() {type = 0;}
		void select_id_GlobalENB_ID() { set(id_GlobalENB_ID); type=1;}
		void select_id_ServedEUTRAcellsENDCX2ManagementList() { set(id_ServedEUTRAcellsENDCX2ManagementList); type=2;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_GlobalENB_ID)) { type = 1; return true; }
			else if(equal(id_ServedEUTRAcellsENDCX2ManagementList)) { type = 2; return true; }
			else { type = 3; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_GlobalENB_ID);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_ServedEUTRAcellsENDCX2ManagementList);} return false;
			case 3: type = 3; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 3; }
		void clear() {type = 0;}
		void select_id_GlobalENB_ID() { set(reject); type=1;}
		void select_id_ServedEUTRAcellsENDCX2ManagementList() { set(reject); type=2;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else if(equal(reject)) { type = 2; return true; }
			else { type = 3; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(reject);} return false;
			case 3: type = 3; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		GlobalENB_ID& select_id_GlobalENB_ID() { return set<GlobalENB_ID>(1); }
		GlobalENB_ID const* get_id_GlobalENB_ID() const { return get<GlobalENB_ID>(1); }
		ServedEUTRAcellsENDCX2ManagementList& select_id_ServedEUTRAcellsENDCX2ManagementList() { return set<ServedEUTRAcellsENDCX2ManagementList>(2); }
		ServedEUTRAcellsENDCX2ManagementList const* get_id_ServedEUTRAcellsENDCX2ManagementList() const { return get<ServedEUTRAcellsENDCX2ManagementList>(2); }
		bool is_unknown() const { return type == 3; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<GlobalENB_ID>(); break;
			case 2: var.destroy<ServedEUTRAcellsENDCX2ManagementList>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<GlobalENB_ID>(1);
			v.template operator()<ServedEUTRAcellsENDCX2ManagementList>(2);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_GlobalENB_ID()); return true;
			case 2: v(select_id_ServedEUTRAcellsENDCX2ManagementList()); return true;
			case 3: if(type != 3) {clear(); asn::base::set();} type = 3; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<GlobalENB_ID>()); return true;
			case 2: v(var.as<ServedEUTRAcellsENDCX2ManagementList>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(GlobalENB_ID)];
			char dummy2[sizeof(ServedEUTRAcellsENDCX2ManagementList)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 3; }
		void clear() {type = 0;}
		void select_id_GlobalENB_ID() { set(mandatory); type=1;}
		void select_id_ServedEUTRAcellsENDCX2ManagementList() { set(mandatory); type=2;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(mandatory)) { type = 2; return true; }
			else { type = 3; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 3: type = 3; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
ListofEUTRACellsinEUTRACoordinationResp ::= SEQUENCE (SIZE (0..maxCellineNB)) OF ECGI
*/

struct ListofEUTRACellsinEUTRACoordinationResp_elm : ECGI
{
	static constexpr const char* name() {return "ListofEUTRACellsinEUTRACoordinationResp_elm";}
	using parent_t = ECGI;

};
struct ListofEUTRACellsinEUTRACoordinationResp : asn::sequenceof<ListofEUTRACellsinEUTRACoordinationResp_elm>
{
	static constexpr const char* name() {return "ListofEUTRACellsinEUTRACoordinationResp";}
	using parent_t = asn::sequenceof<ListofEUTRACellsinEUTRACoordinationResp_elm>;
	using constraint_t = asn::constraints<false,asn::span<0,  maxCellineNB >>;

};
/*
ENB-EUTRA-NRCellResourceCoordinationReqAckIEs X2AP-PROTOCOL-IES ::= {
	{ ID id-DataTrafficResourceIndication				CRITICALITY reject	TYPE DataTrafficResourceIndication				PRESENCE mandatory}|
	{ ID id-SpectrumSharingGroupID						CRITICALITY reject	TYPE SpectrumSharingGroupID							PRESENCE mandatory}|
	{ ID id-ListofEUTRACellsinEUTRACoordinationResp		CRITICALITY reject	TYPE ListofEUTRACellsinEUTRACoordinationResp	PRESENCE mandatory},
	...
}
*/

struct ENB_EUTRA_NRCellResourceCoordinationReqAckIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 4; }
		void clear() {type = 0;}
		void select_id_DataTrafficResourceIndication() { set(id_DataTrafficResourceIndication); type=1;}
		void select_id_SpectrumSharingGroupID() { set(id_SpectrumSharingGroupID); type=2;}
		void select_id_ListofEUTRACellsinEUTRACoordinationResp() { set(id_ListofEUTRACellsinEUTRACoordinationResp); type=3;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_DataTrafficResourceIndication)) { type = 1; return true; }
			else if(equal(id_SpectrumSharingGroupID)) { type = 2; return true; }
			else if(equal(id_ListofEUTRACellsinEUTRACoordinationResp)) { type = 3; return true; }
			else { type = 4; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_DataTrafficResourceIndication);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_SpectrumSharingGroupID);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_ListofEUTRACellsinEUTRACoordinationResp);} return false;
			case 4: type = 4; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 4; }
		void clear() {type = 0;}
		void select_id_DataTrafficResourceIndication() { set(reject); type=1;}
		void select_id_SpectrumSharingGroupID() { set(reject); type=2;}
		void select_id_ListofEUTRACellsinEUTRACoordinationResp() { set(reject); type=3;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else if(equal(reject)) { type = 2; return true; }
			else if(equal(reject)) { type = 3; return true; }
			else { type = 4; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(reject);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(reject);} return false;
			case 4: type = 4; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		DataTrafficResourceIndication& select_id_DataTrafficResourceIndication() { return set<DataTrafficResourceIndication>(1); }
		DataTrafficResourceIndication const* get_id_DataTrafficResourceIndication() const { return get<DataTrafficResourceIndication>(1); }
		SpectrumSharingGroupID& select_id_SpectrumSharingGroupID() { return set<SpectrumSharingGroupID>(2); }
		SpectrumSharingGroupID const* get_id_SpectrumSharingGroupID() const { return get<SpectrumSharingGroupID>(2); }
		ListofEUTRACellsinEUTRACoordinationResp& select_id_ListofEUTRACellsinEUTRACoordinationResp() { return set<ListofEUTRACellsinEUTRACoordinationResp>(3); }
		ListofEUTRACellsinEUTRACoordinationResp const* get_id_ListofEUTRACellsinEUTRACoordinationResp() const { return get<ListofEUTRACellsinEUTRACoordinationResp>(3); }
		bool is_unknown() const { return type == 4; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<DataTrafficResourceIndication>(); break;
			case 2: var.destroy<SpectrumSharingGroupID>(); break;
			case 3: var.destroy<ListofEUTRACellsinEUTRACoordinationResp>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<DataTrafficResourceIndication>(1);
			v.template operator()<SpectrumSharingGroupID>(2);
			v.template operator()<ListofEUTRACellsinEUTRACoordinationResp>(3);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_DataTrafficResourceIndication()); return true;
			case 2: v(select_id_SpectrumSharingGroupID()); return true;
			case 3: v(select_id_ListofEUTRACellsinEUTRACoordinationResp()); return true;
			case 4: if(type != 4) {clear(); asn::base::set();} type = 4; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<DataTrafficResourceIndication>()); return true;
			case 2: v(var.as<SpectrumSharingGroupID>()); return true;
			case 3: v(var.as<ListofEUTRACellsinEUTRACoordinationResp>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(DataTrafficResourceIndication)];
			char dummy2[sizeof(ListofEUTRACellsinEUTRACoordinationResp)];
			char dummy3[sizeof(SpectrumSharingGroupID)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 4; }
		void clear() {type = 0;}
		void select_id_DataTrafficResourceIndication() { set(mandatory); type=1;}
		void select_id_SpectrumSharingGroupID() { set(mandatory); type=2;}
		void select_id_ListofEUTRACellsinEUTRACoordinationResp() { set(mandatory); type=3;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(mandatory)) { type = 2; return true; }
			else if(equal(mandatory)) { type = 3; return true; }
			else { type = 4; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 4: type = 4; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
ListofEUTRACellsinEUTRACoordinationReq ::= SEQUENCE (SIZE (0..maxCellineNB)) OF ECGI
*/

struct ListofEUTRACellsinEUTRACoordinationReq_elm : ECGI
{
	static constexpr const char* name() {return "ListofEUTRACellsinEUTRACoordinationReq_elm";}
	using parent_t = ECGI;

};
struct ListofEUTRACellsinEUTRACoordinationReq : asn::sequenceof<ListofEUTRACellsinEUTRACoordinationReq_elm>
{
	static constexpr const char* name() {return "ListofEUTRACellsinEUTRACoordinationReq";}
	using parent_t = asn::sequenceof<ListofEUTRACellsinEUTRACoordinationReq_elm>;
	using constraint_t = asn::constraints<false,asn::span<0,  maxCellineNB >>;

};
/*
ENB-EUTRA-NRCellResourceCoordinationReqIEs X2AP-PROTOCOL-IES ::= {
	{ ID id-DataTrafficResourceIndication			CRITICALITY reject	TYPE DataTrafficResourceIndication					PRESENCE mandatory}|
	{ ID id-SpectrumSharingGroupID					CRITICALITY reject	TYPE SpectrumSharingGroupID							PRESENCE mandatory}|
	{ ID id-ListofEUTRACellsinEUTRACoordinationReq	CRITICALITY reject	TYPE ListofEUTRACellsinEUTRACoordinationReq		PRESENCE mandatory},
	...
}
*/

struct ENB_EUTRA_NRCellResourceCoordinationReqIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 4; }
		void clear() {type = 0;}
		void select_id_DataTrafficResourceIndication() { set(id_DataTrafficResourceIndication); type=1;}
		void select_id_SpectrumSharingGroupID() { set(id_SpectrumSharingGroupID); type=2;}
		void select_id_ListofEUTRACellsinEUTRACoordinationReq() { set(id_ListofEUTRACellsinEUTRACoordinationReq); type=3;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_DataTrafficResourceIndication)) { type = 1; return true; }
			else if(equal(id_SpectrumSharingGroupID)) { type = 2; return true; }
			else if(equal(id_ListofEUTRACellsinEUTRACoordinationReq)) { type = 3; return true; }
			else { type = 4; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_DataTrafficResourceIndication);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_SpectrumSharingGroupID);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_ListofEUTRACellsinEUTRACoordinationReq);} return false;
			case 4: type = 4; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 4; }
		void clear() {type = 0;}
		void select_id_DataTrafficResourceIndication() { set(reject); type=1;}
		void select_id_SpectrumSharingGroupID() { set(reject); type=2;}
		void select_id_ListofEUTRACellsinEUTRACoordinationReq() { set(reject); type=3;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else if(equal(reject)) { type = 2; return true; }
			else if(equal(reject)) { type = 3; return true; }
			else { type = 4; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(reject);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(reject);} return false;
			case 4: type = 4; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		DataTrafficResourceIndication& select_id_DataTrafficResourceIndication() { return set<DataTrafficResourceIndication>(1); }
		DataTrafficResourceIndication const* get_id_DataTrafficResourceIndication() const { return get<DataTrafficResourceIndication>(1); }
		SpectrumSharingGroupID& select_id_SpectrumSharingGroupID() { return set<SpectrumSharingGroupID>(2); }
		SpectrumSharingGroupID const* get_id_SpectrumSharingGroupID() const { return get<SpectrumSharingGroupID>(2); }
		ListofEUTRACellsinEUTRACoordinationReq& select_id_ListofEUTRACellsinEUTRACoordinationReq() { return set<ListofEUTRACellsinEUTRACoordinationReq>(3); }
		ListofEUTRACellsinEUTRACoordinationReq const* get_id_ListofEUTRACellsinEUTRACoordinationReq() const { return get<ListofEUTRACellsinEUTRACoordinationReq>(3); }
		bool is_unknown() const { return type == 4; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<DataTrafficResourceIndication>(); break;
			case 2: var.destroy<SpectrumSharingGroupID>(); break;
			case 3: var.destroy<ListofEUTRACellsinEUTRACoordinationReq>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<DataTrafficResourceIndication>(1);
			v.template operator()<SpectrumSharingGroupID>(2);
			v.template operator()<ListofEUTRACellsinEUTRACoordinationReq>(3);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_DataTrafficResourceIndication()); return true;
			case 2: v(select_id_SpectrumSharingGroupID()); return true;
			case 3: v(select_id_ListofEUTRACellsinEUTRACoordinationReq()); return true;
			case 4: if(type != 4) {clear(); asn::base::set();} type = 4; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<DataTrafficResourceIndication>()); return true;
			case 2: v(var.as<SpectrumSharingGroupID>()); return true;
			case 3: v(var.as<ListofEUTRACellsinEUTRACoordinationReq>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(DataTrafficResourceIndication)];
			char dummy2[sizeof(ListofEUTRACellsinEUTRACoordinationReq)];
			char dummy3[sizeof(SpectrumSharingGroupID)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 4; }
		void clear() {type = 0;}
		void select_id_DataTrafficResourceIndication() { set(mandatory); type=1;}
		void select_id_SpectrumSharingGroupID() { set(mandatory); type=2;}
		void select_id_ListofEUTRACellsinEUTRACoordinationReq() { set(mandatory); type=3;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(mandatory)) { type = 2; return true; }
			else if(equal(mandatory)) { type = 3; return true; }
			else { type = 4; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 4: type = 4; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
ServedCellsToModify-Item-ExtIEs X2AP-PROTOCOL-EXTENSION ::= {
{ ID id-DeactivationIndication			CRITICALITY ignore	EXTENSION DeactivationIndication				PRESENCE optional },
	...
}
*/

struct ServedCellsToModify_Item_ExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_DeactivationIndication() { set(id_DeactivationIndication); type=1;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_DeactivationIndication)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_DeactivationIndication);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_DeactivationIndication() { set(ignore); type=1;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		DeactivationIndication& select_id_DeactivationIndication() { return set<DeactivationIndication>(1); }
		DeactivationIndication const* get_id_DeactivationIndication() const { return get<DeactivationIndication>(1); }
		bool is_unknown() const { return type == 2; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<DeactivationIndication>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<DeactivationIndication>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_DeactivationIndication()); return true;
			case 2: if(type != 2) {clear(); asn::base::set();} type = 2; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<DeactivationIndication>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(DeactivationIndication)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_DeactivationIndication() { set(optional); type=1;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(optional)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(optional);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
ServedCellsToModify-Item::= SEQUENCE {
	old-ecgi						ECGI,
	servedCellInfo					ServedCell-Information,
	neighbour-Info					Neighbour-Information			OPTIONAL,
	iE-Extensions					ProtocolExtensionContainer { {ServedCellsToModify-Item-ExtIEs} } OPTIONAL,
	...
}
*/

struct ServedCellsToModify_Item : asn::sequence<4, 0, true, 2>
{
	static constexpr const char* name() {return "ServedCellsToModify-Item";}
	using parent_t = asn::sequence<4, 0, true, 2>;
	struct old_ecgi_t : ECGI
	{
		static constexpr const char* name() {return "old_ecgi_t";}
		using parent_t = ECGI;

	};
	old_ecgi_t& ref_old_ecgi() {return old_ecgi;}
	old_ecgi_t const& ref_old_ecgi() const {return old_ecgi;}
	struct servedCellInfo_t : ServedCell_Information
	{
		static constexpr const char* name() {return "servedCellInfo_t";}
		using parent_t = ServedCell_Information;

	};
	servedCellInfo_t& ref_servedCellInfo() {return servedCellInfo;}
	servedCellInfo_t const& ref_servedCellInfo() const {return servedCellInfo;}
	struct neighbour_Info_t : Neighbour_Information
	{
		static constexpr const char* name() {return "neighbour_Info_t";}
		using parent_t = Neighbour_Information;
		static constexpr bool optional = true;

	};
	neighbour_Info_t& set_neighbour_Info() { neighbour_Info.setpresent(true); return neighbour_Info;}
	neighbour_Info_t const* get_neighbour_Info() const {return neighbour_Info.is_valid() ? &neighbour_Info : nullptr;}
	struct iE_Extensions_t : ProtocolExtensionContainer<ServedCellsToModify_Item_ExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<ServedCellsToModify_Item_ExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(old_ecgi);
		v(servedCellInfo);
		v(neighbour_Info);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(old_ecgi);
		v(servedCellInfo);
		v(neighbour_Info);
		v(iE_Extensions);

	};
	void clear()
	{
		old_ecgi.clear();
		servedCellInfo.clear();
		neighbour_Info.clear();
		iE_Extensions.clear();

	};
	private:
	old_ecgi_t	old_ecgi;
	servedCellInfo_t	servedCellInfo;
	neighbour_Info_t	neighbour_Info;
	iE_Extensions_t	iE_Extensions;

};
/*
ServedCellsToModify::= SEQUENCE (SIZE (1..maxCellineNB)) OF ServedCellsToModify-Item
*/

struct ServedCellsToModify_elm : ServedCellsToModify_Item
{
	static constexpr const char* name() {return "ServedCellsToModify_elm";}
	using parent_t = ServedCellsToModify_Item;

};
struct ServedCellsToModify : asn::sequenceof<ServedCellsToModify_elm>
{
	static constexpr const char* name() {return "ServedCellsToModify";}
	using parent_t = asn::sequenceof<ServedCellsToModify_elm>;
	using constraint_t = asn::constraints<false,asn::span<1,  maxCellineNB >>;

};
/*
Old-ECGIs::= SEQUENCE (SIZE (1..maxCellineNB)) OF ECGI
*/

struct Old_ECGIs_elm : ECGI
{
	static constexpr const char* name() {return "Old_ECGIs_elm";}
	using parent_t = ECGI;

};
struct Old_ECGIs : asn::sequenceof<Old_ECGIs_elm>
{
	static constexpr const char* name() {return "Old-ECGIs";}
	using parent_t = asn::sequenceof<Old_ECGIs_elm>;
	using constraint_t = asn::constraints<false,asn::span<1,  maxCellineNB >>;

};
/*
ENBConfigurationUpdate-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-ServedCellsToAdd			CRITICALITY reject	TYPE ServedCells					PRESENCE optional}|
	{ ID id-ServedCellsToModify			CRITICALITY reject	TYPE ServedCellsToModify			PRESENCE optional}|
	{ ID id-ServedCellsToDelete			CRITICALITY reject	TYPE Old-ECGIs						PRESENCE optional}|
	{ ID id-GUGroupIDToAddList			CRITICALITY reject	TYPE GUGroupIDList					PRESENCE optional}|
	{ ID id-GUGroupIDToDeleteList		CRITICALITY reject	TYPE GUGroupIDList					PRESENCE optional}|
	{ ID id-CoverageModificationList	CRITICALITY reject	TYPE CoverageModificationList		PRESENCE optional},
	...
}
*/

struct ENBConfigurationUpdate_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 7; }
		void clear() {type = 0;}
		void select_id_ServedCellsToAdd() { set(id_ServedCellsToAdd); type=1;}
		void select_id_ServedCellsToModify() { set(id_ServedCellsToModify); type=2;}
		void select_id_ServedCellsToDelete() { set(id_ServedCellsToDelete); type=3;}
		void select_id_GUGroupIDToAddList() { set(id_GUGroupIDToAddList); type=4;}
		void select_id_GUGroupIDToDeleteList() { set(id_GUGroupIDToDeleteList); type=5;}
		void select_id_CoverageModificationList() { set(id_CoverageModificationList); type=6;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_ServedCellsToAdd)) { type = 1; return true; }
			else if(equal(id_ServedCellsToModify)) { type = 2; return true; }
			else if(equal(id_ServedCellsToDelete)) { type = 3; return true; }
			else if(equal(id_GUGroupIDToAddList)) { type = 4; return true; }
			else if(equal(id_GUGroupIDToDeleteList)) { type = 5; return true; }
			else if(equal(id_CoverageModificationList)) { type = 6; return true; }
			else { type = 7; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_ServedCellsToAdd);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_ServedCellsToModify);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_ServedCellsToDelete);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(id_GUGroupIDToAddList);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(id_GUGroupIDToDeleteList);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(id_CoverageModificationList);} return false;
			case 7: type = 7; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 7; }
		void clear() {type = 0;}
		void select_id_ServedCellsToAdd() { set(reject); type=1;}
		void select_id_ServedCellsToModify() { set(reject); type=2;}
		void select_id_ServedCellsToDelete() { set(reject); type=3;}
		void select_id_GUGroupIDToAddList() { set(reject); type=4;}
		void select_id_GUGroupIDToDeleteList() { set(reject); type=5;}
		void select_id_CoverageModificationList() { set(reject); type=6;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else if(equal(reject)) { type = 2; return true; }
			else if(equal(reject)) { type = 3; return true; }
			else if(equal(reject)) { type = 4; return true; }
			else if(equal(reject)) { type = 5; return true; }
			else if(equal(reject)) { type = 6; return true; }
			else { type = 7; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(reject);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(reject);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(reject);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(reject);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(reject);} return false;
			case 7: type = 7; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		ServedCells& select_id_ServedCellsToAdd() { return set<ServedCells>(1); }
		ServedCells const* get_id_ServedCellsToAdd() const { return get<ServedCells>(1); }
		ServedCellsToModify& select_id_ServedCellsToModify() { return set<ServedCellsToModify>(2); }
		ServedCellsToModify const* get_id_ServedCellsToModify() const { return get<ServedCellsToModify>(2); }
		Old_ECGIs& select_id_ServedCellsToDelete() { return set<Old_ECGIs>(3); }
		Old_ECGIs const* get_id_ServedCellsToDelete() const { return get<Old_ECGIs>(3); }
		GUGroupIDList& select_id_GUGroupIDToAddList() { return set<GUGroupIDList>(4); }
		GUGroupIDList const* get_id_GUGroupIDToAddList() const { return get<GUGroupIDList>(4); }
		GUGroupIDList& select_id_GUGroupIDToDeleteList() { return set<GUGroupIDList>(5); }
		GUGroupIDList const* get_id_GUGroupIDToDeleteList() const { return get<GUGroupIDList>(5); }
		CoverageModificationList& select_id_CoverageModificationList() { return set<CoverageModificationList>(6); }
		CoverageModificationList const* get_id_CoverageModificationList() const { return get<CoverageModificationList>(6); }
		bool is_unknown() const { return type == 7; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<ServedCells>(); break;
			case 2: var.destroy<ServedCellsToModify>(); break;
			case 3: var.destroy<Old_ECGIs>(); break;
			case 4: var.destroy<GUGroupIDList>(); break;
			case 5: var.destroy<GUGroupIDList>(); break;
			case 6: var.destroy<CoverageModificationList>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<ServedCells>(1);
			v.template operator()<ServedCellsToModify>(2);
			v.template operator()<Old_ECGIs>(3);
			v.template operator()<GUGroupIDList>(4);
			v.template operator()<GUGroupIDList>(5);
			v.template operator()<CoverageModificationList>(6);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_ServedCellsToAdd()); return true;
			case 2: v(select_id_ServedCellsToModify()); return true;
			case 3: v(select_id_ServedCellsToDelete()); return true;
			case 4: v(select_id_GUGroupIDToAddList()); return true;
			case 5: v(select_id_GUGroupIDToDeleteList()); return true;
			case 6: v(select_id_CoverageModificationList()); return true;
			case 7: if(type != 7) {clear(); asn::base::set();} type = 7; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<ServedCells>()); return true;
			case 2: v(var.as<ServedCellsToModify>()); return true;
			case 3: v(var.as<Old_ECGIs>()); return true;
			case 4: v(var.as<GUGroupIDList>()); return true;
			case 5: v(var.as<GUGroupIDList>()); return true;
			case 6: v(var.as<CoverageModificationList>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(CoverageModificationList)];
			char dummy2[sizeof(GUGroupIDList)];
			char dummy3[sizeof(Old_ECGIs)];
			char dummy4[sizeof(ServedCells)];
			char dummy5[sizeof(ServedCellsToModify)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 7; }
		void clear() {type = 0;}
		void select_id_ServedCellsToAdd() { set(optional); type=1;}
		void select_id_ServedCellsToModify() { set(optional); type=2;}
		void select_id_ServedCellsToDelete() { set(optional); type=3;}
		void select_id_GUGroupIDToAddList() { set(optional); type=4;}
		void select_id_GUGroupIDToDeleteList() { set(optional); type=5;}
		void select_id_CoverageModificationList() { set(optional); type=6;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(optional)) { type = 1; return true; }
			else if(equal(optional)) { type = 2; return true; }
			else if(equal(optional)) { type = 3; return true; }
			else if(equal(optional)) { type = 4; return true; }
			else if(equal(optional)) { type = 5; return true; }
			else if(equal(optional)) { type = 6; return true; }
			else { type = 7; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(optional);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(optional);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(optional);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(optional);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(optional);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(optional);} return false;
			case 7: type = 7; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
ENBConfigurationUpdate ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{ENBConfigurationUpdate-IEs}},
	...
}
*/

struct ENBConfigurationUpdate : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "ENBConfigurationUpdate";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<ENBConfigurationUpdate_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<ENBConfigurationUpdate_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
ENBConfigurationUpdateAcknowledge-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-CriticalityDiagnostics		CRITICALITY ignore	TYPE CriticalityDiagnostics			PRESENCE optional},
...
}
*/

struct ENBConfigurationUpdateAcknowledge_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_CriticalityDiagnostics() { set(id_CriticalityDiagnostics); type=1;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_CriticalityDiagnostics)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_CriticalityDiagnostics);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_CriticalityDiagnostics() { set(ignore); type=1;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		CriticalityDiagnostics& select_id_CriticalityDiagnostics() { return set<CriticalityDiagnostics>(1); }
		CriticalityDiagnostics const* get_id_CriticalityDiagnostics() const { return get<CriticalityDiagnostics>(1); }
		bool is_unknown() const { return type == 2; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<CriticalityDiagnostics>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<CriticalityDiagnostics>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_CriticalityDiagnostics()); return true;
			case 2: if(type != 2) {clear(); asn::base::set();} type = 2; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<CriticalityDiagnostics>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(CriticalityDiagnostics)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_CriticalityDiagnostics() { set(optional); type=1;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(optional)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(optional);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
ENBConfigurationUpdateAcknowledge ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{ENBConfigurationUpdateAcknowledge-IEs}},
	...
}
*/

struct ENBConfigurationUpdateAcknowledge : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "ENBConfigurationUpdateAcknowledge";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<ENBConfigurationUpdateAcknowledge_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<ENBConfigurationUpdateAcknowledge_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
ENBConfigurationUpdateFailure-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-Cause						CRITICALITY ignore	TYPE Cause						PRESENCE mandatory}|
	{ ID id-TimeToWait					CRITICALITY ignore	TYPE TimeToWait					PRESENCE optional}|
	{ ID id-CriticalityDiagnostics		CRITICALITY ignore	TYPE CriticalityDiagnostics		PRESENCE optional},
	...
}
*/

struct ENBConfigurationUpdateFailure_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 4; }
		void clear() {type = 0;}
		void select_id_Cause() { set(id_Cause); type=1;}
		void select_id_TimeToWait() { set(id_TimeToWait); type=2;}
		void select_id_CriticalityDiagnostics() { set(id_CriticalityDiagnostics); type=3;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_Cause)) { type = 1; return true; }
			else if(equal(id_TimeToWait)) { type = 2; return true; }
			else if(equal(id_CriticalityDiagnostics)) { type = 3; return true; }
			else { type = 4; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_Cause);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_TimeToWait);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_CriticalityDiagnostics);} return false;
			case 4: type = 4; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 4; }
		void clear() {type = 0;}
		void select_id_Cause() { set(ignore); type=1;}
		void select_id_TimeToWait() { set(ignore); type=2;}
		void select_id_CriticalityDiagnostics() { set(ignore); type=3;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else if(equal(ignore)) { type = 2; return true; }
			else if(equal(ignore)) { type = 3; return true; }
			else { type = 4; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(ignore);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(ignore);} return false;
			case 4: type = 4; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		Cause& select_id_Cause() { return set<Cause>(1); }
		Cause const* get_id_Cause() const { return get<Cause>(1); }
		TimeToWait& select_id_TimeToWait() { return set<TimeToWait>(2); }
		TimeToWait const* get_id_TimeToWait() const { return get<TimeToWait>(2); }
		CriticalityDiagnostics& select_id_CriticalityDiagnostics() { return set<CriticalityDiagnostics>(3); }
		CriticalityDiagnostics const* get_id_CriticalityDiagnostics() const { return get<CriticalityDiagnostics>(3); }
		bool is_unknown() const { return type == 4; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<Cause>(); break;
			case 2: var.destroy<TimeToWait>(); break;
			case 3: var.destroy<CriticalityDiagnostics>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<Cause>(1);
			v.template operator()<TimeToWait>(2);
			v.template operator()<CriticalityDiagnostics>(3);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_Cause()); return true;
			case 2: v(select_id_TimeToWait()); return true;
			case 3: v(select_id_CriticalityDiagnostics()); return true;
			case 4: if(type != 4) {clear(); asn::base::set();} type = 4; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<Cause>()); return true;
			case 2: v(var.as<TimeToWait>()); return true;
			case 3: v(var.as<CriticalityDiagnostics>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(Cause)];
			char dummy2[sizeof(CriticalityDiagnostics)];
			char dummy3[sizeof(TimeToWait)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 4; }
		void clear() {type = 0;}
		void select_id_Cause() { set(mandatory); type=1;}
		void select_id_TimeToWait() { set(optional); type=2;}
		void select_id_CriticalityDiagnostics() { set(optional); type=3;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(optional)) { type = 2; return true; }
			else if(equal(optional)) { type = 3; return true; }
			else { type = 4; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(optional);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(optional);} return false;
			case 4: type = 4; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
ENBConfigurationUpdateFailure ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{ENBConfigurationUpdateFailure-IEs}},
	...
}
*/

struct ENBConfigurationUpdateFailure : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "ENBConfigurationUpdateFailure";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<ENBConfigurationUpdateFailure_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<ENBConfigurationUpdateFailure_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
ENDCCellActivationFailure-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-ActivationID					CRITICALITY reject	TYPE ActivationID				PRESENCE mandatory }|
	{ ID id-Cause						CRITICALITY ignore	TYPE Cause						PRESENCE mandatory }|
	{ ID id-CriticalityDiagnostics		CRITICALITY ignore	TYPE CriticalityDiagnostics		PRESENCE optional },
	...
}
*/

struct ENDCCellActivationFailure_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 4; }
		void clear() {type = 0;}
		void select_id_ActivationID() { set(id_ActivationID); type=1;}
		void select_id_Cause() { set(id_Cause); type=2;}
		void select_id_CriticalityDiagnostics() { set(id_CriticalityDiagnostics); type=3;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_ActivationID)) { type = 1; return true; }
			else if(equal(id_Cause)) { type = 2; return true; }
			else if(equal(id_CriticalityDiagnostics)) { type = 3; return true; }
			else { type = 4; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_ActivationID);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_Cause);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_CriticalityDiagnostics);} return false;
			case 4: type = 4; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 4; }
		void clear() {type = 0;}
		void select_id_ActivationID() { set(reject); type=1;}
		void select_id_Cause() { set(ignore); type=2;}
		void select_id_CriticalityDiagnostics() { set(ignore); type=3;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else if(equal(ignore)) { type = 2; return true; }
			else if(equal(ignore)) { type = 3; return true; }
			else { type = 4; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(ignore);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(ignore);} return false;
			case 4: type = 4; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		ActivationID& select_id_ActivationID() { return set<ActivationID>(1); }
		ActivationID const* get_id_ActivationID() const { return get<ActivationID>(1); }
		Cause& select_id_Cause() { return set<Cause>(2); }
		Cause const* get_id_Cause() const { return get<Cause>(2); }
		CriticalityDiagnostics& select_id_CriticalityDiagnostics() { return set<CriticalityDiagnostics>(3); }
		CriticalityDiagnostics const* get_id_CriticalityDiagnostics() const { return get<CriticalityDiagnostics>(3); }
		bool is_unknown() const { return type == 4; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<ActivationID>(); break;
			case 2: var.destroy<Cause>(); break;
			case 3: var.destroy<CriticalityDiagnostics>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<ActivationID>(1);
			v.template operator()<Cause>(2);
			v.template operator()<CriticalityDiagnostics>(3);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_ActivationID()); return true;
			case 2: v(select_id_Cause()); return true;
			case 3: v(select_id_CriticalityDiagnostics()); return true;
			case 4: if(type != 4) {clear(); asn::base::set();} type = 4; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<ActivationID>()); return true;
			case 2: v(var.as<Cause>()); return true;
			case 3: v(var.as<CriticalityDiagnostics>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(ActivationID)];
			char dummy2[sizeof(Cause)];
			char dummy3[sizeof(CriticalityDiagnostics)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 4; }
		void clear() {type = 0;}
		void select_id_ActivationID() { set(mandatory); type=1;}
		void select_id_Cause() { set(mandatory); type=2;}
		void select_id_CriticalityDiagnostics() { set(optional); type=3;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(mandatory)) { type = 2; return true; }
			else if(equal(optional)) { type = 3; return true; }
			else { type = 4; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(optional);} return false;
			case 4: type = 4; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
ENDCCellActivationFailure ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{ENDCCellActivationFailure-IEs}},
	...
}
*/

struct ENDCCellActivationFailure : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "ENDCCellActivationFailure";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<ENDCCellActivationFailure_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<ENDCCellActivationFailure_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
ServedNRCellsToActivate-Item-ExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct ServedNRCellsToActivate_Item_ExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
ServedNRCellsToActivate-Item::= SEQUENCE {
	nrCellID						NRCGI,
	iE-Extensions					ProtocolExtensionContainer { {ServedNRCellsToActivate-Item-ExtIEs} } OPTIONAL,
	...
}
*/

struct ServedNRCellsToActivate_Item : asn::sequence<2, 0, true, 1>
{
	static constexpr const char* name() {return "ServedNRCellsToActivate-Item";}
	using parent_t = asn::sequence<2, 0, true, 1>;
	struct nrCellID_t : NRCGI
	{
		static constexpr const char* name() {return "nrCellID_t";}
		using parent_t = NRCGI;

	};
	nrCellID_t& ref_nrCellID() {return nrCellID;}
	nrCellID_t const& ref_nrCellID() const {return nrCellID;}
	struct iE_Extensions_t : ProtocolExtensionContainer<ServedNRCellsToActivate_Item_ExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<ServedNRCellsToActivate_Item_ExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(nrCellID);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(nrCellID);
		v(iE_Extensions);

	};
	void clear()
	{
		nrCellID.clear();
		iE_Extensions.clear();

	};
	private:
	nrCellID_t	nrCellID;
	iE_Extensions_t	iE_Extensions;

};
/*
ServedNRCellsToActivate::= SEQUENCE (SIZE (1.. maxCellinengNB)) OF ServedNRCellsToActivate-Item
*/

struct ServedNRCellsToActivate_elm : ServedNRCellsToActivate_Item
{
	static constexpr const char* name() {return "ServedNRCellsToActivate_elm";}
	using parent_t = ServedNRCellsToActivate_Item;

};
struct ServedNRCellsToActivate : asn::sequenceof<ServedNRCellsToActivate_elm>
{
	static constexpr const char* name() {return "ServedNRCellsToActivate";}
	using parent_t = asn::sequenceof<ServedNRCellsToActivate_elm>;
	using constraint_t = asn::constraints<false,asn::span<1,  maxCellinengNB >>;

};
/*
ENDCCellActivationRequest-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-ServedNRCellsToActivate 	CRITICALITY reject	TYPE ServedNRCellsToActivate			PRESENCE mandatory}|
	{ ID id-ActivationID			 	CRITICALITY reject	TYPE ActivationID					PRESENCE mandatory},
	...
}
*/

struct ENDCCellActivationRequest_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 3; }
		void clear() {type = 0;}
		void select_id_ServedNRCellsToActivate() { set(id_ServedNRCellsToActivate); type=1;}
		void select_id_ActivationID() { set(id_ActivationID); type=2;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_ServedNRCellsToActivate)) { type = 1; return true; }
			else if(equal(id_ActivationID)) { type = 2; return true; }
			else { type = 3; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_ServedNRCellsToActivate);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_ActivationID);} return false;
			case 3: type = 3; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 3; }
		void clear() {type = 0;}
		void select_id_ServedNRCellsToActivate() { set(reject); type=1;}
		void select_id_ActivationID() { set(reject); type=2;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else if(equal(reject)) { type = 2; return true; }
			else { type = 3; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(reject);} return false;
			case 3: type = 3; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		ServedNRCellsToActivate& select_id_ServedNRCellsToActivate() { return set<ServedNRCellsToActivate>(1); }
		ServedNRCellsToActivate const* get_id_ServedNRCellsToActivate() const { return get<ServedNRCellsToActivate>(1); }
		ActivationID& select_id_ActivationID() { return set<ActivationID>(2); }
		ActivationID const* get_id_ActivationID() const { return get<ActivationID>(2); }
		bool is_unknown() const { return type == 3; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<ServedNRCellsToActivate>(); break;
			case 2: var.destroy<ActivationID>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<ServedNRCellsToActivate>(1);
			v.template operator()<ActivationID>(2);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_ServedNRCellsToActivate()); return true;
			case 2: v(select_id_ActivationID()); return true;
			case 3: if(type != 3) {clear(); asn::base::set();} type = 3; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<ServedNRCellsToActivate>()); return true;
			case 2: v(var.as<ActivationID>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(ActivationID)];
			char dummy2[sizeof(ServedNRCellsToActivate)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 3; }
		void clear() {type = 0;}
		void select_id_ServedNRCellsToActivate() { set(mandatory); type=1;}
		void select_id_ActivationID() { set(mandatory); type=2;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(mandatory)) { type = 2; return true; }
			else { type = 3; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 3: type = 3; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
ENDCCellActivationRequest ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{ENDCCellActivationRequest-IEs}},
	...
}
*/

struct ENDCCellActivationRequest : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "ENDCCellActivationRequest";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<ENDCCellActivationRequest_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<ENDCCellActivationRequest_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
ENDCCellActivationResponse-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-ActivatedNRCellList		CRITICALITY ignore	TYPE ActivatedNRCellList				PRESENCE mandatory}|
	{ ID id-ActivationID				CRITICALITY reject	TYPE ActivationID					PRESENCE mandatory}|
	{ ID id-CriticalityDiagnostics	CRITICALITY ignore	TYPE CriticalityDiagnostics			PRESENCE optional},
	...
}
*/

struct ENDCCellActivationResponse_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 4; }
		void clear() {type = 0;}
		void select_id_ActivatedNRCellList() { set(id_ActivatedNRCellList); type=1;}
		void select_id_ActivationID() { set(id_ActivationID); type=2;}
		void select_id_CriticalityDiagnostics() { set(id_CriticalityDiagnostics); type=3;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_ActivatedNRCellList)) { type = 1; return true; }
			else if(equal(id_ActivationID)) { type = 2; return true; }
			else if(equal(id_CriticalityDiagnostics)) { type = 3; return true; }
			else { type = 4; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_ActivatedNRCellList);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_ActivationID);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_CriticalityDiagnostics);} return false;
			case 4: type = 4; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 4; }
		void clear() {type = 0;}
		void select_id_ActivatedNRCellList() { set(ignore); type=1;}
		void select_id_ActivationID() { set(reject); type=2;}
		void select_id_CriticalityDiagnostics() { set(ignore); type=3;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else if(equal(reject)) { type = 2; return true; }
			else if(equal(ignore)) { type = 3; return true; }
			else { type = 4; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(reject);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(ignore);} return false;
			case 4: type = 4; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		ActivatedNRCellList& select_id_ActivatedNRCellList() { return set<ActivatedNRCellList>(1); }
		ActivatedNRCellList const* get_id_ActivatedNRCellList() const { return get<ActivatedNRCellList>(1); }
		ActivationID& select_id_ActivationID() { return set<ActivationID>(2); }
		ActivationID const* get_id_ActivationID() const { return get<ActivationID>(2); }
		CriticalityDiagnostics& select_id_CriticalityDiagnostics() { return set<CriticalityDiagnostics>(3); }
		CriticalityDiagnostics const* get_id_CriticalityDiagnostics() const { return get<CriticalityDiagnostics>(3); }
		bool is_unknown() const { return type == 4; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<ActivatedNRCellList>(); break;
			case 2: var.destroy<ActivationID>(); break;
			case 3: var.destroy<CriticalityDiagnostics>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<ActivatedNRCellList>(1);
			v.template operator()<ActivationID>(2);
			v.template operator()<CriticalityDiagnostics>(3);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_ActivatedNRCellList()); return true;
			case 2: v(select_id_ActivationID()); return true;
			case 3: v(select_id_CriticalityDiagnostics()); return true;
			case 4: if(type != 4) {clear(); asn::base::set();} type = 4; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<ActivatedNRCellList>()); return true;
			case 2: v(var.as<ActivationID>()); return true;
			case 3: v(var.as<CriticalityDiagnostics>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(ActivatedNRCellList)];
			char dummy2[sizeof(ActivationID)];
			char dummy3[sizeof(CriticalityDiagnostics)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 4; }
		void clear() {type = 0;}
		void select_id_ActivatedNRCellList() { set(mandatory); type=1;}
		void select_id_ActivationID() { set(mandatory); type=2;}
		void select_id_CriticalityDiagnostics() { set(optional); type=3;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(mandatory)) { type = 2; return true; }
			else if(equal(optional)) { type = 3; return true; }
			else { type = 4; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(optional);} return false;
			case 4: type = 4; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
ENDCCellActivationResponse ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{ENDCCellActivationResponse-IEs}},
	...
}
*/

struct ENDCCellActivationResponse : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "ENDCCellActivationResponse";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<ENDCCellActivationResponse_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<ENDCCellActivationResponse_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
FDD-InfoServedNRCell-Information-ExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct FDD_InfoServedNRCell_Information_ExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
FDD-InfoServedNRCell-Information ::= SEQUENCE {
	ul-NRFreqInfo				NRFreqInfo,
	dl-NRFreqInfo				NRFreqInfo,
	ul-NR-TxBW				NR-TxBW,
	dl-NR-TxBW				NR-TxBW,
	iE-Extensions			ProtocolExtensionContainer { {FDD-InfoServedNRCell-Information-ExtIEs} }		OPTIONAL,
	...
}
*/

struct FDD_InfoServedNRCell_Information : asn::sequence<5, 0, true, 1>
{
	static constexpr const char* name() {return "FDD-InfoServedNRCell-Information";}
	using parent_t = asn::sequence<5, 0, true, 1>;
	struct ul_NRFreqInfo_t : NRFreqInfo
	{
		static constexpr const char* name() {return "ul_NRFreqInfo_t";}
		using parent_t = NRFreqInfo;

	};
	ul_NRFreqInfo_t& ref_ul_NRFreqInfo() {return ul_NRFreqInfo;}
	ul_NRFreqInfo_t const& ref_ul_NRFreqInfo() const {return ul_NRFreqInfo;}
	struct dl_NRFreqInfo_t : NRFreqInfo
	{
		static constexpr const char* name() {return "dl_NRFreqInfo_t";}
		using parent_t = NRFreqInfo;

	};
	dl_NRFreqInfo_t& ref_dl_NRFreqInfo() {return dl_NRFreqInfo;}
	dl_NRFreqInfo_t const& ref_dl_NRFreqInfo() const {return dl_NRFreqInfo;}
	struct ul_NR_TxBW_t : NR_TxBW
	{
		static constexpr const char* name() {return "ul_NR_TxBW_t";}
		using parent_t = NR_TxBW;

	};
	ul_NR_TxBW_t& ref_ul_NR_TxBW() {return ul_NR_TxBW;}
	ul_NR_TxBW_t const& ref_ul_NR_TxBW() const {return ul_NR_TxBW;}
	struct dl_NR_TxBW_t : NR_TxBW
	{
		static constexpr const char* name() {return "dl_NR_TxBW_t";}
		using parent_t = NR_TxBW;

	};
	dl_NR_TxBW_t& ref_dl_NR_TxBW() {return dl_NR_TxBW;}
	dl_NR_TxBW_t const& ref_dl_NR_TxBW() const {return dl_NR_TxBW;}
	struct iE_Extensions_t : ProtocolExtensionContainer<FDD_InfoServedNRCell_Information_ExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<FDD_InfoServedNRCell_Information_ExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(ul_NRFreqInfo);
		v(dl_NRFreqInfo);
		v(ul_NR_TxBW);
		v(dl_NR_TxBW);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(ul_NRFreqInfo);
		v(dl_NRFreqInfo);
		v(ul_NR_TxBW);
		v(dl_NR_TxBW);
		v(iE_Extensions);

	};
	void clear()
	{
		ul_NRFreqInfo.clear();
		dl_NRFreqInfo.clear();
		ul_NR_TxBW.clear();
		dl_NR_TxBW.clear();
		iE_Extensions.clear();

	};
	private:
	ul_NRFreqInfo_t	ul_NRFreqInfo;
	dl_NRFreqInfo_t	dl_NRFreqInfo;
	ul_NR_TxBW_t	ul_NR_TxBW;
	dl_NR_TxBW_t	dl_NR_TxBW;
	iE_Extensions_t	iE_Extensions;

};
/*
TDD-InfoServedNRCell-Information-ExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct TDD_InfoServedNRCell_Information_ExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
TDD-InfoServedNRCell-Information ::= SEQUENCE {
	nRFreqInfo				NRFreqInfo,
	nR-TxBW					NR-TxBW,
	iE-Extensions			ProtocolExtensionContainer { {TDD-InfoServedNRCell-Information-ExtIEs} }		OPTIONAL,
	...
}
*/

struct TDD_InfoServedNRCell_Information : asn::sequence<3, 0, true, 1>
{
	static constexpr const char* name() {return "TDD-InfoServedNRCell-Information";}
	using parent_t = asn::sequence<3, 0, true, 1>;
	struct nRFreqInfo_t : NRFreqInfo
	{
		static constexpr const char* name() {return "nRFreqInfo_t";}
		using parent_t = NRFreqInfo;

	};
	nRFreqInfo_t& ref_nRFreqInfo() {return nRFreqInfo;}
	nRFreqInfo_t const& ref_nRFreqInfo() const {return nRFreqInfo;}
	struct nR_TxBW_t : NR_TxBW
	{
		static constexpr const char* name() {return "nR_TxBW_t";}
		using parent_t = NR_TxBW;

	};
	nR_TxBW_t& ref_nR_TxBW() {return nR_TxBW;}
	nR_TxBW_t const& ref_nR_TxBW() const {return nR_TxBW;}
	struct iE_Extensions_t : ProtocolExtensionContainer<TDD_InfoServedNRCell_Information_ExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<TDD_InfoServedNRCell_Information_ExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(nRFreqInfo);
		v(nR_TxBW);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(nRFreqInfo);
		v(nR_TxBW);
		v(iE_Extensions);

	};
	void clear()
	{
		nRFreqInfo.clear();
		nR_TxBW.clear();
		iE_Extensions.clear();

	};
	private:
	nRFreqInfo_t	nRFreqInfo;
	nR_TxBW_t	nR_TxBW;
	iE_Extensions_t	iE_Extensions;

};
/*
ServedNRCell-Information-ExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct ServedNRCell_Information_ExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
ServedNRCell-Information ::= SEQUENCE {
	nrpCI				NRPCI,
	nrCellID			NRCGI,
	fiveGS-TAC			FiveGS-TAC	OPTIONAL,
	configured-TAC		TAC			OPTIONAL,
	broadcastPLMNs		BroadcastPLMNs-Item,
	nrModeInfo			CHOICE {
		fdd		FDD-InfoServedNRCell-Information,
		tdd		TDD-InfoServedNRCell-Information,
		...
	},
	measurementTimingConfiguration	OCTET STRING,
	iE-Extensions						ProtocolExtensionContainer { {ServedNRCell-Information-ExtIEs} } OPTIONAL,
	...
}
*/

struct ServedNRCell_Information : asn::sequence<8, 0, true, 3>
{
	static constexpr const char* name() {return "ServedNRCell-Information";}
	using parent_t = asn::sequence<8, 0, true, 3>;
	struct nrpCI_t : NRPCI
	{
		static constexpr const char* name() {return "nrpCI_t";}
		using parent_t = NRPCI;

	};
	nrpCI_t& ref_nrpCI() {return nrpCI;}
	nrpCI_t const& ref_nrpCI() const {return nrpCI;}
	struct nrCellID_t : NRCGI
	{
		static constexpr const char* name() {return "nrCellID_t";}
		using parent_t = NRCGI;

	};
	nrCellID_t& ref_nrCellID() {return nrCellID;}
	nrCellID_t const& ref_nrCellID() const {return nrCellID;}
	struct fiveGS_TAC_t : FiveGS_TAC
	{
		static constexpr const char* name() {return "fiveGS_TAC_t";}
		using parent_t = FiveGS_TAC;
		static constexpr bool optional = true;

	};
	fiveGS_TAC_t& set_fiveGS_TAC() { fiveGS_TAC.setpresent(true); return fiveGS_TAC;}
	fiveGS_TAC_t const* get_fiveGS_TAC() const {return fiveGS_TAC.is_valid() ? &fiveGS_TAC : nullptr;}
	struct configured_TAC_t : TAC
	{
		static constexpr const char* name() {return "configured_TAC_t";}
		using parent_t = TAC;
		static constexpr bool optional = true;

	};
	configured_TAC_t& set_configured_TAC() { configured_TAC.setpresent(true); return configured_TAC;}
	configured_TAC_t const* get_configured_TAC() const {return configured_TAC.is_valid() ? &configured_TAC : nullptr;}
	struct broadcastPLMNs_t : BroadcastPLMNs_Item
	{
		static constexpr const char* name() {return "broadcastPLMNs_t";}
		using parent_t = BroadcastPLMNs_Item;

	};
	broadcastPLMNs_t& ref_broadcastPLMNs() {return broadcastPLMNs;}
	broadcastPLMNs_t const& ref_broadcastPLMNs() const {return broadcastPLMNs;}
	struct nrModeInfo_t : asn::choice<2, 0, true>
	{
		static constexpr const char* name() {return "nrModeInfo_t";}
		using parent_t = asn::choice<2, 0, true>;
		index_type get_index() const {return index;}
		bool is_unknown() const {return index == 3;}
		void set_unknown() { set_index(3);  }
		~nrModeInfo_t() {clear();}
		struct fdd_t : FDD_InfoServedNRCell_Information
		{
			static constexpr const char* name() {return "fdd_t";}
			using parent_t = FDD_InfoServedNRCell_Information;

		};
		struct tdd_t : TDD_InfoServedNRCell_Information
		{
			static constexpr const char* name() {return "tdd_t";}
			using parent_t = TDD_InfoServedNRCell_Information;

		};
		void clear()
		{
			switch(get_index())
			{
			case 1: var.destroy<fdd_t>(); break;
			case 2: var.destroy<tdd_t>(); break;
			}
			index = 0;
			base::clear();
		}
		template<typename V> bool decode(size_t idx, V& v)
		{
			clear();
			switch(idx)
			{
			case 1: set_index(1); return v(var.build<fdd_t>());
			case 2: set_index(2); return v(var.build<tdd_t>());
			}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			switch(get_index())
			{
			case 1: return v(var.as<fdd_t>());
			case 2: return v(var.as<tdd_t>());
			}
			return false;
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<fdd_t>(1);
			v.template operator()<tdd_t>(2);

		}
		fdd_t& select_fdd() { if(get_index() != 1) { clear(); set_index(1); return var.build<fdd_t>();} return var.as<fdd_t>();}
		fdd_t const* get_fdd() const { if(get_index() == 1) { return &var.as<fdd_t>();} return nullptr; }
		tdd_t& select_tdd() { if(get_index() != 2) { clear(); set_index(2); return var.build<tdd_t>();} return var.as<tdd_t>();}
		tdd_t const* get_tdd() const { if(get_index() == 2) { return &var.as<tdd_t>();} return nullptr; }
		private:
		void set_index(index_type i) {index = i; base::set();}
		union union_type
		{
			char dummy1[sizeof(fdd_t)];
			char dummy2[sizeof(tdd_t)];

		};
		asn::variant<sizeof(union_type)>	var;
		index_type	index {0};
	};
	nrModeInfo_t& ref_nrModeInfo() {return nrModeInfo;}
	nrModeInfo_t const& ref_nrModeInfo() const {return nrModeInfo;}
	struct measurementTimingConfiguration_t : asn::ostring<>
	{
		static constexpr const char* name() {return "measurementTimingConfiguration_t";}
		using parent_t = asn::ostring<>;

	};

	measurementTimingConfiguration_t& ref_measurementTimingConfiguration() {return measurementTimingConfiguration;}
	measurementTimingConfiguration_t const& ref_measurementTimingConfiguration() const {return measurementTimingConfiguration;}
	struct iE_Extensions_t : ProtocolExtensionContainer<ServedNRCell_Information_ExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<ServedNRCell_Information_ExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(nrpCI);
		v(nrCellID);
		v(fiveGS_TAC);
		v(configured_TAC);
		v(broadcastPLMNs);
		v(nrModeInfo);
		v(measurementTimingConfiguration);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(nrpCI);
		v(nrCellID);
		v(fiveGS_TAC);
		v(configured_TAC);
		v(broadcastPLMNs);
		v(nrModeInfo);
		v(measurementTimingConfiguration);
		v(iE_Extensions);

	};
	void clear()
	{
		nrpCI.clear();
		nrCellID.clear();
		fiveGS_TAC.clear();
		configured_TAC.clear();
		broadcastPLMNs.clear();
		nrModeInfo.clear();
		measurementTimingConfiguration.clear();
		iE_Extensions.clear();

	};
	private:
	nrpCI_t	nrpCI;
	nrCellID_t	nrCellID;
	fiveGS_TAC_t	fiveGS_TAC;
	configured_TAC_t	configured_TAC;
	broadcastPLMNs_t	broadcastPLMNs;
	nrModeInfo_t	nrModeInfo;
	measurementTimingConfiguration_t	measurementTimingConfiguration;
	iE_Extensions_t	iE_Extensions;

};
/*
En-gNBServedCells-ExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct En_gNBServedCells_ExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
ServedNRcellsENDCX2ManagementList ::= SEQUENCE (SIZE (1.. maxCellinengNB)) OF SEQUENCE {
	servedNRCellInfo						ServedNRCell-Information,
	nRNeighbourInfo						NRNeighbour-Information OPTIONAL,
	iE-Extensions						ProtocolExtensionContainer { {En-gNBServedCells-ExtIEs} } OPTIONAL,
	...
}
*/

struct ServedNRcellsENDCX2ManagementList_elm : asn::sequence<3, 0, true, 2>
{
	static constexpr const char* name() {return "ServedNRcellsENDCX2ManagementList_elm";}
	using parent_t = asn::sequence<3, 0, true, 2>;
	struct servedNRCellInfo_t : ServedNRCell_Information
	{
		static constexpr const char* name() {return "servedNRCellInfo_t";}
		using parent_t = ServedNRCell_Information;

	};
	servedNRCellInfo_t& ref_servedNRCellInfo() {return servedNRCellInfo;}
	servedNRCellInfo_t const& ref_servedNRCellInfo() const {return servedNRCellInfo;}
	struct nRNeighbourInfo_t : NRNeighbour_Information
	{
		static constexpr const char* name() {return "nRNeighbourInfo_t";}
		using parent_t = NRNeighbour_Information;
		static constexpr bool optional = true;

	};
	nRNeighbourInfo_t& set_nRNeighbourInfo() { nRNeighbourInfo.setpresent(true); return nRNeighbourInfo;}
	nRNeighbourInfo_t const* get_nRNeighbourInfo() const {return nRNeighbourInfo.is_valid() ? &nRNeighbourInfo : nullptr;}
	struct iE_Extensions_t : ProtocolExtensionContainer<En_gNBServedCells_ExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<En_gNBServedCells_ExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(servedNRCellInfo);
		v(nRNeighbourInfo);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(servedNRCellInfo);
		v(nRNeighbourInfo);
		v(iE_Extensions);

	};
	void clear()
	{
		servedNRCellInfo.clear();
		nRNeighbourInfo.clear();
		iE_Extensions.clear();

	};
	private:
	servedNRCellInfo_t	servedNRCellInfo;
	nRNeighbourInfo_t	nRNeighbourInfo;
	iE_Extensions_t	iE_Extensions;

};
struct ServedNRcellsENDCX2ManagementList : asn::sequenceof<ServedNRcellsENDCX2ManagementList_elm>
{
	static constexpr const char* name() {return "ServedNRcellsENDCX2ManagementList";}
	using parent_t = asn::sequenceof<ServedNRcellsENDCX2ManagementList_elm>;
	using constraint_t = asn::constraints<false,asn::span<1,  maxCellinengNB >>;

};
/*
ServedNRCellsToModify-Item-ExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct ServedNRCellsToModify_Item_ExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
ServedNRCellsToModify-Item::= SEQUENCE {
	old-nrcgi						NRCGI,
	servedNRCellInformation			ServedNRCell-Information,
	nrNeighbourInformation			NRNeighbour-Information			OPTIONAL,
	nrDeactivationIndication			DeactivationIndication			OPTIONAL,
	iE-Extensions					ProtocolExtensionContainer { {ServedNRCellsToModify-Item-ExtIEs} } OPTIONAL,
	...
}
*/

struct ServedNRCellsToModify_Item : asn::sequence<5, 0, true, 3>
{
	static constexpr const char* name() {return "ServedNRCellsToModify-Item";}
	using parent_t = asn::sequence<5, 0, true, 3>;
	struct old_nrcgi_t : NRCGI
	{
		static constexpr const char* name() {return "old_nrcgi_t";}
		using parent_t = NRCGI;

	};
	old_nrcgi_t& ref_old_nrcgi() {return old_nrcgi;}
	old_nrcgi_t const& ref_old_nrcgi() const {return old_nrcgi;}
	struct servedNRCellInformation_t : ServedNRCell_Information
	{
		static constexpr const char* name() {return "servedNRCellInformation_t";}
		using parent_t = ServedNRCell_Information;

	};
	servedNRCellInformation_t& ref_servedNRCellInformation() {return servedNRCellInformation;}
	servedNRCellInformation_t const& ref_servedNRCellInformation() const {return servedNRCellInformation;}
	struct nrNeighbourInformation_t : NRNeighbour_Information
	{
		static constexpr const char* name() {return "nrNeighbourInformation_t";}
		using parent_t = NRNeighbour_Information;
		static constexpr bool optional = true;

	};
	nrNeighbourInformation_t& set_nrNeighbourInformation() { nrNeighbourInformation.setpresent(true); return nrNeighbourInformation;}
	nrNeighbourInformation_t const* get_nrNeighbourInformation() const {return nrNeighbourInformation.is_valid() ? &nrNeighbourInformation : nullptr;}
	struct nrDeactivationIndication_t : DeactivationIndication
	{
		static constexpr const char* name() {return "nrDeactivationIndication_t";}
		using parent_t = DeactivationIndication;
		static constexpr bool optional = true;

	};
	nrDeactivationIndication_t& set_nrDeactivationIndication() { nrDeactivationIndication.setpresent(true); return nrDeactivationIndication;}
	nrDeactivationIndication_t const* get_nrDeactivationIndication() const {return nrDeactivationIndication.is_valid() ? &nrDeactivationIndication : nullptr;}
	struct iE_Extensions_t : ProtocolExtensionContainer<ServedNRCellsToModify_Item_ExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<ServedNRCellsToModify_Item_ExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(old_nrcgi);
		v(servedNRCellInformation);
		v(nrNeighbourInformation);
		v(nrDeactivationIndication);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(old_nrcgi);
		v(servedNRCellInformation);
		v(nrNeighbourInformation);
		v(nrDeactivationIndication);
		v(iE_Extensions);

	};
	void clear()
	{
		old_nrcgi.clear();
		servedNRCellInformation.clear();
		nrNeighbourInformation.clear();
		nrDeactivationIndication.clear();
		iE_Extensions.clear();

	};
	private:
	old_nrcgi_t	old_nrcgi;
	servedNRCellInformation_t	servedNRCellInformation;
	nrNeighbourInformation_t	nrNeighbourInformation;
	nrDeactivationIndication_t	nrDeactivationIndication;
	iE_Extensions_t	iE_Extensions;

};
/*
ServedNRcellsToModifyENDCConfUpdList ::= SEQUENCE (SIZE (1..maxCellinengNB)) OF ServedNRCellsToModify-Item
*/

struct ServedNRcellsToModifyENDCConfUpdList_elm : ServedNRCellsToModify_Item
{
	static constexpr const char* name() {return "ServedNRcellsToModifyENDCConfUpdList_elm";}
	using parent_t = ServedNRCellsToModify_Item;

};
struct ServedNRcellsToModifyENDCConfUpdList : asn::sequenceof<ServedNRcellsToModifyENDCConfUpdList_elm>
{
	static constexpr const char* name() {return "ServedNRcellsToModifyENDCConfUpdList";}
	using parent_t = asn::sequenceof<ServedNRcellsToModifyENDCConfUpdList_elm>;
	using constraint_t = asn::constraints<false,asn::span<1,  maxCellinengNB >>;

};
/*
ServedNRcellsToDeleteENDCConfUpdList ::= SEQUENCE (SIZE (1..maxCellinengNB)) OF NRCGI
*/

struct ServedNRcellsToDeleteENDCConfUpdList_elm : NRCGI
{
	static constexpr const char* name() {return "ServedNRcellsToDeleteENDCConfUpdList_elm";}
	using parent_t = NRCGI;

};
struct ServedNRcellsToDeleteENDCConfUpdList : asn::sequenceof<ServedNRcellsToDeleteENDCConfUpdList_elm>
{
	static constexpr const char* name() {return "ServedNRcellsToDeleteENDCConfUpdList";}
	using parent_t = asn::sequenceof<ServedNRcellsToDeleteENDCConfUpdList_elm>;
	using constraint_t = asn::constraints<false,asn::span<1,  maxCellinengNB >>;

};
/*
En-gNB-ENDCConfigUpdateIEs X2AP-PROTOCOL-IES ::= {
	{ ID id-ServedNRcellsENDCX2ManagementList		CRITICALITY reject	TYPE ServedNRcellsENDCX2ManagementList			PRESENCE optional }|
	{ ID id-ServedNRcellsToModifyListENDCConfUpd		CRITICALITY reject	TYPE ServedNRcellsToModifyENDCConfUpdList		PRESENCE optional }|
	{ ID id-ServedNRcellsToDeleteListENDCConfUpd		CRITICALITY reject	TYPE ServedNRcellsToDeleteENDCConfUpdList		PRESENCE optional },
	...
}
*/

struct En_gNB_ENDCConfigUpdateIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 4; }
		void clear() {type = 0;}
		void select_id_ServedNRcellsENDCX2ManagementList() { set(id_ServedNRcellsENDCX2ManagementList); type=1;}
		void select_id_ServedNRcellsToModifyListENDCConfUpd() { set(id_ServedNRcellsToModifyListENDCConfUpd); type=2;}
		void select_id_ServedNRcellsToDeleteListENDCConfUpd() { set(id_ServedNRcellsToDeleteListENDCConfUpd); type=3;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_ServedNRcellsENDCX2ManagementList)) { type = 1; return true; }
			else if(equal(id_ServedNRcellsToModifyListENDCConfUpd)) { type = 2; return true; }
			else if(equal(id_ServedNRcellsToDeleteListENDCConfUpd)) { type = 3; return true; }
			else { type = 4; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_ServedNRcellsENDCX2ManagementList);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_ServedNRcellsToModifyListENDCConfUpd);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_ServedNRcellsToDeleteListENDCConfUpd);} return false;
			case 4: type = 4; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 4; }
		void clear() {type = 0;}
		void select_id_ServedNRcellsENDCX2ManagementList() { set(reject); type=1;}
		void select_id_ServedNRcellsToModifyListENDCConfUpd() { set(reject); type=2;}
		void select_id_ServedNRcellsToDeleteListENDCConfUpd() { set(reject); type=3;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else if(equal(reject)) { type = 2; return true; }
			else if(equal(reject)) { type = 3; return true; }
			else { type = 4; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(reject);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(reject);} return false;
			case 4: type = 4; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		ServedNRcellsENDCX2ManagementList& select_id_ServedNRcellsENDCX2ManagementList() { return set<ServedNRcellsENDCX2ManagementList>(1); }
		ServedNRcellsENDCX2ManagementList const* get_id_ServedNRcellsENDCX2ManagementList() const { return get<ServedNRcellsENDCX2ManagementList>(1); }
		ServedNRcellsToModifyENDCConfUpdList& select_id_ServedNRcellsToModifyListENDCConfUpd() { return set<ServedNRcellsToModifyENDCConfUpdList>(2); }
		ServedNRcellsToModifyENDCConfUpdList const* get_id_ServedNRcellsToModifyListENDCConfUpd() const { return get<ServedNRcellsToModifyENDCConfUpdList>(2); }
		ServedNRcellsToDeleteENDCConfUpdList& select_id_ServedNRcellsToDeleteListENDCConfUpd() { return set<ServedNRcellsToDeleteENDCConfUpdList>(3); }
		ServedNRcellsToDeleteENDCConfUpdList const* get_id_ServedNRcellsToDeleteListENDCConfUpd() const { return get<ServedNRcellsToDeleteENDCConfUpdList>(3); }
		bool is_unknown() const { return type == 4; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<ServedNRcellsENDCX2ManagementList>(); break;
			case 2: var.destroy<ServedNRcellsToModifyENDCConfUpdList>(); break;
			case 3: var.destroy<ServedNRcellsToDeleteENDCConfUpdList>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<ServedNRcellsENDCX2ManagementList>(1);
			v.template operator()<ServedNRcellsToModifyENDCConfUpdList>(2);
			v.template operator()<ServedNRcellsToDeleteENDCConfUpdList>(3);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_ServedNRcellsENDCX2ManagementList()); return true;
			case 2: v(select_id_ServedNRcellsToModifyListENDCConfUpd()); return true;
			case 3: v(select_id_ServedNRcellsToDeleteListENDCConfUpd()); return true;
			case 4: if(type != 4) {clear(); asn::base::set();} type = 4; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<ServedNRcellsENDCX2ManagementList>()); return true;
			case 2: v(var.as<ServedNRcellsToModifyENDCConfUpdList>()); return true;
			case 3: v(var.as<ServedNRcellsToDeleteENDCConfUpdList>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(ServedNRcellsENDCX2ManagementList)];
			char dummy2[sizeof(ServedNRcellsToDeleteENDCConfUpdList)];
			char dummy3[sizeof(ServedNRcellsToModifyENDCConfUpdList)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 4; }
		void clear() {type = 0;}
		void select_id_ServedNRcellsENDCX2ManagementList() { set(optional); type=1;}
		void select_id_ServedNRcellsToModifyListENDCConfUpd() { set(optional); type=2;}
		void select_id_ServedNRcellsToDeleteListENDCConfUpd() { set(optional); type=3;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(optional)) { type = 1; return true; }
			else if(equal(optional)) { type = 2; return true; }
			else if(equal(optional)) { type = 3; return true; }
			else { type = 4; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(optional);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(optional);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(optional);} return false;
			case 4: type = 4; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
InitiatingNodeType-EndcConfigUpdate::= CHOICE {
	init-eNB			ProtocolIE-Container	{{ENB-ENDCConfigUpdateIEs}},
	init-en-gNB			ProtocolIE-Container	{{En-gNB-ENDCConfigUpdateIEs}},
	...
}
*/

struct InitiatingNodeType_EndcConfigUpdate : asn::choice<2, 0, true>
{
	static constexpr const char* name() {return "InitiatingNodeType-EndcConfigUpdate";}
	using parent_t = asn::choice<2, 0, true>;
	index_type get_index() const {return index;}
	bool is_unknown() const {return index == 3;}
	void set_unknown() { set_index(3);  }
	~InitiatingNodeType_EndcConfigUpdate() {clear();}
	struct init_eNB_t : ProtocolIE_Container<ENB_ENDCConfigUpdateIEs>
	{
		static constexpr const char* name() {return "init_eNB_t";}
		using parent_t = ProtocolIE_Container<ENB_ENDCConfigUpdateIEs>;

	};
	struct init_en_gNB_t : ProtocolIE_Container<En_gNB_ENDCConfigUpdateIEs>
	{
		static constexpr const char* name() {return "init_en_gNB_t";}
		using parent_t = ProtocolIE_Container<En_gNB_ENDCConfigUpdateIEs>;

	};
	void clear()
	{
		switch(get_index())
		{
		case 1: var.destroy<init_eNB_t>(); break;
		case 2: var.destroy<init_en_gNB_t>(); break;
		}
		index = 0;
		base::clear();
	}
	template<typename V> bool decode(size_t idx, V& v)
	{
		clear();
		switch(idx)
		{
		case 1: set_index(1); return v(var.build<init_eNB_t>());
		case 2: set_index(2); return v(var.build<init_en_gNB_t>());
		}
		return false;

	}
	template<typename V> bool encode(V& v) const
	{
		switch(get_index())
		{
		case 1: return v(var.as<init_eNB_t>());
		case 2: return v(var.as<init_en_gNB_t>());
		}
		return false;
	}
	template<typename V> static inline void enumerate(V& v)
	{
		v.template operator()<init_eNB_t>(1);
		v.template operator()<init_en_gNB_t>(2);

	}
	init_eNB_t& select_init_eNB() { if(get_index() != 1) { clear(); set_index(1); return var.build<init_eNB_t>();} return var.as<init_eNB_t>();}
	init_eNB_t const* get_init_eNB() const { if(get_index() == 1) { return &var.as<init_eNB_t>();} return nullptr; }
	init_en_gNB_t& select_init_en_gNB() { if(get_index() != 2) { clear(); set_index(2); return var.build<init_en_gNB_t>();} return var.as<init_en_gNB_t>();}
	init_en_gNB_t const* get_init_en_gNB() const { if(get_index() == 2) { return &var.as<init_en_gNB_t>();} return nullptr; }
	private:
	void set_index(index_type i) {index = i; base::set();}
	union union_type
	{
		char dummy1[sizeof(init_eNB_t)];
		char dummy2[sizeof(init_en_gNB_t)];

	};
	asn::variant<sizeof(union_type)>	var;
	index_type	index {0};
};
/*
ENDCConfigurationUpdate-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-InitiatingNodeType-EndcConfigUpdate			CRITICALITY reject	TYPE InitiatingNodeType-EndcConfigUpdate			PRESENCE mandatory},
	...
}
*/

struct ENDCConfigurationUpdate_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_InitiatingNodeType_EndcConfigUpdate() { set(id_InitiatingNodeType_EndcConfigUpdate); type=1;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_InitiatingNodeType_EndcConfigUpdate)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_InitiatingNodeType_EndcConfigUpdate);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_InitiatingNodeType_EndcConfigUpdate() { set(reject); type=1;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		InitiatingNodeType_EndcConfigUpdate& select_id_InitiatingNodeType_EndcConfigUpdate() { return set<InitiatingNodeType_EndcConfigUpdate>(1); }
		InitiatingNodeType_EndcConfigUpdate const* get_id_InitiatingNodeType_EndcConfigUpdate() const { return get<InitiatingNodeType_EndcConfigUpdate>(1); }
		bool is_unknown() const { return type == 2; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<InitiatingNodeType_EndcConfigUpdate>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<InitiatingNodeType_EndcConfigUpdate>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_InitiatingNodeType_EndcConfigUpdate()); return true;
			case 2: if(type != 2) {clear(); asn::base::set();} type = 2; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<InitiatingNodeType_EndcConfigUpdate>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(InitiatingNodeType_EndcConfigUpdate)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_InitiatingNodeType_EndcConfigUpdate() { set(mandatory); type=1;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
ENDCConfigurationUpdate ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{ENDCConfigurationUpdate-IEs}},
	...
}
*/

struct ENDCConfigurationUpdate : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "ENDCConfigurationUpdate";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<ENDCConfigurationUpdate_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<ENDCConfigurationUpdate_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
En-gNB-ENDCConfigUpdateAckIEs X2AP-PROTOCOL-IES ::= {
	{ ID id-ServedNRcellsENDCX2ManagementList		CRITICALITY reject	TYPE ServedNRcellsENDCX2ManagementList		PRESENCE optional},
	...
}
*/

struct En_gNB_ENDCConfigUpdateAckIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_ServedNRcellsENDCX2ManagementList() { set(id_ServedNRcellsENDCX2ManagementList); type=1;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_ServedNRcellsENDCX2ManagementList)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_ServedNRcellsENDCX2ManagementList);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_ServedNRcellsENDCX2ManagementList() { set(reject); type=1;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		ServedNRcellsENDCX2ManagementList& select_id_ServedNRcellsENDCX2ManagementList() { return set<ServedNRcellsENDCX2ManagementList>(1); }
		ServedNRcellsENDCX2ManagementList const* get_id_ServedNRcellsENDCX2ManagementList() const { return get<ServedNRcellsENDCX2ManagementList>(1); }
		bool is_unknown() const { return type == 2; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<ServedNRcellsENDCX2ManagementList>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<ServedNRcellsENDCX2ManagementList>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_ServedNRcellsENDCX2ManagementList()); return true;
			case 2: if(type != 2) {clear(); asn::base::set();} type = 2; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<ServedNRcellsENDCX2ManagementList>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(ServedNRcellsENDCX2ManagementList)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_ServedNRcellsENDCX2ManagementList() { set(optional); type=1;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(optional)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(optional);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
RespondingNodeType-EndcConfigUpdate::= CHOICE {
	respond-eNB			ProtocolIE-Container	{{ENB-ENDCConfigUpdateAckIEs}},
	respond-en-gNB		ProtocolIE-Container	{{En-gNB-ENDCConfigUpdateAckIEs}},
	...
}
*/

struct RespondingNodeType_EndcConfigUpdate : asn::choice<2, 0, true>
{
	static constexpr const char* name() {return "RespondingNodeType-EndcConfigUpdate";}
	using parent_t = asn::choice<2, 0, true>;
	index_type get_index() const {return index;}
	bool is_unknown() const {return index == 3;}
	void set_unknown() { set_index(3);  }
	~RespondingNodeType_EndcConfigUpdate() {clear();}
	struct respond_eNB_t : ProtocolIE_Container<ENB_ENDCConfigUpdateAckIEs>
	{
		static constexpr const char* name() {return "respond_eNB_t";}
		using parent_t = ProtocolIE_Container<ENB_ENDCConfigUpdateAckIEs>;

	};
	struct respond_en_gNB_t : ProtocolIE_Container<En_gNB_ENDCConfigUpdateAckIEs>
	{
		static constexpr const char* name() {return "respond_en_gNB_t";}
		using parent_t = ProtocolIE_Container<En_gNB_ENDCConfigUpdateAckIEs>;

	};
	void clear()
	{
		switch(get_index())
		{
		case 1: var.destroy<respond_eNB_t>(); break;
		case 2: var.destroy<respond_en_gNB_t>(); break;
		}
		index = 0;
		base::clear();
	}
	template<typename V> bool decode(size_t idx, V& v)
	{
		clear();
		switch(idx)
		{
		case 1: set_index(1); return v(var.build<respond_eNB_t>());
		case 2: set_index(2); return v(var.build<respond_en_gNB_t>());
		}
		return false;

	}
	template<typename V> bool encode(V& v) const
	{
		switch(get_index())
		{
		case 1: return v(var.as<respond_eNB_t>());
		case 2: return v(var.as<respond_en_gNB_t>());
		}
		return false;
	}
	template<typename V> static inline void enumerate(V& v)
	{
		v.template operator()<respond_eNB_t>(1);
		v.template operator()<respond_en_gNB_t>(2);

	}
	respond_eNB_t& select_respond_eNB() { if(get_index() != 1) { clear(); set_index(1); return var.build<respond_eNB_t>();} return var.as<respond_eNB_t>();}
	respond_eNB_t const* get_respond_eNB() const { if(get_index() == 1) { return &var.as<respond_eNB_t>();} return nullptr; }
	respond_en_gNB_t& select_respond_en_gNB() { if(get_index() != 2) { clear(); set_index(2); return var.build<respond_en_gNB_t>();} return var.as<respond_en_gNB_t>();}
	respond_en_gNB_t const* get_respond_en_gNB() const { if(get_index() == 2) { return &var.as<respond_en_gNB_t>();} return nullptr; }
	private:
	void set_index(index_type i) {index = i; base::set();}
	union union_type
	{
		char dummy1[sizeof(respond_eNB_t)];
		char dummy2[sizeof(respond_en_gNB_t)];

	};
	asn::variant<sizeof(union_type)>	var;
	index_type	index {0};
};
/*
ENDCConfigurationUpdateAcknowledge-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-RespondingNodeType-EndcConfigUpdate			CRITICALITY reject	TYPE RespondingNodeType-EndcConfigUpdate			PRESENCE mandatory},
	...
}
*/

struct ENDCConfigurationUpdateAcknowledge_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_RespondingNodeType_EndcConfigUpdate() { set(id_RespondingNodeType_EndcConfigUpdate); type=1;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_RespondingNodeType_EndcConfigUpdate)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_RespondingNodeType_EndcConfigUpdate);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_RespondingNodeType_EndcConfigUpdate() { set(reject); type=1;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		RespondingNodeType_EndcConfigUpdate& select_id_RespondingNodeType_EndcConfigUpdate() { return set<RespondingNodeType_EndcConfigUpdate>(1); }
		RespondingNodeType_EndcConfigUpdate const* get_id_RespondingNodeType_EndcConfigUpdate() const { return get<RespondingNodeType_EndcConfigUpdate>(1); }
		bool is_unknown() const { return type == 2; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<RespondingNodeType_EndcConfigUpdate>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<RespondingNodeType_EndcConfigUpdate>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_RespondingNodeType_EndcConfigUpdate()); return true;
			case 2: if(type != 2) {clear(); asn::base::set();} type = 2; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<RespondingNodeType_EndcConfigUpdate>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(RespondingNodeType_EndcConfigUpdate)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_RespondingNodeType_EndcConfigUpdate() { set(mandatory); type=1;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
ENDCConfigurationUpdateAcknowledge ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{ENDCConfigurationUpdateAcknowledge-IEs}},
	...
}
*/

struct ENDCConfigurationUpdateAcknowledge : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "ENDCConfigurationUpdateAcknowledge";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<ENDCConfigurationUpdateAcknowledge_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<ENDCConfigurationUpdateAcknowledge_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
ENDCConfigurationUpdateFailure-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-Cause						CRITICALITY ignore	TYPE Cause						PRESENCE mandatory}|
	{ ID id-CriticalityDiagnostics		CRITICALITY ignore	TYPE CriticalityDiagnostics		PRESENCE optional }|
	{ ID id-TimeToWait					CRITICALITY ignore	TYPE TimeToWait					PRESENCE optional },
	...
}
*/

struct ENDCConfigurationUpdateFailure_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 4; }
		void clear() {type = 0;}
		void select_id_Cause() { set(id_Cause); type=1;}
		void select_id_CriticalityDiagnostics() { set(id_CriticalityDiagnostics); type=2;}
		void select_id_TimeToWait() { set(id_TimeToWait); type=3;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_Cause)) { type = 1; return true; }
			else if(equal(id_CriticalityDiagnostics)) { type = 2; return true; }
			else if(equal(id_TimeToWait)) { type = 3; return true; }
			else { type = 4; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_Cause);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_CriticalityDiagnostics);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_TimeToWait);} return false;
			case 4: type = 4; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 4; }
		void clear() {type = 0;}
		void select_id_Cause() { set(ignore); type=1;}
		void select_id_CriticalityDiagnostics() { set(ignore); type=2;}
		void select_id_TimeToWait() { set(ignore); type=3;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else if(equal(ignore)) { type = 2; return true; }
			else if(equal(ignore)) { type = 3; return true; }
			else { type = 4; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(ignore);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(ignore);} return false;
			case 4: type = 4; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		Cause& select_id_Cause() { return set<Cause>(1); }
		Cause const* get_id_Cause() const { return get<Cause>(1); }
		CriticalityDiagnostics& select_id_CriticalityDiagnostics() { return set<CriticalityDiagnostics>(2); }
		CriticalityDiagnostics const* get_id_CriticalityDiagnostics() const { return get<CriticalityDiagnostics>(2); }
		TimeToWait& select_id_TimeToWait() { return set<TimeToWait>(3); }
		TimeToWait const* get_id_TimeToWait() const { return get<TimeToWait>(3); }
		bool is_unknown() const { return type == 4; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<Cause>(); break;
			case 2: var.destroy<CriticalityDiagnostics>(); break;
			case 3: var.destroy<TimeToWait>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<Cause>(1);
			v.template operator()<CriticalityDiagnostics>(2);
			v.template operator()<TimeToWait>(3);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_Cause()); return true;
			case 2: v(select_id_CriticalityDiagnostics()); return true;
			case 3: v(select_id_TimeToWait()); return true;
			case 4: if(type != 4) {clear(); asn::base::set();} type = 4; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<Cause>()); return true;
			case 2: v(var.as<CriticalityDiagnostics>()); return true;
			case 3: v(var.as<TimeToWait>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(Cause)];
			char dummy2[sizeof(CriticalityDiagnostics)];
			char dummy3[sizeof(TimeToWait)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 4; }
		void clear() {type = 0;}
		void select_id_Cause() { set(mandatory); type=1;}
		void select_id_CriticalityDiagnostics() { set(optional); type=2;}
		void select_id_TimeToWait() { set(optional); type=3;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(optional)) { type = 2; return true; }
			else if(equal(optional)) { type = 3; return true; }
			else { type = 4; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(optional);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(optional);} return false;
			case 4: type = 4; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
ENDCConfigurationUpdateFailure ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{ENDCConfigurationUpdateFailure-IEs}},
	...
}
*/

struct ENDCConfigurationUpdateFailure : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "ENDCConfigurationUpdateFailure";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<ENDCConfigurationUpdateFailure_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<ENDCConfigurationUpdateFailure_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
ENDCPartialResetConfirm-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-UEs-Admitted-ToBeReset				CRITICALITY reject	TYPE UEsToBeResetList				PRESENCE mandatory},
	...
}
*/

struct ENDCPartialResetConfirm_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_UEs_Admitted_ToBeReset() { set(id_UEs_Admitted_ToBeReset); type=1;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_UEs_Admitted_ToBeReset)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_UEs_Admitted_ToBeReset);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_UEs_Admitted_ToBeReset() { set(reject); type=1;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		UEsToBeResetList& select_id_UEs_Admitted_ToBeReset() { return set<UEsToBeResetList>(1); }
		UEsToBeResetList const* get_id_UEs_Admitted_ToBeReset() const { return get<UEsToBeResetList>(1); }
		bool is_unknown() const { return type == 2; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<UEsToBeResetList>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<UEsToBeResetList>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_UEs_Admitted_ToBeReset()); return true;
			case 2: if(type != 2) {clear(); asn::base::set();} type = 2; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<UEsToBeResetList>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(UEsToBeResetList)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_UEs_Admitted_ToBeReset() { set(mandatory); type=1;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
ENDCPartialResetConfirm ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{ENDCPartialResetConfirm-IEs}},
	...
}
*/

struct ENDCPartialResetConfirm : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "ENDCPartialResetConfirm";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<ENDCPartialResetConfirm_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<ENDCPartialResetConfirm_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
ENDCPartialResetRequired-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-UEs-ToBeReset				CRITICALITY reject	TYPE UEsToBeResetList					PRESENCE mandatory}|
	{ ID id-Cause						CRITICALITY ignore	TYPE Cause								PRESENCE mandatory },
	...
}
*/

struct ENDCPartialResetRequired_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 3; }
		void clear() {type = 0;}
		void select_id_UEs_ToBeReset() { set(id_UEs_ToBeReset); type=1;}
		void select_id_Cause() { set(id_Cause); type=2;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_UEs_ToBeReset)) { type = 1; return true; }
			else if(equal(id_Cause)) { type = 2; return true; }
			else { type = 3; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_UEs_ToBeReset);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_Cause);} return false;
			case 3: type = 3; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 3; }
		void clear() {type = 0;}
		void select_id_UEs_ToBeReset() { set(reject); type=1;}
		void select_id_Cause() { set(ignore); type=2;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else if(equal(ignore)) { type = 2; return true; }
			else { type = 3; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(ignore);} return false;
			case 3: type = 3; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		UEsToBeResetList& select_id_UEs_ToBeReset() { return set<UEsToBeResetList>(1); }
		UEsToBeResetList const* get_id_UEs_ToBeReset() const { return get<UEsToBeResetList>(1); }
		Cause& select_id_Cause() { return set<Cause>(2); }
		Cause const* get_id_Cause() const { return get<Cause>(2); }
		bool is_unknown() const { return type == 3; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<UEsToBeResetList>(); break;
			case 2: var.destroy<Cause>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<UEsToBeResetList>(1);
			v.template operator()<Cause>(2);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_UEs_ToBeReset()); return true;
			case 2: v(select_id_Cause()); return true;
			case 3: if(type != 3) {clear(); asn::base::set();} type = 3; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<UEsToBeResetList>()); return true;
			case 2: v(var.as<Cause>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(Cause)];
			char dummy2[sizeof(UEsToBeResetList)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 3; }
		void clear() {type = 0;}
		void select_id_UEs_ToBeReset() { set(mandatory); type=1;}
		void select_id_Cause() { set(mandatory); type=2;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(mandatory)) { type = 2; return true; }
			else { type = 3; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 3: type = 3; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
ENDCPartialResetRequired ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{ENDCPartialResetRequired-IEs}},
	...
}
*/

struct ENDCPartialResetRequired : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "ENDCPartialResetRequired";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<ENDCPartialResetRequired_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<ENDCPartialResetRequired_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
ENDCX2RemovalFailure-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-Cause					CRITICALITY ignore		TYPE Cause								PRESENCE mandatory} |
	{ ID id-CriticalityDiagnostics	CRITICALITY ignore		TYPE CriticalityDiagnostics				PRESENCE optional },
	...
}
*/

struct ENDCX2RemovalFailure_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 3; }
		void clear() {type = 0;}
		void select_id_Cause() { set(id_Cause); type=1;}
		void select_id_CriticalityDiagnostics() { set(id_CriticalityDiagnostics); type=2;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_Cause)) { type = 1; return true; }
			else if(equal(id_CriticalityDiagnostics)) { type = 2; return true; }
			else { type = 3; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_Cause);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_CriticalityDiagnostics);} return false;
			case 3: type = 3; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 3; }
		void clear() {type = 0;}
		void select_id_Cause() { set(ignore); type=1;}
		void select_id_CriticalityDiagnostics() { set(ignore); type=2;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else if(equal(ignore)) { type = 2; return true; }
			else { type = 3; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(ignore);} return false;
			case 3: type = 3; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		Cause& select_id_Cause() { return set<Cause>(1); }
		Cause const* get_id_Cause() const { return get<Cause>(1); }
		CriticalityDiagnostics& select_id_CriticalityDiagnostics() { return set<CriticalityDiagnostics>(2); }
		CriticalityDiagnostics const* get_id_CriticalityDiagnostics() const { return get<CriticalityDiagnostics>(2); }
		bool is_unknown() const { return type == 3; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<Cause>(); break;
			case 2: var.destroy<CriticalityDiagnostics>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<Cause>(1);
			v.template operator()<CriticalityDiagnostics>(2);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_Cause()); return true;
			case 2: v(select_id_CriticalityDiagnostics()); return true;
			case 3: if(type != 3) {clear(); asn::base::set();} type = 3; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<Cause>()); return true;
			case 2: v(var.as<CriticalityDiagnostics>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(Cause)];
			char dummy2[sizeof(CriticalityDiagnostics)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 3; }
		void clear() {type = 0;}
		void select_id_Cause() { set(mandatory); type=1;}
		void select_id_CriticalityDiagnostics() { set(optional); type=2;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(optional)) { type = 2; return true; }
			else { type = 3; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(optional);} return false;
			case 3: type = 3; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
ENDCX2RemovalFailure ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{ENDCX2RemovalFailure-IEs}},
	...
}
*/

struct ENDCX2RemovalFailure : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "ENDCX2RemovalFailure";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<ENDCX2RemovalFailure_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<ENDCX2RemovalFailure_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
En-gNB-ENDCX2RemovalReqIEs X2AP-PROTOCOL-IES ::= {
	{ ID id-Globalen-gNB-ID							CRITICALITY reject	TYPE GlobalGNB-ID										PRESENCE mandatory},
	...
}
*/

struct En_gNB_ENDCX2RemovalReqIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_Globalen_gNB_ID() { set(id_Globalen_gNB_ID); type=1;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_Globalen_gNB_ID)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_Globalen_gNB_ID);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_Globalen_gNB_ID() { set(reject); type=1;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		GlobalGNB_ID& select_id_Globalen_gNB_ID() { return set<GlobalGNB_ID>(1); }
		GlobalGNB_ID const* get_id_Globalen_gNB_ID() const { return get<GlobalGNB_ID>(1); }
		bool is_unknown() const { return type == 2; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<GlobalGNB_ID>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<GlobalGNB_ID>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_Globalen_gNB_ID()); return true;
			case 2: if(type != 2) {clear(); asn::base::set();} type = 2; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<GlobalGNB_ID>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(GlobalGNB_ID)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_Globalen_gNB_ID() { set(mandatory); type=1;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
InitiatingNodeType-EndcX2Removal ::= CHOICE {
	init-eNB				ProtocolIE-Container	{{ENB-ENDCX2RemovalReqIEs}},
	init-en-gNB			ProtocolIE-Container	{{En-gNB-ENDCX2RemovalReqIEs}},
	...
}
*/

struct InitiatingNodeType_EndcX2Removal : asn::choice<2, 0, true>
{
	static constexpr const char* name() {return "InitiatingNodeType-EndcX2Removal";}
	using parent_t = asn::choice<2, 0, true>;
	index_type get_index() const {return index;}
	bool is_unknown() const {return index == 3;}
	void set_unknown() { set_index(3);  }
	~InitiatingNodeType_EndcX2Removal() {clear();}
	struct init_eNB_t : ProtocolIE_Container<ENB_ENDCX2RemovalReqIEs>
	{
		static constexpr const char* name() {return "init_eNB_t";}
		using parent_t = ProtocolIE_Container<ENB_ENDCX2RemovalReqIEs>;

	};
	struct init_en_gNB_t : ProtocolIE_Container<En_gNB_ENDCX2RemovalReqIEs>
	{
		static constexpr const char* name() {return "init_en_gNB_t";}
		using parent_t = ProtocolIE_Container<En_gNB_ENDCX2RemovalReqIEs>;

	};
	void clear()
	{
		switch(get_index())
		{
		case 1: var.destroy<init_eNB_t>(); break;
		case 2: var.destroy<init_en_gNB_t>(); break;
		}
		index = 0;
		base::clear();
	}
	template<typename V> bool decode(size_t idx, V& v)
	{
		clear();
		switch(idx)
		{
		case 1: set_index(1); return v(var.build<init_eNB_t>());
		case 2: set_index(2); return v(var.build<init_en_gNB_t>());
		}
		return false;

	}
	template<typename V> bool encode(V& v) const
	{
		switch(get_index())
		{
		case 1: return v(var.as<init_eNB_t>());
		case 2: return v(var.as<init_en_gNB_t>());
		}
		return false;
	}
	template<typename V> static inline void enumerate(V& v)
	{
		v.template operator()<init_eNB_t>(1);
		v.template operator()<init_en_gNB_t>(2);

	}
	init_eNB_t& select_init_eNB() { if(get_index() != 1) { clear(); set_index(1); return var.build<init_eNB_t>();} return var.as<init_eNB_t>();}
	init_eNB_t const* get_init_eNB() const { if(get_index() == 1) { return &var.as<init_eNB_t>();} return nullptr; }
	init_en_gNB_t& select_init_en_gNB() { if(get_index() != 2) { clear(); set_index(2); return var.build<init_en_gNB_t>();} return var.as<init_en_gNB_t>();}
	init_en_gNB_t const* get_init_en_gNB() const { if(get_index() == 2) { return &var.as<init_en_gNB_t>();} return nullptr; }
	private:
	void set_index(index_type i) {index = i; base::set();}
	union union_type
	{
		char dummy1[sizeof(init_eNB_t)];
		char dummy2[sizeof(init_en_gNB_t)];

	};
	asn::variant<sizeof(union_type)>	var;
	index_type	index {0};
};
/*
ENDCX2RemovalRequest-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-InitiatingNodeType-EndcX2Removal			CRITICALITY reject	TYPE InitiatingNodeType-EndcX2Removal		PRESENCE mandatory},
	...
}
*/

struct ENDCX2RemovalRequest_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_InitiatingNodeType_EndcX2Removal() { set(id_InitiatingNodeType_EndcX2Removal); type=1;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_InitiatingNodeType_EndcX2Removal)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_InitiatingNodeType_EndcX2Removal);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_InitiatingNodeType_EndcX2Removal() { set(reject); type=1;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		InitiatingNodeType_EndcX2Removal& select_id_InitiatingNodeType_EndcX2Removal() { return set<InitiatingNodeType_EndcX2Removal>(1); }
		InitiatingNodeType_EndcX2Removal const* get_id_InitiatingNodeType_EndcX2Removal() const { return get<InitiatingNodeType_EndcX2Removal>(1); }
		bool is_unknown() const { return type == 2; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<InitiatingNodeType_EndcX2Removal>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<InitiatingNodeType_EndcX2Removal>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_InitiatingNodeType_EndcX2Removal()); return true;
			case 2: if(type != 2) {clear(); asn::base::set();} type = 2; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<InitiatingNodeType_EndcX2Removal>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(InitiatingNodeType_EndcX2Removal)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_InitiatingNodeType_EndcX2Removal() { set(mandatory); type=1;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
ENDCX2RemovalRequest ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{ENDCX2RemovalRequest-IEs}},
	...
}
*/

struct ENDCX2RemovalRequest : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "ENDCX2RemovalRequest";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<ENDCX2RemovalRequest_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<ENDCX2RemovalRequest_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
En-gNB-ENDCX2RemovalReqAckIEs X2AP-PROTOCOL-IES ::= {
	{ ID id-Globalen-gNB-ID							CRITICALITY reject	TYPE GlobalGNB-ID										PRESENCE mandatory},
	...
}
*/

struct En_gNB_ENDCX2RemovalReqAckIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_Globalen_gNB_ID() { set(id_Globalen_gNB_ID); type=1;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_Globalen_gNB_ID)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_Globalen_gNB_ID);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_Globalen_gNB_ID() { set(reject); type=1;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		GlobalGNB_ID& select_id_Globalen_gNB_ID() { return set<GlobalGNB_ID>(1); }
		GlobalGNB_ID const* get_id_Globalen_gNB_ID() const { return get<GlobalGNB_ID>(1); }
		bool is_unknown() const { return type == 2; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<GlobalGNB_ID>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<GlobalGNB_ID>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_Globalen_gNB_ID()); return true;
			case 2: if(type != 2) {clear(); asn::base::set();} type = 2; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<GlobalGNB_ID>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(GlobalGNB_ID)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_Globalen_gNB_ID() { set(mandatory); type=1;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
RespondingNodeType-EndcX2Removal ::= CHOICE {
	respond-eNB			ProtocolIE-Container	{{ENB-ENDCX2RemovalReqAckIEs}},
	respond-en-gNB		ProtocolIE-Container	{{En-gNB-ENDCX2RemovalReqAckIEs}},
	...
}
*/

struct RespondingNodeType_EndcX2Removal : asn::choice<2, 0, true>
{
	static constexpr const char* name() {return "RespondingNodeType-EndcX2Removal";}
	using parent_t = asn::choice<2, 0, true>;
	index_type get_index() const {return index;}
	bool is_unknown() const {return index == 3;}
	void set_unknown() { set_index(3);  }
	~RespondingNodeType_EndcX2Removal() {clear();}
	struct respond_eNB_t : ProtocolIE_Container<ENB_ENDCX2RemovalReqAckIEs>
	{
		static constexpr const char* name() {return "respond_eNB_t";}
		using parent_t = ProtocolIE_Container<ENB_ENDCX2RemovalReqAckIEs>;

	};
	struct respond_en_gNB_t : ProtocolIE_Container<En_gNB_ENDCX2RemovalReqAckIEs>
	{
		static constexpr const char* name() {return "respond_en_gNB_t";}
		using parent_t = ProtocolIE_Container<En_gNB_ENDCX2RemovalReqAckIEs>;

	};
	void clear()
	{
		switch(get_index())
		{
		case 1: var.destroy<respond_eNB_t>(); break;
		case 2: var.destroy<respond_en_gNB_t>(); break;
		}
		index = 0;
		base::clear();
	}
	template<typename V> bool decode(size_t idx, V& v)
	{
		clear();
		switch(idx)
		{
		case 1: set_index(1); return v(var.build<respond_eNB_t>());
		case 2: set_index(2); return v(var.build<respond_en_gNB_t>());
		}
		return false;

	}
	template<typename V> bool encode(V& v) const
	{
		switch(get_index())
		{
		case 1: return v(var.as<respond_eNB_t>());
		case 2: return v(var.as<respond_en_gNB_t>());
		}
		return false;
	}
	template<typename V> static inline void enumerate(V& v)
	{
		v.template operator()<respond_eNB_t>(1);
		v.template operator()<respond_en_gNB_t>(2);

	}
	respond_eNB_t& select_respond_eNB() { if(get_index() != 1) { clear(); set_index(1); return var.build<respond_eNB_t>();} return var.as<respond_eNB_t>();}
	respond_eNB_t const* get_respond_eNB() const { if(get_index() == 1) { return &var.as<respond_eNB_t>();} return nullptr; }
	respond_en_gNB_t& select_respond_en_gNB() { if(get_index() != 2) { clear(); set_index(2); return var.build<respond_en_gNB_t>();} return var.as<respond_en_gNB_t>();}
	respond_en_gNB_t const* get_respond_en_gNB() const { if(get_index() == 2) { return &var.as<respond_en_gNB_t>();} return nullptr; }
	private:
	void set_index(index_type i) {index = i; base::set();}
	union union_type
	{
		char dummy1[sizeof(respond_eNB_t)];
		char dummy2[sizeof(respond_en_gNB_t)];

	};
	asn::variant<sizeof(union_type)>	var;
	index_type	index {0};
};
/*
ENDCX2RemovalResponse-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-RespondingNodeType-EndcX2Removal		CRITICALITY reject	TYPE RespondingNodeType-EndcX2Removal		PRESENCE mandatory},
	...
}
*/

struct ENDCX2RemovalResponse_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_RespondingNodeType_EndcX2Removal() { set(id_RespondingNodeType_EndcX2Removal); type=1;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_RespondingNodeType_EndcX2Removal)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_RespondingNodeType_EndcX2Removal);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_RespondingNodeType_EndcX2Removal() { set(reject); type=1;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		RespondingNodeType_EndcX2Removal& select_id_RespondingNodeType_EndcX2Removal() { return set<RespondingNodeType_EndcX2Removal>(1); }
		RespondingNodeType_EndcX2Removal const* get_id_RespondingNodeType_EndcX2Removal() const { return get<RespondingNodeType_EndcX2Removal>(1); }
		bool is_unknown() const { return type == 2; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<RespondingNodeType_EndcX2Removal>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<RespondingNodeType_EndcX2Removal>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_RespondingNodeType_EndcX2Removal()); return true;
			case 2: if(type != 2) {clear(); asn::base::set();} type = 2; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<RespondingNodeType_EndcX2Removal>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(RespondingNodeType_EndcX2Removal)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_RespondingNodeType_EndcX2Removal() { set(mandatory); type=1;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
ENDCX2RemovalResponse ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{ENDCX2RemovalResponse-IEs}},
	...
}
*/

struct ENDCX2RemovalResponse : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "ENDCX2RemovalResponse";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<ENDCX2RemovalResponse_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<ENDCX2RemovalResponse_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
ENDCX2SetupFailure-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-Cause					CRITICALITY ignore		TYPE Cause								PRESENCE mandatory} |
	{ ID id-CriticalityDiagnostics	CRITICALITY ignore		TYPE CriticalityDiagnostics				PRESENCE optional } |
	{ ID id-TimeToWait				CRITICALITY ignore		TYPE TimeToWait							PRESENCE optional	},
	...
}
*/

struct ENDCX2SetupFailure_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 4; }
		void clear() {type = 0;}
		void select_id_Cause() { set(id_Cause); type=1;}
		void select_id_CriticalityDiagnostics() { set(id_CriticalityDiagnostics); type=2;}
		void select_id_TimeToWait() { set(id_TimeToWait); type=3;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_Cause)) { type = 1; return true; }
			else if(equal(id_CriticalityDiagnostics)) { type = 2; return true; }
			else if(equal(id_TimeToWait)) { type = 3; return true; }
			else { type = 4; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_Cause);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_CriticalityDiagnostics);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_TimeToWait);} return false;
			case 4: type = 4; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 4; }
		void clear() {type = 0;}
		void select_id_Cause() { set(ignore); type=1;}
		void select_id_CriticalityDiagnostics() { set(ignore); type=2;}
		void select_id_TimeToWait() { set(ignore); type=3;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else if(equal(ignore)) { type = 2; return true; }
			else if(equal(ignore)) { type = 3; return true; }
			else { type = 4; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(ignore);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(ignore);} return false;
			case 4: type = 4; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		Cause& select_id_Cause() { return set<Cause>(1); }
		Cause const* get_id_Cause() const { return get<Cause>(1); }
		CriticalityDiagnostics& select_id_CriticalityDiagnostics() { return set<CriticalityDiagnostics>(2); }
		CriticalityDiagnostics const* get_id_CriticalityDiagnostics() const { return get<CriticalityDiagnostics>(2); }
		TimeToWait& select_id_TimeToWait() { return set<TimeToWait>(3); }
		TimeToWait const* get_id_TimeToWait() const { return get<TimeToWait>(3); }
		bool is_unknown() const { return type == 4; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<Cause>(); break;
			case 2: var.destroy<CriticalityDiagnostics>(); break;
			case 3: var.destroy<TimeToWait>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<Cause>(1);
			v.template operator()<CriticalityDiagnostics>(2);
			v.template operator()<TimeToWait>(3);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_Cause()); return true;
			case 2: v(select_id_CriticalityDiagnostics()); return true;
			case 3: v(select_id_TimeToWait()); return true;
			case 4: if(type != 4) {clear(); asn::base::set();} type = 4; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<Cause>()); return true;
			case 2: v(var.as<CriticalityDiagnostics>()); return true;
			case 3: v(var.as<TimeToWait>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(Cause)];
			char dummy2[sizeof(CriticalityDiagnostics)];
			char dummy3[sizeof(TimeToWait)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 4; }
		void clear() {type = 0;}
		void select_id_Cause() { set(mandatory); type=1;}
		void select_id_CriticalityDiagnostics() { set(optional); type=2;}
		void select_id_TimeToWait() { set(optional); type=3;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(optional)) { type = 2; return true; }
			else if(equal(optional)) { type = 3; return true; }
			else { type = 4; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(optional);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(optional);} return false;
			case 4: type = 4; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
ENDCX2SetupFailure ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{ENDCX2SetupFailure-IEs}},
	...
}
*/

struct ENDCX2SetupFailure : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "ENDCX2SetupFailure";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<ENDCX2SetupFailure_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<ENDCX2SetupFailure_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
En-gNB-ENDCX2SetupReqIEs X2AP-PROTOCOL-IES ::= {
	{ ID id-Globalen-gNB-ID							CRITICALITY reject	TYPE GlobalGNB-ID										PRESENCE mandatory}|
	{ ID id-ServedNRcellsENDCX2ManagementList		CRITICALITY reject	TYPE ServedNRcellsENDCX2ManagementList			PRESENCE mandatory},
	...
}
*/

struct En_gNB_ENDCX2SetupReqIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 3; }
		void clear() {type = 0;}
		void select_id_Globalen_gNB_ID() { set(id_Globalen_gNB_ID); type=1;}
		void select_id_ServedNRcellsENDCX2ManagementList() { set(id_ServedNRcellsENDCX2ManagementList); type=2;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_Globalen_gNB_ID)) { type = 1; return true; }
			else if(equal(id_ServedNRcellsENDCX2ManagementList)) { type = 2; return true; }
			else { type = 3; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_Globalen_gNB_ID);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_ServedNRcellsENDCX2ManagementList);} return false;
			case 3: type = 3; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 3; }
		void clear() {type = 0;}
		void select_id_Globalen_gNB_ID() { set(reject); type=1;}
		void select_id_ServedNRcellsENDCX2ManagementList() { set(reject); type=2;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else if(equal(reject)) { type = 2; return true; }
			else { type = 3; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(reject);} return false;
			case 3: type = 3; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		GlobalGNB_ID& select_id_Globalen_gNB_ID() { return set<GlobalGNB_ID>(1); }
		GlobalGNB_ID const* get_id_Globalen_gNB_ID() const { return get<GlobalGNB_ID>(1); }
		ServedNRcellsENDCX2ManagementList& select_id_ServedNRcellsENDCX2ManagementList() { return set<ServedNRcellsENDCX2ManagementList>(2); }
		ServedNRcellsENDCX2ManagementList const* get_id_ServedNRcellsENDCX2ManagementList() const { return get<ServedNRcellsENDCX2ManagementList>(2); }
		bool is_unknown() const { return type == 3; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<GlobalGNB_ID>(); break;
			case 2: var.destroy<ServedNRcellsENDCX2ManagementList>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<GlobalGNB_ID>(1);
			v.template operator()<ServedNRcellsENDCX2ManagementList>(2);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_Globalen_gNB_ID()); return true;
			case 2: v(select_id_ServedNRcellsENDCX2ManagementList()); return true;
			case 3: if(type != 3) {clear(); asn::base::set();} type = 3; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<GlobalGNB_ID>()); return true;
			case 2: v(var.as<ServedNRcellsENDCX2ManagementList>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(GlobalGNB_ID)];
			char dummy2[sizeof(ServedNRcellsENDCX2ManagementList)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 3; }
		void clear() {type = 0;}
		void select_id_Globalen_gNB_ID() { set(mandatory); type=1;}
		void select_id_ServedNRcellsENDCX2ManagementList() { set(mandatory); type=2;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(mandatory)) { type = 2; return true; }
			else { type = 3; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 3: type = 3; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
InitiatingNodeType-EndcX2Setup ::= CHOICE {
	init-eNB				ProtocolIE-Container	{{ENB-ENDCX2SetupReqIEs}},
	init-en-gNB			ProtocolIE-Container	{{En-gNB-ENDCX2SetupReqIEs}},
	...
}
*/

struct InitiatingNodeType_EndcX2Setup : asn::choice<2, 0, true>
{
	static constexpr const char* name() {return "InitiatingNodeType-EndcX2Setup";}
	using parent_t = asn::choice<2, 0, true>;
	index_type get_index() const {return index;}
	bool is_unknown() const {return index == 3;}
	void set_unknown() { set_index(3);  }
	~InitiatingNodeType_EndcX2Setup() {clear();}
	struct init_eNB_t : ProtocolIE_Container<ENB_ENDCX2SetupReqIEs>
	{
		static constexpr const char* name() {return "init_eNB_t";}
		using parent_t = ProtocolIE_Container<ENB_ENDCX2SetupReqIEs>;

	};
	struct init_en_gNB_t : ProtocolIE_Container<En_gNB_ENDCX2SetupReqIEs>
	{
		static constexpr const char* name() {return "init_en_gNB_t";}
		using parent_t = ProtocolIE_Container<En_gNB_ENDCX2SetupReqIEs>;

	};
	void clear()
	{
		switch(get_index())
		{
		case 1: var.destroy<init_eNB_t>(); break;
		case 2: var.destroy<init_en_gNB_t>(); break;
		}
		index = 0;
		base::clear();
	}
	template<typename V> bool decode(size_t idx, V& v)
	{
		clear();
		switch(idx)
		{
		case 1: set_index(1); return v(var.build<init_eNB_t>());
		case 2: set_index(2); return v(var.build<init_en_gNB_t>());
		}
		return false;

	}
	template<typename V> bool encode(V& v) const
	{
		switch(get_index())
		{
		case 1: return v(var.as<init_eNB_t>());
		case 2: return v(var.as<init_en_gNB_t>());
		}
		return false;
	}
	template<typename V> static inline void enumerate(V& v)
	{
		v.template operator()<init_eNB_t>(1);
		v.template operator()<init_en_gNB_t>(2);

	}
	init_eNB_t& select_init_eNB() { if(get_index() != 1) { clear(); set_index(1); return var.build<init_eNB_t>();} return var.as<init_eNB_t>();}
	init_eNB_t const* get_init_eNB() const { if(get_index() == 1) { return &var.as<init_eNB_t>();} return nullptr; }
	init_en_gNB_t& select_init_en_gNB() { if(get_index() != 2) { clear(); set_index(2); return var.build<init_en_gNB_t>();} return var.as<init_en_gNB_t>();}
	init_en_gNB_t const* get_init_en_gNB() const { if(get_index() == 2) { return &var.as<init_en_gNB_t>();} return nullptr; }
	private:
	void set_index(index_type i) {index = i; base::set();}
	union union_type
	{
		char dummy1[sizeof(init_eNB_t)];
		char dummy2[sizeof(init_en_gNB_t)];

	};
	asn::variant<sizeof(union_type)>	var;
	index_type	index {0};
};
/*
ENDCX2SetupRequest-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-InitiatingNodeType-EndcX2Setup			CRITICALITY reject	TYPE InitiatingNodeType-EndcX2Setup		PRESENCE mandatory},
	...
}
*/

struct ENDCX2SetupRequest_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_InitiatingNodeType_EndcX2Setup() { set(id_InitiatingNodeType_EndcX2Setup); type=1;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_InitiatingNodeType_EndcX2Setup)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_InitiatingNodeType_EndcX2Setup);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_InitiatingNodeType_EndcX2Setup() { set(reject); type=1;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		InitiatingNodeType_EndcX2Setup& select_id_InitiatingNodeType_EndcX2Setup() { return set<InitiatingNodeType_EndcX2Setup>(1); }
		InitiatingNodeType_EndcX2Setup const* get_id_InitiatingNodeType_EndcX2Setup() const { return get<InitiatingNodeType_EndcX2Setup>(1); }
		bool is_unknown() const { return type == 2; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<InitiatingNodeType_EndcX2Setup>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<InitiatingNodeType_EndcX2Setup>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_InitiatingNodeType_EndcX2Setup()); return true;
			case 2: if(type != 2) {clear(); asn::base::set();} type = 2; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<InitiatingNodeType_EndcX2Setup>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(InitiatingNodeType_EndcX2Setup)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_InitiatingNodeType_EndcX2Setup() { set(mandatory); type=1;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
ENDCX2SetupRequest ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{ENDCX2SetupRequest-IEs}},
	...
}
*/

struct ENDCX2SetupRequest : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "ENDCX2SetupRequest";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<ENDCX2SetupRequest_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<ENDCX2SetupRequest_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
En-gNB-ENDCX2SetupReqAckIEs X2AP-PROTOCOL-IES ::= {
	{ ID id-Globalen-gNB-ID							CRITICALITY reject	TYPE GlobalGNB-ID										PRESENCE mandatory}|
	{ ID id-ServedNRcellsENDCX2ManagementList		CRITICALITY reject	TYPE ServedNRcellsENDCX2ManagementList			PRESENCE mandatory},
	...
}
*/

struct En_gNB_ENDCX2SetupReqAckIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 3; }
		void clear() {type = 0;}
		void select_id_Globalen_gNB_ID() { set(id_Globalen_gNB_ID); type=1;}
		void select_id_ServedNRcellsENDCX2ManagementList() { set(id_ServedNRcellsENDCX2ManagementList); type=2;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_Globalen_gNB_ID)) { type = 1; return true; }
			else if(equal(id_ServedNRcellsENDCX2ManagementList)) { type = 2; return true; }
			else { type = 3; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_Globalen_gNB_ID);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_ServedNRcellsENDCX2ManagementList);} return false;
			case 3: type = 3; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 3; }
		void clear() {type = 0;}
		void select_id_Globalen_gNB_ID() { set(reject); type=1;}
		void select_id_ServedNRcellsENDCX2ManagementList() { set(reject); type=2;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else if(equal(reject)) { type = 2; return true; }
			else { type = 3; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(reject);} return false;
			case 3: type = 3; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		GlobalGNB_ID& select_id_Globalen_gNB_ID() { return set<GlobalGNB_ID>(1); }
		GlobalGNB_ID const* get_id_Globalen_gNB_ID() const { return get<GlobalGNB_ID>(1); }
		ServedNRcellsENDCX2ManagementList& select_id_ServedNRcellsENDCX2ManagementList() { return set<ServedNRcellsENDCX2ManagementList>(2); }
		ServedNRcellsENDCX2ManagementList const* get_id_ServedNRcellsENDCX2ManagementList() const { return get<ServedNRcellsENDCX2ManagementList>(2); }
		bool is_unknown() const { return type == 3; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<GlobalGNB_ID>(); break;
			case 2: var.destroy<ServedNRcellsENDCX2ManagementList>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<GlobalGNB_ID>(1);
			v.template operator()<ServedNRcellsENDCX2ManagementList>(2);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_Globalen_gNB_ID()); return true;
			case 2: v(select_id_ServedNRcellsENDCX2ManagementList()); return true;
			case 3: if(type != 3) {clear(); asn::base::set();} type = 3; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<GlobalGNB_ID>()); return true;
			case 2: v(var.as<ServedNRcellsENDCX2ManagementList>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(GlobalGNB_ID)];
			char dummy2[sizeof(ServedNRcellsENDCX2ManagementList)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 3; }
		void clear() {type = 0;}
		void select_id_Globalen_gNB_ID() { set(mandatory); type=1;}
		void select_id_ServedNRcellsENDCX2ManagementList() { set(mandatory); type=2;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(mandatory)) { type = 2; return true; }
			else { type = 3; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 3: type = 3; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
RespondingNodeType-EndcX2Setup ::= CHOICE {
	respond-eNB			ProtocolIE-Container	{{ENB-ENDCX2SetupReqAckIEs}},
	respond-en-gNB		ProtocolIE-Container	{{En-gNB-ENDCX2SetupReqAckIEs}},
	...
}
*/

struct RespondingNodeType_EndcX2Setup : asn::choice<2, 0, true>
{
	static constexpr const char* name() {return "RespondingNodeType-EndcX2Setup";}
	using parent_t = asn::choice<2, 0, true>;
	index_type get_index() const {return index;}
	bool is_unknown() const {return index == 3;}
	void set_unknown() { set_index(3);  }
	~RespondingNodeType_EndcX2Setup() {clear();}
	struct respond_eNB_t : ProtocolIE_Container<ENB_ENDCX2SetupReqAckIEs>
	{
		static constexpr const char* name() {return "respond_eNB_t";}
		using parent_t = ProtocolIE_Container<ENB_ENDCX2SetupReqAckIEs>;

	};
	struct respond_en_gNB_t : ProtocolIE_Container<En_gNB_ENDCX2SetupReqAckIEs>
	{
		static constexpr const char* name() {return "respond_en_gNB_t";}
		using parent_t = ProtocolIE_Container<En_gNB_ENDCX2SetupReqAckIEs>;

	};
	void clear()
	{
		switch(get_index())
		{
		case 1: var.destroy<respond_eNB_t>(); break;
		case 2: var.destroy<respond_en_gNB_t>(); break;
		}
		index = 0;
		base::clear();
	}
	template<typename V> bool decode(size_t idx, V& v)
	{
		clear();
		switch(idx)
		{
		case 1: set_index(1); return v(var.build<respond_eNB_t>());
		case 2: set_index(2); return v(var.build<respond_en_gNB_t>());
		}
		return false;

	}
	template<typename V> bool encode(V& v) const
	{
		switch(get_index())
		{
		case 1: return v(var.as<respond_eNB_t>());
		case 2: return v(var.as<respond_en_gNB_t>());
		}
		return false;
	}
	template<typename V> static inline void enumerate(V& v)
	{
		v.template operator()<respond_eNB_t>(1);
		v.template operator()<respond_en_gNB_t>(2);

	}
	respond_eNB_t& select_respond_eNB() { if(get_index() != 1) { clear(); set_index(1); return var.build<respond_eNB_t>();} return var.as<respond_eNB_t>();}
	respond_eNB_t const* get_respond_eNB() const { if(get_index() == 1) { return &var.as<respond_eNB_t>();} return nullptr; }
	respond_en_gNB_t& select_respond_en_gNB() { if(get_index() != 2) { clear(); set_index(2); return var.build<respond_en_gNB_t>();} return var.as<respond_en_gNB_t>();}
	respond_en_gNB_t const* get_respond_en_gNB() const { if(get_index() == 2) { return &var.as<respond_en_gNB_t>();} return nullptr; }
	private:
	void set_index(index_type i) {index = i; base::set();}
	union union_type
	{
		char dummy1[sizeof(respond_eNB_t)];
		char dummy2[sizeof(respond_en_gNB_t)];

	};
	asn::variant<sizeof(union_type)>	var;
	index_type	index {0};
};
/*
ENDCX2SetupResponse-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-RespondingNodeType-EndcX2Setup		CRITICALITY reject	TYPE RespondingNodeType-EndcX2Setup		PRESENCE mandatory},
	...
}
*/

struct ENDCX2SetupResponse_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_RespondingNodeType_EndcX2Setup() { set(id_RespondingNodeType_EndcX2Setup); type=1;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_RespondingNodeType_EndcX2Setup)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_RespondingNodeType_EndcX2Setup);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_RespondingNodeType_EndcX2Setup() { set(reject); type=1;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		RespondingNodeType_EndcX2Setup& select_id_RespondingNodeType_EndcX2Setup() { return set<RespondingNodeType_EndcX2Setup>(1); }
		RespondingNodeType_EndcX2Setup const* get_id_RespondingNodeType_EndcX2Setup() const { return get<RespondingNodeType_EndcX2Setup>(1); }
		bool is_unknown() const { return type == 2; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<RespondingNodeType_EndcX2Setup>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<RespondingNodeType_EndcX2Setup>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_RespondingNodeType_EndcX2Setup()); return true;
			case 2: if(type != 2) {clear(); asn::base::set();} type = 2; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<RespondingNodeType_EndcX2Setup>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(RespondingNodeType_EndcX2Setup)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_RespondingNodeType_EndcX2Setup() { set(mandatory); type=1;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
ENDCX2SetupResponse ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{ENDCX2SetupResponse-IEs}},
	...
}
*/

struct ENDCX2SetupResponse : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "ENDCX2SetupResponse";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<ENDCX2SetupResponse_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<ENDCX2SetupResponse_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
ListofEUTRACellsinNRCoordinationReq ::= SEQUENCE (SIZE (1..maxCellineNB)) OF ECGI
*/

struct ListofEUTRACellsinNRCoordinationReq_elm : ECGI
{
	static constexpr const char* name() {return "ListofEUTRACellsinNRCoordinationReq_elm";}
	using parent_t = ECGI;

};
struct ListofEUTRACellsinNRCoordinationReq : asn::sequenceof<ListofEUTRACellsinNRCoordinationReq_elm>
{
	static constexpr const char* name() {return "ListofEUTRACellsinNRCoordinationReq";}
	using parent_t = asn::sequenceof<ListofEUTRACellsinNRCoordinationReq_elm>;
	using constraint_t = asn::constraints<false,asn::span<1,  maxCellineNB >>;

};
/*
ListofNRCellsinNRCoordinationReq ::= SEQUENCE (SIZE (0..maxnoNRcellsSpectrumSharingWithE-UTRA)) OF NRCGI
*/

struct ListofNRCellsinNRCoordinationReq_elm : NRCGI
{
	static constexpr const char* name() {return "ListofNRCellsinNRCoordinationReq_elm";}
	using parent_t = NRCGI;

};
struct ListofNRCellsinNRCoordinationReq : asn::sequenceof<ListofNRCellsinNRCoordinationReq_elm>
{
	static constexpr const char* name() {return "ListofNRCellsinNRCoordinationReq";}
	using parent_t = asn::sequenceof<ListofNRCellsinNRCoordinationReq_elm>;
	using constraint_t = asn::constraints<false,asn::span<0,  maxnoNRcellsSpectrumSharingWithE_UTRA >>;

};
/*
En-gNB-EUTRA-NRCellResourceCoordinationReqIEs X2AP-PROTOCOL-IES ::= {
	{ ID id-DataTrafficResourceIndication			CRITICALITY reject	TYPE DataTrafficResourceIndication				PRESENCE mandatory}|
	{ ID id-ListofEUTRACellsinNRCoordinationReq		CRITICALITY reject	TYPE ListofEUTRACellsinNRCoordinationReq		PRESENCE mandatory }|
	{ ID id-SpectrumSharingGroupID					CRITICALITY reject	TYPE SpectrumSharingGroupID						PRESENCE mandatory}|
	{ ID id-ListofNRCellsinNRCoordinationReq		CRITICALITY reject	TYPE ListofNRCellsinNRCoordinationReq			PRESENCE mandatory},
	...
}
*/

struct En_gNB_EUTRA_NRCellResourceCoordinationReqIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 5; }
		void clear() {type = 0;}
		void select_id_DataTrafficResourceIndication() { set(id_DataTrafficResourceIndication); type=1;}
		void select_id_ListofEUTRACellsinNRCoordinationReq() { set(id_ListofEUTRACellsinNRCoordinationReq); type=2;}
		void select_id_SpectrumSharingGroupID() { set(id_SpectrumSharingGroupID); type=3;}
		void select_id_ListofNRCellsinNRCoordinationReq() { set(id_ListofNRCellsinNRCoordinationReq); type=4;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_DataTrafficResourceIndication)) { type = 1; return true; }
			else if(equal(id_ListofEUTRACellsinNRCoordinationReq)) { type = 2; return true; }
			else if(equal(id_SpectrumSharingGroupID)) { type = 3; return true; }
			else if(equal(id_ListofNRCellsinNRCoordinationReq)) { type = 4; return true; }
			else { type = 5; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_DataTrafficResourceIndication);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_ListofEUTRACellsinNRCoordinationReq);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_SpectrumSharingGroupID);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(id_ListofNRCellsinNRCoordinationReq);} return false;
			case 5: type = 5; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 5; }
		void clear() {type = 0;}
		void select_id_DataTrafficResourceIndication() { set(reject); type=1;}
		void select_id_ListofEUTRACellsinNRCoordinationReq() { set(reject); type=2;}
		void select_id_SpectrumSharingGroupID() { set(reject); type=3;}
		void select_id_ListofNRCellsinNRCoordinationReq() { set(reject); type=4;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else if(equal(reject)) { type = 2; return true; }
			else if(equal(reject)) { type = 3; return true; }
			else if(equal(reject)) { type = 4; return true; }
			else { type = 5; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(reject);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(reject);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(reject);} return false;
			case 5: type = 5; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		DataTrafficResourceIndication& select_id_DataTrafficResourceIndication() { return set<DataTrafficResourceIndication>(1); }
		DataTrafficResourceIndication const* get_id_DataTrafficResourceIndication() const { return get<DataTrafficResourceIndication>(1); }
		ListofEUTRACellsinNRCoordinationReq& select_id_ListofEUTRACellsinNRCoordinationReq() { return set<ListofEUTRACellsinNRCoordinationReq>(2); }
		ListofEUTRACellsinNRCoordinationReq const* get_id_ListofEUTRACellsinNRCoordinationReq() const { return get<ListofEUTRACellsinNRCoordinationReq>(2); }
		SpectrumSharingGroupID& select_id_SpectrumSharingGroupID() { return set<SpectrumSharingGroupID>(3); }
		SpectrumSharingGroupID const* get_id_SpectrumSharingGroupID() const { return get<SpectrumSharingGroupID>(3); }
		ListofNRCellsinNRCoordinationReq& select_id_ListofNRCellsinNRCoordinationReq() { return set<ListofNRCellsinNRCoordinationReq>(4); }
		ListofNRCellsinNRCoordinationReq const* get_id_ListofNRCellsinNRCoordinationReq() const { return get<ListofNRCellsinNRCoordinationReq>(4); }
		bool is_unknown() const { return type == 5; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<DataTrafficResourceIndication>(); break;
			case 2: var.destroy<ListofEUTRACellsinNRCoordinationReq>(); break;
			case 3: var.destroy<SpectrumSharingGroupID>(); break;
			case 4: var.destroy<ListofNRCellsinNRCoordinationReq>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<DataTrafficResourceIndication>(1);
			v.template operator()<ListofEUTRACellsinNRCoordinationReq>(2);
			v.template operator()<SpectrumSharingGroupID>(3);
			v.template operator()<ListofNRCellsinNRCoordinationReq>(4);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_DataTrafficResourceIndication()); return true;
			case 2: v(select_id_ListofEUTRACellsinNRCoordinationReq()); return true;
			case 3: v(select_id_SpectrumSharingGroupID()); return true;
			case 4: v(select_id_ListofNRCellsinNRCoordinationReq()); return true;
			case 5: if(type != 5) {clear(); asn::base::set();} type = 5; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<DataTrafficResourceIndication>()); return true;
			case 2: v(var.as<ListofEUTRACellsinNRCoordinationReq>()); return true;
			case 3: v(var.as<SpectrumSharingGroupID>()); return true;
			case 4: v(var.as<ListofNRCellsinNRCoordinationReq>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(DataTrafficResourceIndication)];
			char dummy2[sizeof(ListofEUTRACellsinNRCoordinationReq)];
			char dummy3[sizeof(ListofNRCellsinNRCoordinationReq)];
			char dummy4[sizeof(SpectrumSharingGroupID)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 5; }
		void clear() {type = 0;}
		void select_id_DataTrafficResourceIndication() { set(mandatory); type=1;}
		void select_id_ListofEUTRACellsinNRCoordinationReq() { set(mandatory); type=2;}
		void select_id_SpectrumSharingGroupID() { set(mandatory); type=3;}
		void select_id_ListofNRCellsinNRCoordinationReq() { set(mandatory); type=4;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(mandatory)) { type = 2; return true; }
			else if(equal(mandatory)) { type = 3; return true; }
			else if(equal(mandatory)) { type = 4; return true; }
			else { type = 5; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 5: type = 5; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
InitiatingNodeType-EutranrCellResourceCoordination ::= CHOICE {
	initiate-eNB			ProtocolIE-Container	{{ENB-EUTRA-NRCellResourceCoordinationReqIEs}},
	initiate-en-gNB			ProtocolIE-Container	{{En-gNB-EUTRA-NRCellResourceCoordinationReqIEs}},
	...
}
*/

struct InitiatingNodeType_EutranrCellResourceCoordination : asn::choice<2, 0, true>
{
	static constexpr const char* name() {return "InitiatingNodeType-EutranrCellResourceCoordination";}
	using parent_t = asn::choice<2, 0, true>;
	index_type get_index() const {return index;}
	bool is_unknown() const {return index == 3;}
	void set_unknown() { set_index(3);  }
	~InitiatingNodeType_EutranrCellResourceCoordination() {clear();}
	struct initiate_eNB_t : ProtocolIE_Container<ENB_EUTRA_NRCellResourceCoordinationReqIEs>
	{
		static constexpr const char* name() {return "initiate_eNB_t";}
		using parent_t = ProtocolIE_Container<ENB_EUTRA_NRCellResourceCoordinationReqIEs>;

	};
	struct initiate_en_gNB_t : ProtocolIE_Container<En_gNB_EUTRA_NRCellResourceCoordinationReqIEs>
	{
		static constexpr const char* name() {return "initiate_en_gNB_t";}
		using parent_t = ProtocolIE_Container<En_gNB_EUTRA_NRCellResourceCoordinationReqIEs>;

	};
	void clear()
	{
		switch(get_index())
		{
		case 1: var.destroy<initiate_eNB_t>(); break;
		case 2: var.destroy<initiate_en_gNB_t>(); break;
		}
		index = 0;
		base::clear();
	}
	template<typename V> bool decode(size_t idx, V& v)
	{
		clear();
		switch(idx)
		{
		case 1: set_index(1); return v(var.build<initiate_eNB_t>());
		case 2: set_index(2); return v(var.build<initiate_en_gNB_t>());
		}
		return false;

	}
	template<typename V> bool encode(V& v) const
	{
		switch(get_index())
		{
		case 1: return v(var.as<initiate_eNB_t>());
		case 2: return v(var.as<initiate_en_gNB_t>());
		}
		return false;
	}
	template<typename V> static inline void enumerate(V& v)
	{
		v.template operator()<initiate_eNB_t>(1);
		v.template operator()<initiate_en_gNB_t>(2);

	}
	initiate_eNB_t& select_initiate_eNB() { if(get_index() != 1) { clear(); set_index(1); return var.build<initiate_eNB_t>();} return var.as<initiate_eNB_t>();}
	initiate_eNB_t const* get_initiate_eNB() const { if(get_index() == 1) { return &var.as<initiate_eNB_t>();} return nullptr; }
	initiate_en_gNB_t& select_initiate_en_gNB() { if(get_index() != 2) { clear(); set_index(2); return var.build<initiate_en_gNB_t>();} return var.as<initiate_en_gNB_t>();}
	initiate_en_gNB_t const* get_initiate_en_gNB() const { if(get_index() == 2) { return &var.as<initiate_en_gNB_t>();} return nullptr; }
	private:
	void set_index(index_type i) {index = i; base::set();}
	union union_type
	{
		char dummy1[sizeof(initiate_eNB_t)];
		char dummy2[sizeof(initiate_en_gNB_t)];

	};
	asn::variant<sizeof(union_type)>	var;
	index_type	index {0};
};
/*
EUTRANRCellResourceCoordinationRequest-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-InitiatingNodeType-EutranrCellResourceCoordination		CRITICALITY reject	TYPE InitiatingNodeType-EutranrCellResourceCoordination			PRESENCE mandatory},
	...
}
*/

struct EUTRANRCellResourceCoordinationRequest_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_InitiatingNodeType_EutranrCellResourceCoordination() { set(id_InitiatingNodeType_EutranrCellResourceCoordination); type=1;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_InitiatingNodeType_EutranrCellResourceCoordination)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_InitiatingNodeType_EutranrCellResourceCoordination);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_InitiatingNodeType_EutranrCellResourceCoordination() { set(reject); type=1;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		InitiatingNodeType_EutranrCellResourceCoordination& select_id_InitiatingNodeType_EutranrCellResourceCoordination() { return set<InitiatingNodeType_EutranrCellResourceCoordination>(1); }
		InitiatingNodeType_EutranrCellResourceCoordination const* get_id_InitiatingNodeType_EutranrCellResourceCoordination() const { return get<InitiatingNodeType_EutranrCellResourceCoordination>(1); }
		bool is_unknown() const { return type == 2; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<InitiatingNodeType_EutranrCellResourceCoordination>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<InitiatingNodeType_EutranrCellResourceCoordination>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_InitiatingNodeType_EutranrCellResourceCoordination()); return true;
			case 2: if(type != 2) {clear(); asn::base::set();} type = 2; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<InitiatingNodeType_EutranrCellResourceCoordination>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(InitiatingNodeType_EutranrCellResourceCoordination)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_InitiatingNodeType_EutranrCellResourceCoordination() { set(mandatory); type=1;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
EUTRANRCellResourceCoordinationRequest ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container		{{EUTRANRCellResourceCoordinationRequest-IEs}},
	...
}
*/

struct EUTRANRCellResourceCoordinationRequest : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "EUTRANRCellResourceCoordinationRequest";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<EUTRANRCellResourceCoordinationRequest_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<EUTRANRCellResourceCoordinationRequest_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
ListofNRCellsinNRCoordinationResp ::= SEQUENCE (SIZE (0..maxnoNRcellsSpectrumSharingWithE-UTRA)) OF NRCGI
*/

struct ListofNRCellsinNRCoordinationResp_elm : NRCGI
{
	static constexpr const char* name() {return "ListofNRCellsinNRCoordinationResp_elm";}
	using parent_t = NRCGI;

};
struct ListofNRCellsinNRCoordinationResp : asn::sequenceof<ListofNRCellsinNRCoordinationResp_elm>
{
	static constexpr const char* name() {return "ListofNRCellsinNRCoordinationResp";}
	using parent_t = asn::sequenceof<ListofNRCellsinNRCoordinationResp_elm>;
	using constraint_t = asn::constraints<false,asn::span<0,  maxnoNRcellsSpectrumSharingWithE_UTRA >>;

};
/*
En-gNB-EUTRA-NRCellResourceCoordinationReqAckIEs X2AP-PROTOCOL-IES ::= {
	{ ID id-DataTrafficResourceIndication		CRITICALITY reject	TYPE DataTrafficResourceIndication			PRESENCE mandatory}|
	{ ID id-SpectrumSharingGroupID				CRITICALITY reject	TYPE SpectrumSharingGroupID					PRESENCE mandatory}|
	{ ID id-ListofNRCellsinNRCoordinationResp	CRITICALITY reject	TYPE ListofNRCellsinNRCoordinationResp		PRESENCE mandatory},


	...
}
*/

struct En_gNB_EUTRA_NRCellResourceCoordinationReqAckIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 4; }
		void clear() {type = 0;}
		void select_id_DataTrafficResourceIndication() { set(id_DataTrafficResourceIndication); type=1;}
		void select_id_SpectrumSharingGroupID() { set(id_SpectrumSharingGroupID); type=2;}
		void select_id_ListofNRCellsinNRCoordinationResp() { set(id_ListofNRCellsinNRCoordinationResp); type=3;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_DataTrafficResourceIndication)) { type = 1; return true; }
			else if(equal(id_SpectrumSharingGroupID)) { type = 2; return true; }
			else if(equal(id_ListofNRCellsinNRCoordinationResp)) { type = 3; return true; }
			else { type = 4; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_DataTrafficResourceIndication);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_SpectrumSharingGroupID);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_ListofNRCellsinNRCoordinationResp);} return false;
			case 4: type = 4; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 4; }
		void clear() {type = 0;}
		void select_id_DataTrafficResourceIndication() { set(reject); type=1;}
		void select_id_SpectrumSharingGroupID() { set(reject); type=2;}
		void select_id_ListofNRCellsinNRCoordinationResp() { set(reject); type=3;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else if(equal(reject)) { type = 2; return true; }
			else if(equal(reject)) { type = 3; return true; }
			else { type = 4; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(reject);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(reject);} return false;
			case 4: type = 4; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		DataTrafficResourceIndication& select_id_DataTrafficResourceIndication() { return set<DataTrafficResourceIndication>(1); }
		DataTrafficResourceIndication const* get_id_DataTrafficResourceIndication() const { return get<DataTrafficResourceIndication>(1); }
		SpectrumSharingGroupID& select_id_SpectrumSharingGroupID() { return set<SpectrumSharingGroupID>(2); }
		SpectrumSharingGroupID const* get_id_SpectrumSharingGroupID() const { return get<SpectrumSharingGroupID>(2); }
		ListofNRCellsinNRCoordinationResp& select_id_ListofNRCellsinNRCoordinationResp() { return set<ListofNRCellsinNRCoordinationResp>(3); }
		ListofNRCellsinNRCoordinationResp const* get_id_ListofNRCellsinNRCoordinationResp() const { return get<ListofNRCellsinNRCoordinationResp>(3); }
		bool is_unknown() const { return type == 4; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<DataTrafficResourceIndication>(); break;
			case 2: var.destroy<SpectrumSharingGroupID>(); break;
			case 3: var.destroy<ListofNRCellsinNRCoordinationResp>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<DataTrafficResourceIndication>(1);
			v.template operator()<SpectrumSharingGroupID>(2);
			v.template operator()<ListofNRCellsinNRCoordinationResp>(3);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_DataTrafficResourceIndication()); return true;
			case 2: v(select_id_SpectrumSharingGroupID()); return true;
			case 3: v(select_id_ListofNRCellsinNRCoordinationResp()); return true;
			case 4: if(type != 4) {clear(); asn::base::set();} type = 4; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<DataTrafficResourceIndication>()); return true;
			case 2: v(var.as<SpectrumSharingGroupID>()); return true;
			case 3: v(var.as<ListofNRCellsinNRCoordinationResp>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(DataTrafficResourceIndication)];
			char dummy2[sizeof(ListofNRCellsinNRCoordinationResp)];
			char dummy3[sizeof(SpectrumSharingGroupID)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 4; }
		void clear() {type = 0;}
		void select_id_DataTrafficResourceIndication() { set(mandatory); type=1;}
		void select_id_SpectrumSharingGroupID() { set(mandatory); type=2;}
		void select_id_ListofNRCellsinNRCoordinationResp() { set(mandatory); type=3;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(mandatory)) { type = 2; return true; }
			else if(equal(mandatory)) { type = 3; return true; }
			else { type = 4; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 4: type = 4; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
RespondingNodeType-EutranrCellResourceCoordination ::= CHOICE {
	respond-eNB			ProtocolIE-Container	{{ENB-EUTRA-NRCellResourceCoordinationReqAckIEs}},
	respond-en-gNB		ProtocolIE-Container	{{En-gNB-EUTRA-NRCellResourceCoordinationReqAckIEs}},
	...
}
*/

struct RespondingNodeType_EutranrCellResourceCoordination : asn::choice<2, 0, true>
{
	static constexpr const char* name() {return "RespondingNodeType-EutranrCellResourceCoordination";}
	using parent_t = asn::choice<2, 0, true>;
	index_type get_index() const {return index;}
	bool is_unknown() const {return index == 3;}
	void set_unknown() { set_index(3);  }
	~RespondingNodeType_EutranrCellResourceCoordination() {clear();}
	struct respond_eNB_t : ProtocolIE_Container<ENB_EUTRA_NRCellResourceCoordinationReqAckIEs>
	{
		static constexpr const char* name() {return "respond_eNB_t";}
		using parent_t = ProtocolIE_Container<ENB_EUTRA_NRCellResourceCoordinationReqAckIEs>;

	};
	struct respond_en_gNB_t : ProtocolIE_Container<En_gNB_EUTRA_NRCellResourceCoordinationReqAckIEs>
	{
		static constexpr const char* name() {return "respond_en_gNB_t";}
		using parent_t = ProtocolIE_Container<En_gNB_EUTRA_NRCellResourceCoordinationReqAckIEs>;

	};
	void clear()
	{
		switch(get_index())
		{
		case 1: var.destroy<respond_eNB_t>(); break;
		case 2: var.destroy<respond_en_gNB_t>(); break;
		}
		index = 0;
		base::clear();
	}
	template<typename V> bool decode(size_t idx, V& v)
	{
		clear();
		switch(idx)
		{
		case 1: set_index(1); return v(var.build<respond_eNB_t>());
		case 2: set_index(2); return v(var.build<respond_en_gNB_t>());
		}
		return false;

	}
	template<typename V> bool encode(V& v) const
	{
		switch(get_index())
		{
		case 1: return v(var.as<respond_eNB_t>());
		case 2: return v(var.as<respond_en_gNB_t>());
		}
		return false;
	}
	template<typename V> static inline void enumerate(V& v)
	{
		v.template operator()<respond_eNB_t>(1);
		v.template operator()<respond_en_gNB_t>(2);

	}
	respond_eNB_t& select_respond_eNB() { if(get_index() != 1) { clear(); set_index(1); return var.build<respond_eNB_t>();} return var.as<respond_eNB_t>();}
	respond_eNB_t const* get_respond_eNB() const { if(get_index() == 1) { return &var.as<respond_eNB_t>();} return nullptr; }
	respond_en_gNB_t& select_respond_en_gNB() { if(get_index() != 2) { clear(); set_index(2); return var.build<respond_en_gNB_t>();} return var.as<respond_en_gNB_t>();}
	respond_en_gNB_t const* get_respond_en_gNB() const { if(get_index() == 2) { return &var.as<respond_en_gNB_t>();} return nullptr; }
	private:
	void set_index(index_type i) {index = i; base::set();}
	union union_type
	{
		char dummy1[sizeof(respond_eNB_t)];
		char dummy2[sizeof(respond_en_gNB_t)];

	};
	asn::variant<sizeof(union_type)>	var;
	index_type	index {0};
};
/*
EUTRANRCellResourceCoordinationResponse-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-RespondingNodeType-EutranrCellResourceCoordination		CRITICALITY reject	TYPE RespondingNodeType-EutranrCellResourceCoordination			PRESENCE mandatory},
	...
}
*/

struct EUTRANRCellResourceCoordinationResponse_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_RespondingNodeType_EutranrCellResourceCoordination() { set(id_RespondingNodeType_EutranrCellResourceCoordination); type=1;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_RespondingNodeType_EutranrCellResourceCoordination)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_RespondingNodeType_EutranrCellResourceCoordination);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_RespondingNodeType_EutranrCellResourceCoordination() { set(reject); type=1;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		RespondingNodeType_EutranrCellResourceCoordination& select_id_RespondingNodeType_EutranrCellResourceCoordination() { return set<RespondingNodeType_EutranrCellResourceCoordination>(1); }
		RespondingNodeType_EutranrCellResourceCoordination const* get_id_RespondingNodeType_EutranrCellResourceCoordination() const { return get<RespondingNodeType_EutranrCellResourceCoordination>(1); }
		bool is_unknown() const { return type == 2; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<RespondingNodeType_EutranrCellResourceCoordination>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<RespondingNodeType_EutranrCellResourceCoordination>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_RespondingNodeType_EutranrCellResourceCoordination()); return true;
			case 2: if(type != 2) {clear(); asn::base::set();} type = 2; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<RespondingNodeType_EutranrCellResourceCoordination>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(RespondingNodeType_EutranrCellResourceCoordination)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_RespondingNodeType_EutranrCellResourceCoordination() { set(mandatory); type=1;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
EUTRANRCellResourceCoordinationResponse ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container		{{EUTRANRCellResourceCoordinationResponse-IEs}},
	...
}
*/

struct EUTRANRCellResourceCoordinationResponse : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "EUTRANRCellResourceCoordinationResponse";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<EUTRANRCellResourceCoordinationResponse_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<EUTRANRCellResourceCoordinationResponse_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
ErrorIndication-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-Old-eNB-UE-X2AP-ID					CRITICALITY ignore	TYPE UE-X2AP-ID					PRESENCE optional}|
	{ ID id-New-eNB-UE-X2AP-ID					CRITICALITY ignore	TYPE UE-X2AP-ID					PRESENCE optional}|
	{ ID id-Cause								CRITICALITY ignore	TYPE Cause						PRESENCE optional}|
	{ ID id-CriticalityDiagnostics				CRITICALITY ignore	TYPE CriticalityDiagnostics		PRESENCE optional}|
	{ ID id-Old-eNB-UE-X2AP-ID-Extension		CRITICALITY ignore	TYPE UE-X2AP-ID-Extension		PRESENCE optional}|
	{ ID id-New-eNB-UE-X2AP-ID-Extension		CRITICALITY ignore	TYPE UE-X2AP-ID-Extension		PRESENCE optional}|
	{ ID id-Old-SgNB-UE-X2AP-ID					CRITICALITY ignore	TYPE SgNB-UE-X2AP-ID			PRESENCE optional},
	...
}
*/

struct ErrorIndication_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 8; }
		void clear() {type = 0;}
		void select_id_Old_eNB_UE_X2AP_ID() { set(id_Old_eNB_UE_X2AP_ID); type=1;}
		void select_id_New_eNB_UE_X2AP_ID() { set(id_New_eNB_UE_X2AP_ID); type=2;}
		void select_id_Cause() { set(id_Cause); type=3;}
		void select_id_CriticalityDiagnostics() { set(id_CriticalityDiagnostics); type=4;}
		void select_id_Old_eNB_UE_X2AP_ID_Extension() { set(id_Old_eNB_UE_X2AP_ID_Extension); type=5;}
		void select_id_New_eNB_UE_X2AP_ID_Extension() { set(id_New_eNB_UE_X2AP_ID_Extension); type=6;}
		void select_id_Old_SgNB_UE_X2AP_ID() { set(id_Old_SgNB_UE_X2AP_ID); type=7;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_Old_eNB_UE_X2AP_ID)) { type = 1; return true; }
			else if(equal(id_New_eNB_UE_X2AP_ID)) { type = 2; return true; }
			else if(equal(id_Cause)) { type = 3; return true; }
			else if(equal(id_CriticalityDiagnostics)) { type = 4; return true; }
			else if(equal(id_Old_eNB_UE_X2AP_ID_Extension)) { type = 5; return true; }
			else if(equal(id_New_eNB_UE_X2AP_ID_Extension)) { type = 6; return true; }
			else if(equal(id_Old_SgNB_UE_X2AP_ID)) { type = 7; return true; }
			else { type = 8; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_Old_eNB_UE_X2AP_ID);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_New_eNB_UE_X2AP_ID);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_Cause);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(id_CriticalityDiagnostics);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(id_Old_eNB_UE_X2AP_ID_Extension);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(id_New_eNB_UE_X2AP_ID_Extension);} return false;
			case 7: type = 7; if(v(ref_nested())) { return equal(id_Old_SgNB_UE_X2AP_ID);} return false;
			case 8: type = 8; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 8; }
		void clear() {type = 0;}
		void select_id_Old_eNB_UE_X2AP_ID() { set(ignore); type=1;}
		void select_id_New_eNB_UE_X2AP_ID() { set(ignore); type=2;}
		void select_id_Cause() { set(ignore); type=3;}
		void select_id_CriticalityDiagnostics() { set(ignore); type=4;}
		void select_id_Old_eNB_UE_X2AP_ID_Extension() { set(ignore); type=5;}
		void select_id_New_eNB_UE_X2AP_ID_Extension() { set(ignore); type=6;}
		void select_id_Old_SgNB_UE_X2AP_ID() { set(ignore); type=7;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else if(equal(ignore)) { type = 2; return true; }
			else if(equal(ignore)) { type = 3; return true; }
			else if(equal(ignore)) { type = 4; return true; }
			else if(equal(ignore)) { type = 5; return true; }
			else if(equal(ignore)) { type = 6; return true; }
			else if(equal(ignore)) { type = 7; return true; }
			else { type = 8; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(ignore);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(ignore);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(ignore);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(ignore);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(ignore);} return false;
			case 7: type = 7; if(v(ref_nested())) { return equal(ignore);} return false;
			case 8: type = 8; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		UE_X2AP_ID& select_id_Old_eNB_UE_X2AP_ID() { return set<UE_X2AP_ID>(1); }
		UE_X2AP_ID const* get_id_Old_eNB_UE_X2AP_ID() const { return get<UE_X2AP_ID>(1); }
		UE_X2AP_ID& select_id_New_eNB_UE_X2AP_ID() { return set<UE_X2AP_ID>(2); }
		UE_X2AP_ID const* get_id_New_eNB_UE_X2AP_ID() const { return get<UE_X2AP_ID>(2); }
		Cause& select_id_Cause() { return set<Cause>(3); }
		Cause const* get_id_Cause() const { return get<Cause>(3); }
		CriticalityDiagnostics& select_id_CriticalityDiagnostics() { return set<CriticalityDiagnostics>(4); }
		CriticalityDiagnostics const* get_id_CriticalityDiagnostics() const { return get<CriticalityDiagnostics>(4); }
		UE_X2AP_ID_Extension& select_id_Old_eNB_UE_X2AP_ID_Extension() { return set<UE_X2AP_ID_Extension>(5); }
		UE_X2AP_ID_Extension const* get_id_Old_eNB_UE_X2AP_ID_Extension() const { return get<UE_X2AP_ID_Extension>(5); }
		UE_X2AP_ID_Extension& select_id_New_eNB_UE_X2AP_ID_Extension() { return set<UE_X2AP_ID_Extension>(6); }
		UE_X2AP_ID_Extension const* get_id_New_eNB_UE_X2AP_ID_Extension() const { return get<UE_X2AP_ID_Extension>(6); }
		SgNB_UE_X2AP_ID& select_id_Old_SgNB_UE_X2AP_ID() { return set<SgNB_UE_X2AP_ID>(7); }
		SgNB_UE_X2AP_ID const* get_id_Old_SgNB_UE_X2AP_ID() const { return get<SgNB_UE_X2AP_ID>(7); }
		bool is_unknown() const { return type == 8; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<UE_X2AP_ID>(); break;
			case 2: var.destroy<UE_X2AP_ID>(); break;
			case 3: var.destroy<Cause>(); break;
			case 4: var.destroy<CriticalityDiagnostics>(); break;
			case 5: var.destroy<UE_X2AP_ID_Extension>(); break;
			case 6: var.destroy<UE_X2AP_ID_Extension>(); break;
			case 7: var.destroy<SgNB_UE_X2AP_ID>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<UE_X2AP_ID>(1);
			v.template operator()<UE_X2AP_ID>(2);
			v.template operator()<Cause>(3);
			v.template operator()<CriticalityDiagnostics>(4);
			v.template operator()<UE_X2AP_ID_Extension>(5);
			v.template operator()<UE_X2AP_ID_Extension>(6);
			v.template operator()<SgNB_UE_X2AP_ID>(7);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_Old_eNB_UE_X2AP_ID()); return true;
			case 2: v(select_id_New_eNB_UE_X2AP_ID()); return true;
			case 3: v(select_id_Cause()); return true;
			case 4: v(select_id_CriticalityDiagnostics()); return true;
			case 5: v(select_id_Old_eNB_UE_X2AP_ID_Extension()); return true;
			case 6: v(select_id_New_eNB_UE_X2AP_ID_Extension()); return true;
			case 7: v(select_id_Old_SgNB_UE_X2AP_ID()); return true;
			case 8: if(type != 8) {clear(); asn::base::set();} type = 8; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<UE_X2AP_ID>()); return true;
			case 2: v(var.as<UE_X2AP_ID>()); return true;
			case 3: v(var.as<Cause>()); return true;
			case 4: v(var.as<CriticalityDiagnostics>()); return true;
			case 5: v(var.as<UE_X2AP_ID_Extension>()); return true;
			case 6: v(var.as<UE_X2AP_ID_Extension>()); return true;
			case 7: v(var.as<SgNB_UE_X2AP_ID>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(Cause)];
			char dummy2[sizeof(CriticalityDiagnostics)];
			char dummy3[sizeof(SgNB_UE_X2AP_ID)];
			char dummy4[sizeof(UE_X2AP_ID)];
			char dummy5[sizeof(UE_X2AP_ID_Extension)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 8; }
		void clear() {type = 0;}
		void select_id_Old_eNB_UE_X2AP_ID() { set(optional); type=1;}
		void select_id_New_eNB_UE_X2AP_ID() { set(optional); type=2;}
		void select_id_Cause() { set(optional); type=3;}
		void select_id_CriticalityDiagnostics() { set(optional); type=4;}
		void select_id_Old_eNB_UE_X2AP_ID_Extension() { set(optional); type=5;}
		void select_id_New_eNB_UE_X2AP_ID_Extension() { set(optional); type=6;}
		void select_id_Old_SgNB_UE_X2AP_ID() { set(optional); type=7;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(optional)) { type = 1; return true; }
			else if(equal(optional)) { type = 2; return true; }
			else if(equal(optional)) { type = 3; return true; }
			else if(equal(optional)) { type = 4; return true; }
			else if(equal(optional)) { type = 5; return true; }
			else if(equal(optional)) { type = 6; return true; }
			else if(equal(optional)) { type = 7; return true; }
			else { type = 8; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(optional);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(optional);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(optional);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(optional);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(optional);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(optional);} return false;
			case 7: type = 7; if(v(ref_nested())) { return equal(optional);} return false;
			case 8: type = 8; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
ErrorIndication ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{ErrorIndication-IEs}},
	...
}
*/

struct ErrorIndication : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "ErrorIndication";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<ErrorIndication_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<ErrorIndication_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
GNBStatusIndicationIEs X2AP-PROTOCOL-IES ::= {
	{ ID id-GNBOverloadInformation		CRITICALITY ignore	TYPE GNBOverloadInformation		PRESENCE mandatory},
	...
}
*/

struct GNBStatusIndicationIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_GNBOverloadInformation() { set(id_GNBOverloadInformation); type=1;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_GNBOverloadInformation)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_GNBOverloadInformation);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_GNBOverloadInformation() { set(ignore); type=1;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		GNBOverloadInformation& select_id_GNBOverloadInformation() { return set<GNBOverloadInformation>(1); }
		GNBOverloadInformation const* get_id_GNBOverloadInformation() const { return get<GNBOverloadInformation>(1); }
		bool is_unknown() const { return type == 2; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<GNBOverloadInformation>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<GNBOverloadInformation>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_GNBOverloadInformation()); return true;
			case 2: if(type != 2) {clear(); asn::base::set();} type = 2; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<GNBOverloadInformation>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(GNBOverloadInformation)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_GNBOverloadInformation() { set(mandatory); type=1;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
GNBStatusIndication ::= SEQUENCE {
	protocolIEs			ProtocolIE-Container	{ { GNBStatusIndicationIEs} },
	...
}
*/

struct GNBStatusIndication : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "GNBStatusIndication";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<GNBStatusIndicationIEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<GNBStatusIndicationIEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
HandoverCancel-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-Old-eNB-UE-X2AP-ID					CRITICALITY reject	TYPE UE-X2AP-ID					PRESENCE mandatory}|
	{ ID id-New-eNB-UE-X2AP-ID					CRITICALITY ignore	TYPE UE-X2AP-ID					PRESENCE optional}|
	{ ID id-Cause								CRITICALITY ignore	TYPE Cause						PRESENCE mandatory}|
	{ ID id-Old-eNB-UE-X2AP-ID-Extension		CRITICALITY reject	TYPE UE-X2AP-ID-Extension		PRESENCE optional}|
	{ ID id-New-eNB-UE-X2AP-ID-Extension		CRITICALITY ignore	TYPE UE-X2AP-ID-Extension		PRESENCE optional},
	...
}
*/

struct HandoverCancel_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 6; }
		void clear() {type = 0;}
		void select_id_Old_eNB_UE_X2AP_ID() { set(id_Old_eNB_UE_X2AP_ID); type=1;}
		void select_id_New_eNB_UE_X2AP_ID() { set(id_New_eNB_UE_X2AP_ID); type=2;}
		void select_id_Cause() { set(id_Cause); type=3;}
		void select_id_Old_eNB_UE_X2AP_ID_Extension() { set(id_Old_eNB_UE_X2AP_ID_Extension); type=4;}
		void select_id_New_eNB_UE_X2AP_ID_Extension() { set(id_New_eNB_UE_X2AP_ID_Extension); type=5;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_Old_eNB_UE_X2AP_ID)) { type = 1; return true; }
			else if(equal(id_New_eNB_UE_X2AP_ID)) { type = 2; return true; }
			else if(equal(id_Cause)) { type = 3; return true; }
			else if(equal(id_Old_eNB_UE_X2AP_ID_Extension)) { type = 4; return true; }
			else if(equal(id_New_eNB_UE_X2AP_ID_Extension)) { type = 5; return true; }
			else { type = 6; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_Old_eNB_UE_X2AP_ID);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_New_eNB_UE_X2AP_ID);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_Cause);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(id_Old_eNB_UE_X2AP_ID_Extension);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(id_New_eNB_UE_X2AP_ID_Extension);} return false;
			case 6: type = 6; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 6; }
		void clear() {type = 0;}
		void select_id_Old_eNB_UE_X2AP_ID() { set(reject); type=1;}
		void select_id_New_eNB_UE_X2AP_ID() { set(ignore); type=2;}
		void select_id_Cause() { set(ignore); type=3;}
		void select_id_Old_eNB_UE_X2AP_ID_Extension() { set(reject); type=4;}
		void select_id_New_eNB_UE_X2AP_ID_Extension() { set(ignore); type=5;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else if(equal(ignore)) { type = 2; return true; }
			else if(equal(ignore)) { type = 3; return true; }
			else if(equal(reject)) { type = 4; return true; }
			else if(equal(ignore)) { type = 5; return true; }
			else { type = 6; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(ignore);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(ignore);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(reject);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(ignore);} return false;
			case 6: type = 6; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		UE_X2AP_ID& select_id_Old_eNB_UE_X2AP_ID() { return set<UE_X2AP_ID>(1); }
		UE_X2AP_ID const* get_id_Old_eNB_UE_X2AP_ID() const { return get<UE_X2AP_ID>(1); }
		UE_X2AP_ID& select_id_New_eNB_UE_X2AP_ID() { return set<UE_X2AP_ID>(2); }
		UE_X2AP_ID const* get_id_New_eNB_UE_X2AP_ID() const { return get<UE_X2AP_ID>(2); }
		Cause& select_id_Cause() { return set<Cause>(3); }
		Cause const* get_id_Cause() const { return get<Cause>(3); }
		UE_X2AP_ID_Extension& select_id_Old_eNB_UE_X2AP_ID_Extension() { return set<UE_X2AP_ID_Extension>(4); }
		UE_X2AP_ID_Extension const* get_id_Old_eNB_UE_X2AP_ID_Extension() const { return get<UE_X2AP_ID_Extension>(4); }
		UE_X2AP_ID_Extension& select_id_New_eNB_UE_X2AP_ID_Extension() { return set<UE_X2AP_ID_Extension>(5); }
		UE_X2AP_ID_Extension const* get_id_New_eNB_UE_X2AP_ID_Extension() const { return get<UE_X2AP_ID_Extension>(5); }
		bool is_unknown() const { return type == 6; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<UE_X2AP_ID>(); break;
			case 2: var.destroy<UE_X2AP_ID>(); break;
			case 3: var.destroy<Cause>(); break;
			case 4: var.destroy<UE_X2AP_ID_Extension>(); break;
			case 5: var.destroy<UE_X2AP_ID_Extension>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<UE_X2AP_ID>(1);
			v.template operator()<UE_X2AP_ID>(2);
			v.template operator()<Cause>(3);
			v.template operator()<UE_X2AP_ID_Extension>(4);
			v.template operator()<UE_X2AP_ID_Extension>(5);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_Old_eNB_UE_X2AP_ID()); return true;
			case 2: v(select_id_New_eNB_UE_X2AP_ID()); return true;
			case 3: v(select_id_Cause()); return true;
			case 4: v(select_id_Old_eNB_UE_X2AP_ID_Extension()); return true;
			case 5: v(select_id_New_eNB_UE_X2AP_ID_Extension()); return true;
			case 6: if(type != 6) {clear(); asn::base::set();} type = 6; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<UE_X2AP_ID>()); return true;
			case 2: v(var.as<UE_X2AP_ID>()); return true;
			case 3: v(var.as<Cause>()); return true;
			case 4: v(var.as<UE_X2AP_ID_Extension>()); return true;
			case 5: v(var.as<UE_X2AP_ID_Extension>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(Cause)];
			char dummy2[sizeof(UE_X2AP_ID)];
			char dummy3[sizeof(UE_X2AP_ID_Extension)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 6; }
		void clear() {type = 0;}
		void select_id_Old_eNB_UE_X2AP_ID() { set(mandatory); type=1;}
		void select_id_New_eNB_UE_X2AP_ID() { set(optional); type=2;}
		void select_id_Cause() { set(mandatory); type=3;}
		void select_id_Old_eNB_UE_X2AP_ID_Extension() { set(optional); type=4;}
		void select_id_New_eNB_UE_X2AP_ID_Extension() { set(optional); type=5;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(optional)) { type = 2; return true; }
			else if(equal(mandatory)) { type = 3; return true; }
			else if(equal(optional)) { type = 4; return true; }
			else if(equal(optional)) { type = 5; return true; }
			else { type = 6; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(optional);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(optional);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(optional);} return false;
			case 6: type = 6; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
HandoverCancel ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{HandoverCancel-IEs}},
	...
}
*/

struct HandoverCancel : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "HandoverCancel";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<HandoverCancel_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<HandoverCancel_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
HandoverPreparationFailure-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-Old-eNB-UE-X2AP-ID				CRITICALITY ignore	TYPE UE-X2AP-ID					PRESENCE mandatory}|
	{ ID id-Cause							CRITICALITY ignore	TYPE Cause						PRESENCE mandatory}|
	{ ID id-CriticalityDiagnostics			CRITICALITY ignore	TYPE CriticalityDiagnostics		PRESENCE optional}|
	{ ID id-Old-eNB-UE-X2AP-ID-Extension	CRITICALITY ignore	TYPE UE-X2AP-ID-Extension		PRESENCE optional},

	...
}
*/

struct HandoverPreparationFailure_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 5; }
		void clear() {type = 0;}
		void select_id_Old_eNB_UE_X2AP_ID() { set(id_Old_eNB_UE_X2AP_ID); type=1;}
		void select_id_Cause() { set(id_Cause); type=2;}
		void select_id_CriticalityDiagnostics() { set(id_CriticalityDiagnostics); type=3;}
		void select_id_Old_eNB_UE_X2AP_ID_Extension() { set(id_Old_eNB_UE_X2AP_ID_Extension); type=4;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_Old_eNB_UE_X2AP_ID)) { type = 1; return true; }
			else if(equal(id_Cause)) { type = 2; return true; }
			else if(equal(id_CriticalityDiagnostics)) { type = 3; return true; }
			else if(equal(id_Old_eNB_UE_X2AP_ID_Extension)) { type = 4; return true; }
			else { type = 5; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_Old_eNB_UE_X2AP_ID);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_Cause);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_CriticalityDiagnostics);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(id_Old_eNB_UE_X2AP_ID_Extension);} return false;
			case 5: type = 5; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 5; }
		void clear() {type = 0;}
		void select_id_Old_eNB_UE_X2AP_ID() { set(ignore); type=1;}
		void select_id_Cause() { set(ignore); type=2;}
		void select_id_CriticalityDiagnostics() { set(ignore); type=3;}
		void select_id_Old_eNB_UE_X2AP_ID_Extension() { set(ignore); type=4;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else if(equal(ignore)) { type = 2; return true; }
			else if(equal(ignore)) { type = 3; return true; }
			else if(equal(ignore)) { type = 4; return true; }
			else { type = 5; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(ignore);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(ignore);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(ignore);} return false;
			case 5: type = 5; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		UE_X2AP_ID& select_id_Old_eNB_UE_X2AP_ID() { return set<UE_X2AP_ID>(1); }
		UE_X2AP_ID const* get_id_Old_eNB_UE_X2AP_ID() const { return get<UE_X2AP_ID>(1); }
		Cause& select_id_Cause() { return set<Cause>(2); }
		Cause const* get_id_Cause() const { return get<Cause>(2); }
		CriticalityDiagnostics& select_id_CriticalityDiagnostics() { return set<CriticalityDiagnostics>(3); }
		CriticalityDiagnostics const* get_id_CriticalityDiagnostics() const { return get<CriticalityDiagnostics>(3); }
		UE_X2AP_ID_Extension& select_id_Old_eNB_UE_X2AP_ID_Extension() { return set<UE_X2AP_ID_Extension>(4); }
		UE_X2AP_ID_Extension const* get_id_Old_eNB_UE_X2AP_ID_Extension() const { return get<UE_X2AP_ID_Extension>(4); }
		bool is_unknown() const { return type == 5; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<UE_X2AP_ID>(); break;
			case 2: var.destroy<Cause>(); break;
			case 3: var.destroy<CriticalityDiagnostics>(); break;
			case 4: var.destroy<UE_X2AP_ID_Extension>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<UE_X2AP_ID>(1);
			v.template operator()<Cause>(2);
			v.template operator()<CriticalityDiagnostics>(3);
			v.template operator()<UE_X2AP_ID_Extension>(4);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_Old_eNB_UE_X2AP_ID()); return true;
			case 2: v(select_id_Cause()); return true;
			case 3: v(select_id_CriticalityDiagnostics()); return true;
			case 4: v(select_id_Old_eNB_UE_X2AP_ID_Extension()); return true;
			case 5: if(type != 5) {clear(); asn::base::set();} type = 5; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<UE_X2AP_ID>()); return true;
			case 2: v(var.as<Cause>()); return true;
			case 3: v(var.as<CriticalityDiagnostics>()); return true;
			case 4: v(var.as<UE_X2AP_ID_Extension>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(Cause)];
			char dummy2[sizeof(CriticalityDiagnostics)];
			char dummy3[sizeof(UE_X2AP_ID)];
			char dummy4[sizeof(UE_X2AP_ID_Extension)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 5; }
		void clear() {type = 0;}
		void select_id_Old_eNB_UE_X2AP_ID() { set(mandatory); type=1;}
		void select_id_Cause() { set(mandatory); type=2;}
		void select_id_CriticalityDiagnostics() { set(optional); type=3;}
		void select_id_Old_eNB_UE_X2AP_ID_Extension() { set(optional); type=4;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(mandatory)) { type = 2; return true; }
			else if(equal(optional)) { type = 3; return true; }
			else if(equal(optional)) { type = 4; return true; }
			else { type = 5; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(optional);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(optional);} return false;
			case 5: type = 5; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
HandoverPreparationFailure ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{HandoverPreparationFailure-IEs}},
	...
}
*/

struct HandoverPreparationFailure : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "HandoverPreparationFailure";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<HandoverPreparationFailure_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<HandoverPreparationFailure_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
MobilityInformation ::= BIT STRING (SIZE(32))
*/

struct MobilityInformation : asn::bstring<>
{
	using constraint_t = asn::constraints<false,asn::one<32>>;
	static constexpr const char* name() {return "MobilityInformation";}
	using parent_t = asn::bstring<>;

};

/*
HandoverReport-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-HandoverReportType							CRITICALITY ignore	TYPE HandoverReportType									PRESENCE mandatory}|
	{ ID id-Cause										CRITICALITY ignore	TYPE Cause													PRESENCE mandatory}|
	{ ID id-SourceCellECGI								CRITICALITY ignore	TYPE ECGI													PRESENCE mandatory}|
	{ ID id-FailureCellECGI								CRITICALITY ignore	TYPE ECGI													PRESENCE mandatory}|
	{ ID id-Re-establishmentCellECGI					CRITICALITY ignore	TYPE ECGI													PRESENCE conditional} -- The IE shall be present if the Handover Report Type IE is set to HO to Wrong Cell -- |
	{ ID id-TargetCellInUTRAN							CRITICALITY ignore	TYPE TargetCellInUTRAN									PRESENCE conditional} -- The IE shall be present if the Handover Report Type IE is set to "InterRAT ping-pong" --|
	{ ID id-SourceCellCRNTI								CRITICALITY ignore	TYPE CRNTI													PRESENCE optional}|
	{ ID id-MobilityInformation							CRITICALITY ignore	TYPE MobilityInformation									PRESENCE optional}|
	{ ID id-UE-RLF-Report-Container						CRITICALITY ignore	TYPE UE-RLF-Report-Container							PRESENCE optional}|
	{ ID id-UE-RLF-Report-Container-for-extended-bands	CRITICALITY ignore	TYPE UE-RLF-Report-Container-for-extended-bands	PRESENCE optional},
	...
}
*/

struct HandoverReport_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 11; }
		void clear() {type = 0;}
		void select_id_HandoverReportType() { set(id_HandoverReportType); type=1;}
		void select_id_Cause() { set(id_Cause); type=2;}
		void select_id_SourceCellECGI() { set(id_SourceCellECGI); type=3;}
		void select_id_FailureCellECGI() { set(id_FailureCellECGI); type=4;}
		void select_id_Re_establishmentCellECGI() { set(id_Re_establishmentCellECGI); type=5;}
		void select_id_TargetCellInUTRAN() { set(id_TargetCellInUTRAN); type=6;}
		void select_id_SourceCellCRNTI() { set(id_SourceCellCRNTI); type=7;}
		void select_id_MobilityInformation() { set(id_MobilityInformation); type=8;}
		void select_id_UE_RLF_Report_Container() { set(id_UE_RLF_Report_Container); type=9;}
		void select_id_UE_RLF_Report_Container_for_extended_bands() { set(id_UE_RLF_Report_Container_for_extended_bands); type=10;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_HandoverReportType)) { type = 1; return true; }
			else if(equal(id_Cause)) { type = 2; return true; }
			else if(equal(id_SourceCellECGI)) { type = 3; return true; }
			else if(equal(id_FailureCellECGI)) { type = 4; return true; }
			else if(equal(id_Re_establishmentCellECGI)) { type = 5; return true; }
			else if(equal(id_TargetCellInUTRAN)) { type = 6; return true; }
			else if(equal(id_SourceCellCRNTI)) { type = 7; return true; }
			else if(equal(id_MobilityInformation)) { type = 8; return true; }
			else if(equal(id_UE_RLF_Report_Container)) { type = 9; return true; }
			else if(equal(id_UE_RLF_Report_Container_for_extended_bands)) { type = 10; return true; }
			else { type = 11; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_HandoverReportType);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_Cause);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_SourceCellECGI);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(id_FailureCellECGI);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(id_Re_establishmentCellECGI);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(id_TargetCellInUTRAN);} return false;
			case 7: type = 7; if(v(ref_nested())) { return equal(id_SourceCellCRNTI);} return false;
			case 8: type = 8; if(v(ref_nested())) { return equal(id_MobilityInformation);} return false;
			case 9: type = 9; if(v(ref_nested())) { return equal(id_UE_RLF_Report_Container);} return false;
			case 10: type = 10; if(v(ref_nested())) { return equal(id_UE_RLF_Report_Container_for_extended_bands);} return false;
			case 11: type = 11; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 11; }
		void clear() {type = 0;}
		void select_id_HandoverReportType() { set(ignore); type=1;}
		void select_id_Cause() { set(ignore); type=2;}
		void select_id_SourceCellECGI() { set(ignore); type=3;}
		void select_id_FailureCellECGI() { set(ignore); type=4;}
		void select_id_Re_establishmentCellECGI() { set(ignore); type=5;}
		void select_id_TargetCellInUTRAN() { set(ignore); type=6;}
		void select_id_SourceCellCRNTI() { set(ignore); type=7;}
		void select_id_MobilityInformation() { set(ignore); type=8;}
		void select_id_UE_RLF_Report_Container() { set(ignore); type=9;}
		void select_id_UE_RLF_Report_Container_for_extended_bands() { set(ignore); type=10;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else if(equal(ignore)) { type = 2; return true; }
			else if(equal(ignore)) { type = 3; return true; }
			else if(equal(ignore)) { type = 4; return true; }
			else if(equal(ignore)) { type = 5; return true; }
			else if(equal(ignore)) { type = 6; return true; }
			else if(equal(ignore)) { type = 7; return true; }
			else if(equal(ignore)) { type = 8; return true; }
			else if(equal(ignore)) { type = 9; return true; }
			else if(equal(ignore)) { type = 10; return true; }
			else { type = 11; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(ignore);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(ignore);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(ignore);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(ignore);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(ignore);} return false;
			case 7: type = 7; if(v(ref_nested())) { return equal(ignore);} return false;
			case 8: type = 8; if(v(ref_nested())) { return equal(ignore);} return false;
			case 9: type = 9; if(v(ref_nested())) { return equal(ignore);} return false;
			case 10: type = 10; if(v(ref_nested())) { return equal(ignore);} return false;
			case 11: type = 11; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		HandoverReportType& select_id_HandoverReportType() { return set<HandoverReportType>(1); }
		HandoverReportType const* get_id_HandoverReportType() const { return get<HandoverReportType>(1); }
		Cause& select_id_Cause() { return set<Cause>(2); }
		Cause const* get_id_Cause() const { return get<Cause>(2); }
		ECGI& select_id_SourceCellECGI() { return set<ECGI>(3); }
		ECGI const* get_id_SourceCellECGI() const { return get<ECGI>(3); }
		ECGI& select_id_FailureCellECGI() { return set<ECGI>(4); }
		ECGI const* get_id_FailureCellECGI() const { return get<ECGI>(4); }
		ECGI& select_id_Re_establishmentCellECGI() { return set<ECGI>(5); }
		ECGI const* get_id_Re_establishmentCellECGI() const { return get<ECGI>(5); }
		TargetCellInUTRAN& select_id_TargetCellInUTRAN() { return set<TargetCellInUTRAN>(6); }
		TargetCellInUTRAN const* get_id_TargetCellInUTRAN() const { return get<TargetCellInUTRAN>(6); }
		CRNTI& select_id_SourceCellCRNTI() { return set<CRNTI>(7); }
		CRNTI const* get_id_SourceCellCRNTI() const { return get<CRNTI>(7); }
		MobilityInformation& select_id_MobilityInformation() { return set<MobilityInformation>(8); }
		MobilityInformation const* get_id_MobilityInformation() const { return get<MobilityInformation>(8); }
		UE_RLF_Report_Container& select_id_UE_RLF_Report_Container() { return set<UE_RLF_Report_Container>(9); }
		UE_RLF_Report_Container const* get_id_UE_RLF_Report_Container() const { return get<UE_RLF_Report_Container>(9); }
		UE_RLF_Report_Container_for_extended_bands& select_id_UE_RLF_Report_Container_for_extended_bands() { return set<UE_RLF_Report_Container_for_extended_bands>(10); }
		UE_RLF_Report_Container_for_extended_bands const* get_id_UE_RLF_Report_Container_for_extended_bands() const { return get<UE_RLF_Report_Container_for_extended_bands>(10); }
		bool is_unknown() const { return type == 11; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<HandoverReportType>(); break;
			case 2: var.destroy<Cause>(); break;
			case 3: var.destroy<ECGI>(); break;
			case 4: var.destroy<ECGI>(); break;
			case 5: var.destroy<ECGI>(); break;
			case 6: var.destroy<TargetCellInUTRAN>(); break;
			case 7: var.destroy<CRNTI>(); break;
			case 8: var.destroy<MobilityInformation>(); break;
			case 9: var.destroy<UE_RLF_Report_Container>(); break;
			case 10: var.destroy<UE_RLF_Report_Container_for_extended_bands>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<HandoverReportType>(1);
			v.template operator()<Cause>(2);
			v.template operator()<ECGI>(3);
			v.template operator()<ECGI>(4);
			v.template operator()<ECGI>(5);
			v.template operator()<TargetCellInUTRAN>(6);
			v.template operator()<CRNTI>(7);
			v.template operator()<MobilityInformation>(8);
			v.template operator()<UE_RLF_Report_Container>(9);
			v.template operator()<UE_RLF_Report_Container_for_extended_bands>(10);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_HandoverReportType()); return true;
			case 2: v(select_id_Cause()); return true;
			case 3: v(select_id_SourceCellECGI()); return true;
			case 4: v(select_id_FailureCellECGI()); return true;
			case 5: v(select_id_Re_establishmentCellECGI()); return true;
			case 6: v(select_id_TargetCellInUTRAN()); return true;
			case 7: v(select_id_SourceCellCRNTI()); return true;
			case 8: v(select_id_MobilityInformation()); return true;
			case 9: v(select_id_UE_RLF_Report_Container()); return true;
			case 10: v(select_id_UE_RLF_Report_Container_for_extended_bands()); return true;
			case 11: if(type != 11) {clear(); asn::base::set();} type = 11; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<HandoverReportType>()); return true;
			case 2: v(var.as<Cause>()); return true;
			case 3: v(var.as<ECGI>()); return true;
			case 4: v(var.as<ECGI>()); return true;
			case 5: v(var.as<ECGI>()); return true;
			case 6: v(var.as<TargetCellInUTRAN>()); return true;
			case 7: v(var.as<CRNTI>()); return true;
			case 8: v(var.as<MobilityInformation>()); return true;
			case 9: v(var.as<UE_RLF_Report_Container>()); return true;
			case 10: v(var.as<UE_RLF_Report_Container_for_extended_bands>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(CRNTI)];
			char dummy2[sizeof(Cause)];
			char dummy3[sizeof(ECGI)];
			char dummy4[sizeof(HandoverReportType)];
			char dummy5[sizeof(MobilityInformation)];
			char dummy6[sizeof(TargetCellInUTRAN)];
			char dummy7[sizeof(UE_RLF_Report_Container)];
			char dummy8[sizeof(UE_RLF_Report_Container_for_extended_bands)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 11; }
		void clear() {type = 0;}
		void select_id_HandoverReportType() { set(mandatory); type=1;}
		void select_id_Cause() { set(mandatory); type=2;}
		void select_id_SourceCellECGI() { set(mandatory); type=3;}
		void select_id_FailureCellECGI() { set(mandatory); type=4;}
		void select_id_Re_establishmentCellECGI() { set(conditional); type=5;}
		void select_id_TargetCellInUTRAN() { set(conditional); type=6;}
		void select_id_SourceCellCRNTI() { set(optional); type=7;}
		void select_id_MobilityInformation() { set(optional); type=8;}
		void select_id_UE_RLF_Report_Container() { set(optional); type=9;}
		void select_id_UE_RLF_Report_Container_for_extended_bands() { set(optional); type=10;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(mandatory)) { type = 2; return true; }
			else if(equal(mandatory)) { type = 3; return true; }
			else if(equal(mandatory)) { type = 4; return true; }
			else if(equal(conditional)) { type = 5; return true; }
			else if(equal(conditional)) { type = 6; return true; }
			else if(equal(optional)) { type = 7; return true; }
			else if(equal(optional)) { type = 8; return true; }
			else if(equal(optional)) { type = 9; return true; }
			else if(equal(optional)) { type = 10; return true; }
			else { type = 11; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(conditional);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(conditional);} return false;
			case 7: type = 7; if(v(ref_nested())) { return equal(optional);} return false;
			case 8: type = 8; if(v(ref_nested())) { return equal(optional);} return false;
			case 9: type = 9; if(v(ref_nested())) { return equal(optional);} return false;
			case 10: type = 10; if(v(ref_nested())) { return equal(optional);} return false;
			case 11: type = 11; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
HandoverReport ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{HandoverReport-IEs}},
	...
}
*/

struct HandoverReport : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "HandoverReport";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<HandoverReport_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<HandoverReport_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
UE-ContextInformation-ExtIEs X2AP-PROTOCOL-EXTENSION ::= {
{ ID id-ManagementBasedMDTallowed			CRITICALITY ignore	EXTENSION ManagementBasedMDTallowed					PRESENCE optional }|
{ ID id-ManagementBasedMDTPLMNList			CRITICALITY ignore	EXTENSION MDTPLMNList									PRESENCE optional }|
{ ID id-UESidelinkAggregateMaximumBitRate	CRITICALITY ignore	EXTENSION UESidelinkAggregateMaximumBitRate		PRESENCE optional},
	...
}
*/

struct UE_ContextInformation_ExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 4; }
		void clear() {type = 0;}
		void select_id_ManagementBasedMDTallowed() { set(id_ManagementBasedMDTallowed); type=1;}
		void select_id_ManagementBasedMDTPLMNList() { set(id_ManagementBasedMDTPLMNList); type=2;}
		void select_id_UESidelinkAggregateMaximumBitRate() { set(id_UESidelinkAggregateMaximumBitRate); type=3;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_ManagementBasedMDTallowed)) { type = 1; return true; }
			else if(equal(id_ManagementBasedMDTPLMNList)) { type = 2; return true; }
			else if(equal(id_UESidelinkAggregateMaximumBitRate)) { type = 3; return true; }
			else { type = 4; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_ManagementBasedMDTallowed);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_ManagementBasedMDTPLMNList);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_UESidelinkAggregateMaximumBitRate);} return false;
			case 4: type = 4; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 4; }
		void clear() {type = 0;}
		void select_id_ManagementBasedMDTallowed() { set(ignore); type=1;}
		void select_id_ManagementBasedMDTPLMNList() { set(ignore); type=2;}
		void select_id_UESidelinkAggregateMaximumBitRate() { set(ignore); type=3;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else if(equal(ignore)) { type = 2; return true; }
			else if(equal(ignore)) { type = 3; return true; }
			else { type = 4; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(ignore);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(ignore);} return false;
			case 4: type = 4; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		ManagementBasedMDTallowed& select_id_ManagementBasedMDTallowed() { return set<ManagementBasedMDTallowed>(1); }
		ManagementBasedMDTallowed const* get_id_ManagementBasedMDTallowed() const { return get<ManagementBasedMDTallowed>(1); }
		MDTPLMNList& select_id_ManagementBasedMDTPLMNList() { return set<MDTPLMNList>(2); }
		MDTPLMNList const* get_id_ManagementBasedMDTPLMNList() const { return get<MDTPLMNList>(2); }
		UESidelinkAggregateMaximumBitRate& select_id_UESidelinkAggregateMaximumBitRate() { return set<UESidelinkAggregateMaximumBitRate>(3); }
		UESidelinkAggregateMaximumBitRate const* get_id_UESidelinkAggregateMaximumBitRate() const { return get<UESidelinkAggregateMaximumBitRate>(3); }
		bool is_unknown() const { return type == 4; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<ManagementBasedMDTallowed>(); break;
			case 2: var.destroy<MDTPLMNList>(); break;
			case 3: var.destroy<UESidelinkAggregateMaximumBitRate>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<ManagementBasedMDTallowed>(1);
			v.template operator()<MDTPLMNList>(2);
			v.template operator()<UESidelinkAggregateMaximumBitRate>(3);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_ManagementBasedMDTallowed()); return true;
			case 2: v(select_id_ManagementBasedMDTPLMNList()); return true;
			case 3: v(select_id_UESidelinkAggregateMaximumBitRate()); return true;
			case 4: if(type != 4) {clear(); asn::base::set();} type = 4; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<ManagementBasedMDTallowed>()); return true;
			case 2: v(var.as<MDTPLMNList>()); return true;
			case 3: v(var.as<UESidelinkAggregateMaximumBitRate>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(MDTPLMNList)];
			char dummy2[sizeof(ManagementBasedMDTallowed)];
			char dummy3[sizeof(UESidelinkAggregateMaximumBitRate)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 4; }
		void clear() {type = 0;}
		void select_id_ManagementBasedMDTallowed() { set(optional); type=1;}
		void select_id_ManagementBasedMDTPLMNList() { set(optional); type=2;}
		void select_id_UESidelinkAggregateMaximumBitRate() { set(optional); type=3;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(optional)) { type = 1; return true; }
			else if(equal(optional)) { type = 2; return true; }
			else if(equal(optional)) { type = 3; return true; }
			else { type = 4; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(optional);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(optional);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(optional);} return false;
			case 4: type = 4; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
UE-ContextInformation ::= SEQUENCE {
	mME-UE-S1AP-ID						UE-S1AP-ID,
	uESecurityCapabilities				UESecurityCapabilities,
	aS-SecurityInformation				AS-SecurityInformation,
	uEaggregateMaximumBitRate			UEAggregateMaximumBitRate,
	subscriberProfileIDforRFP			SubscriberProfileIDforRFP		OPTIONAL,
	e-RABs-ToBeSetup-List				E-RABs-ToBeSetup-List,
	rRC-Context							RRC-Context,
	handoverRestrictionList				HandoverRestrictionList		OPTIONAL,
	locationReportingInformation		LocationReportingInformation	OPTIONAL,
	iE-Extensions						ProtocolExtensionContainer { {UE-ContextInformation-ExtIEs} } OPTIONAL,
	...
}
*/

struct UE_ContextInformation : asn::sequence<10, 0, true, 4>
{
	static constexpr const char* name() {return "UE-ContextInformation";}
	using parent_t = asn::sequence<10, 0, true, 4>;
	struct mME_UE_S1AP_ID_t : UE_S1AP_ID
	{
		static constexpr const char* name() {return "mME_UE_S1AP_ID_t";}
		using parent_t = UE_S1AP_ID;

	};
	mME_UE_S1AP_ID_t& ref_mME_UE_S1AP_ID() {return mME_UE_S1AP_ID;}
	mME_UE_S1AP_ID_t const& ref_mME_UE_S1AP_ID() const {return mME_UE_S1AP_ID;}
	struct uESecurityCapabilities_t : UESecurityCapabilities
	{
		static constexpr const char* name() {return "uESecurityCapabilities_t";}
		using parent_t = UESecurityCapabilities;

	};
	uESecurityCapabilities_t& ref_uESecurityCapabilities() {return uESecurityCapabilities;}
	uESecurityCapabilities_t const& ref_uESecurityCapabilities() const {return uESecurityCapabilities;}
	struct aS_SecurityInformation_t : AS_SecurityInformation
	{
		static constexpr const char* name() {return "aS_SecurityInformation_t";}
		using parent_t = AS_SecurityInformation;

	};
	aS_SecurityInformation_t& ref_aS_SecurityInformation() {return aS_SecurityInformation;}
	aS_SecurityInformation_t const& ref_aS_SecurityInformation() const {return aS_SecurityInformation;}
	struct uEaggregateMaximumBitRate_t : UEAggregateMaximumBitRate
	{
		static constexpr const char* name() {return "uEaggregateMaximumBitRate_t";}
		using parent_t = UEAggregateMaximumBitRate;

	};
	uEaggregateMaximumBitRate_t& ref_uEaggregateMaximumBitRate() {return uEaggregateMaximumBitRate;}
	uEaggregateMaximumBitRate_t const& ref_uEaggregateMaximumBitRate() const {return uEaggregateMaximumBitRate;}
	struct subscriberProfileIDforRFP_t : SubscriberProfileIDforRFP
	{
		static constexpr const char* name() {return "subscriberProfileIDforRFP_t";}
		using parent_t = SubscriberProfileIDforRFP;
		static constexpr bool optional = true;

	};
	subscriberProfileIDforRFP_t& set_subscriberProfileIDforRFP() { subscriberProfileIDforRFP.setpresent(true); return subscriberProfileIDforRFP;}
	subscriberProfileIDforRFP_t const* get_subscriberProfileIDforRFP() const {return subscriberProfileIDforRFP.is_valid() ? &subscriberProfileIDforRFP : nullptr;}
	struct e_RABs_ToBeSetup_List_t : E_RABs_ToBeSetup_List
	{
		static constexpr const char* name() {return "e_RABs_ToBeSetup_List_t";}
		using parent_t = E_RABs_ToBeSetup_List;

	};
	e_RABs_ToBeSetup_List_t& ref_e_RABs_ToBeSetup_List() {return e_RABs_ToBeSetup_List;}
	e_RABs_ToBeSetup_List_t const& ref_e_RABs_ToBeSetup_List() const {return e_RABs_ToBeSetup_List;}
	struct rRC_Context_t : RRC_Context
	{
		static constexpr const char* name() {return "rRC_Context_t";}
		using parent_t = RRC_Context;

	};
	rRC_Context_t& ref_rRC_Context() {return rRC_Context;}
	rRC_Context_t const& ref_rRC_Context() const {return rRC_Context;}
	struct handoverRestrictionList_t : HandoverRestrictionList
	{
		static constexpr const char* name() {return "handoverRestrictionList_t";}
		using parent_t = HandoverRestrictionList;
		static constexpr bool optional = true;

	};
	handoverRestrictionList_t& set_handoverRestrictionList() { handoverRestrictionList.setpresent(true); return handoverRestrictionList;}
	handoverRestrictionList_t const* get_handoverRestrictionList() const {return handoverRestrictionList.is_valid() ? &handoverRestrictionList : nullptr;}
	struct locationReportingInformation_t : LocationReportingInformation
	{
		static constexpr const char* name() {return "locationReportingInformation_t";}
		using parent_t = LocationReportingInformation;
		static constexpr bool optional = true;

	};
	locationReportingInformation_t& set_locationReportingInformation() { locationReportingInformation.setpresent(true); return locationReportingInformation;}
	locationReportingInformation_t const* get_locationReportingInformation() const {return locationReportingInformation.is_valid() ? &locationReportingInformation : nullptr;}
	struct iE_Extensions_t : ProtocolExtensionContainer<UE_ContextInformation_ExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<UE_ContextInformation_ExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(mME_UE_S1AP_ID);
		v(uESecurityCapabilities);
		v(aS_SecurityInformation);
		v(uEaggregateMaximumBitRate);
		v(subscriberProfileIDforRFP);
		v(e_RABs_ToBeSetup_List);
		v(rRC_Context);
		v(handoverRestrictionList);
		v(locationReportingInformation);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(mME_UE_S1AP_ID);
		v(uESecurityCapabilities);
		v(aS_SecurityInformation);
		v(uEaggregateMaximumBitRate);
		v(subscriberProfileIDforRFP);
		v(e_RABs_ToBeSetup_List);
		v(rRC_Context);
		v(handoverRestrictionList);
		v(locationReportingInformation);
		v(iE_Extensions);

	};
	void clear()
	{
		mME_UE_S1AP_ID.clear();
		uESecurityCapabilities.clear();
		aS_SecurityInformation.clear();
		uEaggregateMaximumBitRate.clear();
		subscriberProfileIDforRFP.clear();
		e_RABs_ToBeSetup_List.clear();
		rRC_Context.clear();
		handoverRestrictionList.clear();
		locationReportingInformation.clear();
		iE_Extensions.clear();

	};
	private:
	mME_UE_S1AP_ID_t	mME_UE_S1AP_ID;
	uESecurityCapabilities_t	uESecurityCapabilities;
	aS_SecurityInformation_t	aS_SecurityInformation;
	uEaggregateMaximumBitRate_t	uEaggregateMaximumBitRate;
	subscriberProfileIDforRFP_t	subscriberProfileIDforRFP;
	e_RABs_ToBeSetup_List_t	e_RABs_ToBeSetup_List;
	rRC_Context_t	rRC_Context;
	handoverRestrictionList_t	handoverRestrictionList;
	locationReportingInformation_t	locationReportingInformation;
	iE_Extensions_t	iE_Extensions;

};
/*
UE-ContextReferenceAtSeNB-ItemExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct UE_ContextReferenceAtSeNB_ItemExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
UE-ContextReferenceAtSeNB ::= SEQUENCE {
	source-GlobalSeNB-ID		GlobalENB-ID,
	seNB-UE-X2AP-ID				UE-X2AP-ID,
	seNB-UE-X2AP-ID-Extension	UE-X2AP-ID-Extension,
	iE-Extensions				ProtocolExtensionContainer { {UE-ContextReferenceAtSeNB-ItemExtIEs} } OPTIONAL,
	...
}
*/

struct UE_ContextReferenceAtSeNB : asn::sequence<4, 0, true, 1>
{
	static constexpr const char* name() {return "UE-ContextReferenceAtSeNB";}
	using parent_t = asn::sequence<4, 0, true, 1>;
	struct source_GlobalSeNB_ID_t : GlobalENB_ID
	{
		static constexpr const char* name() {return "source_GlobalSeNB_ID_t";}
		using parent_t = GlobalENB_ID;

	};
	source_GlobalSeNB_ID_t& ref_source_GlobalSeNB_ID() {return source_GlobalSeNB_ID;}
	source_GlobalSeNB_ID_t const& ref_source_GlobalSeNB_ID() const {return source_GlobalSeNB_ID;}
	struct seNB_UE_X2AP_ID_t : UE_X2AP_ID
	{
		static constexpr const char* name() {return "seNB_UE_X2AP_ID_t";}
		using parent_t = UE_X2AP_ID;

	};
	seNB_UE_X2AP_ID_t& ref_seNB_UE_X2AP_ID() {return seNB_UE_X2AP_ID;}
	seNB_UE_X2AP_ID_t const& ref_seNB_UE_X2AP_ID() const {return seNB_UE_X2AP_ID;}
	struct seNB_UE_X2AP_ID_Extension_t : UE_X2AP_ID_Extension
	{
		static constexpr const char* name() {return "seNB_UE_X2AP_ID_Extension_t";}
		using parent_t = UE_X2AP_ID_Extension;

	};
	seNB_UE_X2AP_ID_Extension_t& ref_seNB_UE_X2AP_ID_Extension() {return seNB_UE_X2AP_ID_Extension;}
	seNB_UE_X2AP_ID_Extension_t const& ref_seNB_UE_X2AP_ID_Extension() const {return seNB_UE_X2AP_ID_Extension;}
	struct iE_Extensions_t : ProtocolExtensionContainer<UE_ContextReferenceAtSeNB_ItemExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<UE_ContextReferenceAtSeNB_ItemExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(source_GlobalSeNB_ID);
		v(seNB_UE_X2AP_ID);
		v(seNB_UE_X2AP_ID_Extension);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(source_GlobalSeNB_ID);
		v(seNB_UE_X2AP_ID);
		v(seNB_UE_X2AP_ID_Extension);
		v(iE_Extensions);

	};
	void clear()
	{
		source_GlobalSeNB_ID.clear();
		seNB_UE_X2AP_ID.clear();
		seNB_UE_X2AP_ID_Extension.clear();
		iE_Extensions.clear();

	};
	private:
	source_GlobalSeNB_ID_t	source_GlobalSeNB_ID;
	seNB_UE_X2AP_ID_t	seNB_UE_X2AP_ID;
	seNB_UE_X2AP_ID_Extension_t	seNB_UE_X2AP_ID_Extension;
	iE_Extensions_t	iE_Extensions;

};
/*
UE-ContextReferenceAtWT-ItemExtIEs	X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct UE_ContextReferenceAtWT_ItemExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
UE-ContextReferenceAtWT ::= SEQUENCE {
	wTID					WTID,
	wT-UE-XwAP-ID			WT-UE-XwAP-ID,
	iE-Extensions			ProtocolExtensionContainer { {UE-ContextReferenceAtWT-ItemExtIEs} } OPTIONAL,
	...
}
*/

struct UE_ContextReferenceAtWT : asn::sequence<3, 0, true, 1>
{
	static constexpr const char* name() {return "UE-ContextReferenceAtWT";}
	using parent_t = asn::sequence<3, 0, true, 1>;
	struct wTID_t : WTID
	{
		static constexpr const char* name() {return "wTID_t";}
		using parent_t = WTID;

	};
	wTID_t& ref_wTID() {return wTID;}
	wTID_t const& ref_wTID() const {return wTID;}
	struct wT_UE_XwAP_ID_t : WT_UE_XwAP_ID
	{
		static constexpr const char* name() {return "wT_UE_XwAP_ID_t";}
		using parent_t = WT_UE_XwAP_ID;

	};
	wT_UE_XwAP_ID_t& ref_wT_UE_XwAP_ID() {return wT_UE_XwAP_ID;}
	wT_UE_XwAP_ID_t const& ref_wT_UE_XwAP_ID() const {return wT_UE_XwAP_ID;}
	struct iE_Extensions_t : ProtocolExtensionContainer<UE_ContextReferenceAtWT_ItemExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<UE_ContextReferenceAtWT_ItemExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(wTID);
		v(wT_UE_XwAP_ID);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(wTID);
		v(wT_UE_XwAP_ID);
		v(iE_Extensions);

	};
	void clear()
	{
		wTID.clear();
		wT_UE_XwAP_ID.clear();
		iE_Extensions.clear();

	};
	private:
	wTID_t	wTID;
	wT_UE_XwAP_ID_t	wT_UE_XwAP_ID;
	iE_Extensions_t	iE_Extensions;

};
/*
UE-ContextReferenceAtSgNB-ItemExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct UE_ContextReferenceAtSgNB_ItemExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
UE-ContextReferenceAtSgNB ::= SEQUENCE {
	source-GlobalSgNB-ID			GlobalGNB-ID,
	sgNB-UE-X2AP-ID				SgNB-UE-X2AP-ID,
	iE-Extensions				ProtocolExtensionContainer { {UE-ContextReferenceAtSgNB-ItemExtIEs} } OPTIONAL,
	...
}
*/

struct UE_ContextReferenceAtSgNB : asn::sequence<3, 0, true, 1>
{
	static constexpr const char* name() {return "UE-ContextReferenceAtSgNB";}
	using parent_t = asn::sequence<3, 0, true, 1>;
	struct source_GlobalSgNB_ID_t : GlobalGNB_ID
	{
		static constexpr const char* name() {return "source_GlobalSgNB_ID_t";}
		using parent_t = GlobalGNB_ID;

	};
	source_GlobalSgNB_ID_t& ref_source_GlobalSgNB_ID() {return source_GlobalSgNB_ID;}
	source_GlobalSgNB_ID_t const& ref_source_GlobalSgNB_ID() const {return source_GlobalSgNB_ID;}
	struct sgNB_UE_X2AP_ID_t : SgNB_UE_X2AP_ID
	{
		static constexpr const char* name() {return "sgNB_UE_X2AP_ID_t";}
		using parent_t = SgNB_UE_X2AP_ID;

	};
	sgNB_UE_X2AP_ID_t& ref_sgNB_UE_X2AP_ID() {return sgNB_UE_X2AP_ID;}
	sgNB_UE_X2AP_ID_t const& ref_sgNB_UE_X2AP_ID() const {return sgNB_UE_X2AP_ID;}
	struct iE_Extensions_t : ProtocolExtensionContainer<UE_ContextReferenceAtSgNB_ItemExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<UE_ContextReferenceAtSgNB_ItemExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(source_GlobalSgNB_ID);
		v(sgNB_UE_X2AP_ID);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(source_GlobalSgNB_ID);
		v(sgNB_UE_X2AP_ID);
		v(iE_Extensions);

	};
	void clear()
	{
		source_GlobalSgNB_ID.clear();
		sgNB_UE_X2AP_ID.clear();
		iE_Extensions.clear();

	};
	private:
	source_GlobalSgNB_ID_t	source_GlobalSgNB_ID;
	sgNB_UE_X2AP_ID_t	sgNB_UE_X2AP_ID;
	iE_Extensions_t	iE_Extensions;

};
/*
HandoverRequest-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-Old-eNB-UE-X2AP-ID					CRITICALITY reject	TYPE UE-X2AP-ID								PRESENCE mandatory}|
	{ ID id-Cause								CRITICALITY ignore	TYPE Cause									PRESENCE mandatory}|
	{ ID id-TargetCell-ID						CRITICALITY reject	TYPE ECGI									PRESENCE mandatory}|
	{ ID id-GUMMEI-ID							CRITICALITY reject	TYPE GUMMEI									PRESENCE mandatory}|
	{ ID id-UE-ContextInformation				CRITICALITY reject	TYPE UE-ContextInformation					PRESENCE mandatory}|
	{ ID id-UE-HistoryInformation				CRITICALITY ignore	TYPE UE-HistoryInformation					PRESENCE mandatory}|
	{ ID id-TraceActivation						CRITICALITY ignore	TYPE TraceActivation						PRESENCE optional}|
	{ ID id-SRVCCOperationPossible				CRITICALITY ignore	TYPE SRVCCOperationPossible					PRESENCE optional}|
	{ ID id-CSGMembershipStatus					CRITICALITY reject	TYPE CSGMembershipStatus					PRESENCE optional}|
	{ ID id-MobilityInformation					CRITICALITY ignore	TYPE MobilityInformation					PRESENCE optional}|
	{ ID id-Masked-IMEISV						CRITICALITY ignore	TYPE Masked-IMEISV							PRESENCE optional}|
	{ ID id-UE-HistoryInformationFromTheUE		CRITICALITY ignore	TYPE UE-HistoryInformationFromTheUE		PRESENCE optional}|
	{ ID id-ExpectedUEBehaviour					CRITICALITY ignore	TYPE ExpectedUEBehaviour					PRESENCE optional}|
	{ ID id-ProSeAuthorized						CRITICALITY ignore	TYPE ProSeAuthorized						PRESENCE optional}|
	{ ID id-UE-ContextReferenceAtSeNB			CRITICALITY ignore	TYPE UE-ContextReferenceAtSeNB			PRESENCE optional}|
	{ ID id-Old-eNB-UE-X2AP-ID-Extension		CRITICALITY reject	TYPE UE-X2AP-ID-Extension					PRESENCE optional}|
	{ ID id-V2XServicesAuthorized				CRITICALITY ignore	TYPE V2XServicesAuthorized					PRESENCE optional}|
	{ ID id-UE-ContextReferenceAtWT				CRITICALITY ignore	TYPE UE-ContextReferenceAtWT				PRESENCE optional}|
	{ ID id-NRUESecurityCapabilities				CRITICALITY ignore	TYPE NRUESecurityCapabilities				PRESENCE optional}|
	{ ID id-UE-ContextReferenceAtSgNB			CRITICALITY ignore	TYPE UE-ContextReferenceAtSgNB			PRESENCE optional}|
	{ ID id-AerialUEsubscriptionInformation		CRITICALITY ignore	TYPE AerialUEsubscriptionInformation	PRESENCE optional}|
	{ ID id-Subscription-Based-UE-DifferentiationInfo		CRITICALITY ignore	TYPE Subscription-Based-UE-DifferentiationInfo				PRESENCE optional},
	...
}
*/

struct HandoverRequest_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 23; }
		void clear() {type = 0;}
		void select_id_Old_eNB_UE_X2AP_ID() { set(id_Old_eNB_UE_X2AP_ID); type=1;}
		void select_id_Cause() { set(id_Cause); type=2;}
		void select_id_TargetCell_ID() { set(id_TargetCell_ID); type=3;}
		void select_id_GUMMEI_ID() { set(id_GUMMEI_ID); type=4;}
		void select_id_UE_ContextInformation() { set(id_UE_ContextInformation); type=5;}
		void select_id_UE_HistoryInformation() { set(id_UE_HistoryInformation); type=6;}
		void select_id_TraceActivation() { set(id_TraceActivation); type=7;}
		void select_id_SRVCCOperationPossible() { set(id_SRVCCOperationPossible); type=8;}
		void select_id_CSGMembershipStatus() { set(id_CSGMembershipStatus); type=9;}
		void select_id_MobilityInformation() { set(id_MobilityInformation); type=10;}
		void select_id_Masked_IMEISV() { set(id_Masked_IMEISV); type=11;}
		void select_id_UE_HistoryInformationFromTheUE() { set(id_UE_HistoryInformationFromTheUE); type=12;}
		void select_id_ExpectedUEBehaviour() { set(id_ExpectedUEBehaviour); type=13;}
		void select_id_ProSeAuthorized() { set(id_ProSeAuthorized); type=14;}
		void select_id_UE_ContextReferenceAtSeNB() { set(id_UE_ContextReferenceAtSeNB); type=15;}
		void select_id_Old_eNB_UE_X2AP_ID_Extension() { set(id_Old_eNB_UE_X2AP_ID_Extension); type=16;}
		void select_id_V2XServicesAuthorized() { set(id_V2XServicesAuthorized); type=17;}
		void select_id_UE_ContextReferenceAtWT() { set(id_UE_ContextReferenceAtWT); type=18;}
		void select_id_NRUESecurityCapabilities() { set(id_NRUESecurityCapabilities); type=19;}
		void select_id_UE_ContextReferenceAtSgNB() { set(id_UE_ContextReferenceAtSgNB); type=20;}
		void select_id_AerialUEsubscriptionInformation() { set(id_AerialUEsubscriptionInformation); type=21;}
		void select_id_Subscription_Based_UE_DifferentiationInfo() { set(id_Subscription_Based_UE_DifferentiationInfo); type=22;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_Old_eNB_UE_X2AP_ID)) { type = 1; return true; }
			else if(equal(id_Cause)) { type = 2; return true; }
			else if(equal(id_TargetCell_ID)) { type = 3; return true; }
			else if(equal(id_GUMMEI_ID)) { type = 4; return true; }
			else if(equal(id_UE_ContextInformation)) { type = 5; return true; }
			else if(equal(id_UE_HistoryInformation)) { type = 6; return true; }
			else if(equal(id_TraceActivation)) { type = 7; return true; }
			else if(equal(id_SRVCCOperationPossible)) { type = 8; return true; }
			else if(equal(id_CSGMembershipStatus)) { type = 9; return true; }
			else if(equal(id_MobilityInformation)) { type = 10; return true; }
			else if(equal(id_Masked_IMEISV)) { type = 11; return true; }
			else if(equal(id_UE_HistoryInformationFromTheUE)) { type = 12; return true; }
			else if(equal(id_ExpectedUEBehaviour)) { type = 13; return true; }
			else if(equal(id_ProSeAuthorized)) { type = 14; return true; }
			else if(equal(id_UE_ContextReferenceAtSeNB)) { type = 15; return true; }
			else if(equal(id_Old_eNB_UE_X2AP_ID_Extension)) { type = 16; return true; }
			else if(equal(id_V2XServicesAuthorized)) { type = 17; return true; }
			else if(equal(id_UE_ContextReferenceAtWT)) { type = 18; return true; }
			else if(equal(id_NRUESecurityCapabilities)) { type = 19; return true; }
			else if(equal(id_UE_ContextReferenceAtSgNB)) { type = 20; return true; }
			else if(equal(id_AerialUEsubscriptionInformation)) { type = 21; return true; }
			else if(equal(id_Subscription_Based_UE_DifferentiationInfo)) { type = 22; return true; }
			else { type = 23; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_Old_eNB_UE_X2AP_ID);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_Cause);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_TargetCell_ID);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(id_GUMMEI_ID);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(id_UE_ContextInformation);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(id_UE_HistoryInformation);} return false;
			case 7: type = 7; if(v(ref_nested())) { return equal(id_TraceActivation);} return false;
			case 8: type = 8; if(v(ref_nested())) { return equal(id_SRVCCOperationPossible);} return false;
			case 9: type = 9; if(v(ref_nested())) { return equal(id_CSGMembershipStatus);} return false;
			case 10: type = 10; if(v(ref_nested())) { return equal(id_MobilityInformation);} return false;
			case 11: type = 11; if(v(ref_nested())) { return equal(id_Masked_IMEISV);} return false;
			case 12: type = 12; if(v(ref_nested())) { return equal(id_UE_HistoryInformationFromTheUE);} return false;
			case 13: type = 13; if(v(ref_nested())) { return equal(id_ExpectedUEBehaviour);} return false;
			case 14: type = 14; if(v(ref_nested())) { return equal(id_ProSeAuthorized);} return false;
			case 15: type = 15; if(v(ref_nested())) { return equal(id_UE_ContextReferenceAtSeNB);} return false;
			case 16: type = 16; if(v(ref_nested())) { return equal(id_Old_eNB_UE_X2AP_ID_Extension);} return false;
			case 17: type = 17; if(v(ref_nested())) { return equal(id_V2XServicesAuthorized);} return false;
			case 18: type = 18; if(v(ref_nested())) { return equal(id_UE_ContextReferenceAtWT);} return false;
			case 19: type = 19; if(v(ref_nested())) { return equal(id_NRUESecurityCapabilities);} return false;
			case 20: type = 20; if(v(ref_nested())) { return equal(id_UE_ContextReferenceAtSgNB);} return false;
			case 21: type = 21; if(v(ref_nested())) { return equal(id_AerialUEsubscriptionInformation);} return false;
			case 22: type = 22; if(v(ref_nested())) { return equal(id_Subscription_Based_UE_DifferentiationInfo);} return false;
			case 23: type = 23; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 23; }
		void clear() {type = 0;}
		void select_id_Old_eNB_UE_X2AP_ID() { set(reject); type=1;}
		void select_id_Cause() { set(ignore); type=2;}
		void select_id_TargetCell_ID() { set(reject); type=3;}
		void select_id_GUMMEI_ID() { set(reject); type=4;}
		void select_id_UE_ContextInformation() { set(reject); type=5;}
		void select_id_UE_HistoryInformation() { set(ignore); type=6;}
		void select_id_TraceActivation() { set(ignore); type=7;}
		void select_id_SRVCCOperationPossible() { set(ignore); type=8;}
		void select_id_CSGMembershipStatus() { set(reject); type=9;}
		void select_id_MobilityInformation() { set(ignore); type=10;}
		void select_id_Masked_IMEISV() { set(ignore); type=11;}
		void select_id_UE_HistoryInformationFromTheUE() { set(ignore); type=12;}
		void select_id_ExpectedUEBehaviour() { set(ignore); type=13;}
		void select_id_ProSeAuthorized() { set(ignore); type=14;}
		void select_id_UE_ContextReferenceAtSeNB() { set(ignore); type=15;}
		void select_id_Old_eNB_UE_X2AP_ID_Extension() { set(reject); type=16;}
		void select_id_V2XServicesAuthorized() { set(ignore); type=17;}
		void select_id_UE_ContextReferenceAtWT() { set(ignore); type=18;}
		void select_id_NRUESecurityCapabilities() { set(ignore); type=19;}
		void select_id_UE_ContextReferenceAtSgNB() { set(ignore); type=20;}
		void select_id_AerialUEsubscriptionInformation() { set(ignore); type=21;}
		void select_id_Subscription_Based_UE_DifferentiationInfo() { set(ignore); type=22;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else if(equal(ignore)) { type = 2; return true; }
			else if(equal(reject)) { type = 3; return true; }
			else if(equal(reject)) { type = 4; return true; }
			else if(equal(reject)) { type = 5; return true; }
			else if(equal(ignore)) { type = 6; return true; }
			else if(equal(ignore)) { type = 7; return true; }
			else if(equal(ignore)) { type = 8; return true; }
			else if(equal(reject)) { type = 9; return true; }
			else if(equal(ignore)) { type = 10; return true; }
			else if(equal(ignore)) { type = 11; return true; }
			else if(equal(ignore)) { type = 12; return true; }
			else if(equal(ignore)) { type = 13; return true; }
			else if(equal(ignore)) { type = 14; return true; }
			else if(equal(ignore)) { type = 15; return true; }
			else if(equal(reject)) { type = 16; return true; }
			else if(equal(ignore)) { type = 17; return true; }
			else if(equal(ignore)) { type = 18; return true; }
			else if(equal(ignore)) { type = 19; return true; }
			else if(equal(ignore)) { type = 20; return true; }
			else if(equal(ignore)) { type = 21; return true; }
			else if(equal(ignore)) { type = 22; return true; }
			else { type = 23; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(ignore);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(reject);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(reject);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(reject);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(ignore);} return false;
			case 7: type = 7; if(v(ref_nested())) { return equal(ignore);} return false;
			case 8: type = 8; if(v(ref_nested())) { return equal(ignore);} return false;
			case 9: type = 9; if(v(ref_nested())) { return equal(reject);} return false;
			case 10: type = 10; if(v(ref_nested())) { return equal(ignore);} return false;
			case 11: type = 11; if(v(ref_nested())) { return equal(ignore);} return false;
			case 12: type = 12; if(v(ref_nested())) { return equal(ignore);} return false;
			case 13: type = 13; if(v(ref_nested())) { return equal(ignore);} return false;
			case 14: type = 14; if(v(ref_nested())) { return equal(ignore);} return false;
			case 15: type = 15; if(v(ref_nested())) { return equal(ignore);} return false;
			case 16: type = 16; if(v(ref_nested())) { return equal(reject);} return false;
			case 17: type = 17; if(v(ref_nested())) { return equal(ignore);} return false;
			case 18: type = 18; if(v(ref_nested())) { return equal(ignore);} return false;
			case 19: type = 19; if(v(ref_nested())) { return equal(ignore);} return false;
			case 20: type = 20; if(v(ref_nested())) { return equal(ignore);} return false;
			case 21: type = 21; if(v(ref_nested())) { return equal(ignore);} return false;
			case 22: type = 22; if(v(ref_nested())) { return equal(ignore);} return false;
			case 23: type = 23; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		UE_X2AP_ID& select_id_Old_eNB_UE_X2AP_ID() { return set<UE_X2AP_ID>(1); }
		UE_X2AP_ID const* get_id_Old_eNB_UE_X2AP_ID() const { return get<UE_X2AP_ID>(1); }
		Cause& select_id_Cause() { return set<Cause>(2); }
		Cause const* get_id_Cause() const { return get<Cause>(2); }
		ECGI& select_id_TargetCell_ID() { return set<ECGI>(3); }
		ECGI const* get_id_TargetCell_ID() const { return get<ECGI>(3); }
		GUMMEI& select_id_GUMMEI_ID() { return set<GUMMEI>(4); }
		GUMMEI const* get_id_GUMMEI_ID() const { return get<GUMMEI>(4); }
		UE_ContextInformation& select_id_UE_ContextInformation() { return set<UE_ContextInformation>(5); }
		UE_ContextInformation const* get_id_UE_ContextInformation() const { return get<UE_ContextInformation>(5); }
		UE_HistoryInformation& select_id_UE_HistoryInformation() { return set<UE_HistoryInformation>(6); }
		UE_HistoryInformation const* get_id_UE_HistoryInformation() const { return get<UE_HistoryInformation>(6); }
		TraceActivation& select_id_TraceActivation() { return set<TraceActivation>(7); }
		TraceActivation const* get_id_TraceActivation() const { return get<TraceActivation>(7); }
		SRVCCOperationPossible& select_id_SRVCCOperationPossible() { return set<SRVCCOperationPossible>(8); }
		SRVCCOperationPossible const* get_id_SRVCCOperationPossible() const { return get<SRVCCOperationPossible>(8); }
		CSGMembershipStatus& select_id_CSGMembershipStatus() { return set<CSGMembershipStatus>(9); }
		CSGMembershipStatus const* get_id_CSGMembershipStatus() const { return get<CSGMembershipStatus>(9); }
		MobilityInformation& select_id_MobilityInformation() { return set<MobilityInformation>(10); }
		MobilityInformation const* get_id_MobilityInformation() const { return get<MobilityInformation>(10); }
		Masked_IMEISV& select_id_Masked_IMEISV() { return set<Masked_IMEISV>(11); }
		Masked_IMEISV const* get_id_Masked_IMEISV() const { return get<Masked_IMEISV>(11); }
		UE_HistoryInformationFromTheUE& select_id_UE_HistoryInformationFromTheUE() { return set<UE_HistoryInformationFromTheUE>(12); }
		UE_HistoryInformationFromTheUE const* get_id_UE_HistoryInformationFromTheUE() const { return get<UE_HistoryInformationFromTheUE>(12); }
		ExpectedUEBehaviour& select_id_ExpectedUEBehaviour() { return set<ExpectedUEBehaviour>(13); }
		ExpectedUEBehaviour const* get_id_ExpectedUEBehaviour() const { return get<ExpectedUEBehaviour>(13); }
		ProSeAuthorized& select_id_ProSeAuthorized() { return set<ProSeAuthorized>(14); }
		ProSeAuthorized const* get_id_ProSeAuthorized() const { return get<ProSeAuthorized>(14); }
		UE_ContextReferenceAtSeNB& select_id_UE_ContextReferenceAtSeNB() { return set<UE_ContextReferenceAtSeNB>(15); }
		UE_ContextReferenceAtSeNB const* get_id_UE_ContextReferenceAtSeNB() const { return get<UE_ContextReferenceAtSeNB>(15); }
		UE_X2AP_ID_Extension& select_id_Old_eNB_UE_X2AP_ID_Extension() { return set<UE_X2AP_ID_Extension>(16); }
		UE_X2AP_ID_Extension const* get_id_Old_eNB_UE_X2AP_ID_Extension() const { return get<UE_X2AP_ID_Extension>(16); }
		V2XServicesAuthorized& select_id_V2XServicesAuthorized() { return set<V2XServicesAuthorized>(17); }
		V2XServicesAuthorized const* get_id_V2XServicesAuthorized() const { return get<V2XServicesAuthorized>(17); }
		UE_ContextReferenceAtWT& select_id_UE_ContextReferenceAtWT() { return set<UE_ContextReferenceAtWT>(18); }
		UE_ContextReferenceAtWT const* get_id_UE_ContextReferenceAtWT() const { return get<UE_ContextReferenceAtWT>(18); }
		NRUESecurityCapabilities& select_id_NRUESecurityCapabilities() { return set<NRUESecurityCapabilities>(19); }
		NRUESecurityCapabilities const* get_id_NRUESecurityCapabilities() const { return get<NRUESecurityCapabilities>(19); }
		UE_ContextReferenceAtSgNB& select_id_UE_ContextReferenceAtSgNB() { return set<UE_ContextReferenceAtSgNB>(20); }
		UE_ContextReferenceAtSgNB const* get_id_UE_ContextReferenceAtSgNB() const { return get<UE_ContextReferenceAtSgNB>(20); }
		AerialUEsubscriptionInformation& select_id_AerialUEsubscriptionInformation() { return set<AerialUEsubscriptionInformation>(21); }
		AerialUEsubscriptionInformation const* get_id_AerialUEsubscriptionInformation() const { return get<AerialUEsubscriptionInformation>(21); }
		Subscription_Based_UE_DifferentiationInfo& select_id_Subscription_Based_UE_DifferentiationInfo() { return set<Subscription_Based_UE_DifferentiationInfo>(22); }
		Subscription_Based_UE_DifferentiationInfo const* get_id_Subscription_Based_UE_DifferentiationInfo() const { return get<Subscription_Based_UE_DifferentiationInfo>(22); }
		bool is_unknown() const { return type == 23; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<UE_X2AP_ID>(); break;
			case 2: var.destroy<Cause>(); break;
			case 3: var.destroy<ECGI>(); break;
			case 4: var.destroy<GUMMEI>(); break;
			case 5: var.destroy<UE_ContextInformation>(); break;
			case 6: var.destroy<UE_HistoryInformation>(); break;
			case 7: var.destroy<TraceActivation>(); break;
			case 8: var.destroy<SRVCCOperationPossible>(); break;
			case 9: var.destroy<CSGMembershipStatus>(); break;
			case 10: var.destroy<MobilityInformation>(); break;
			case 11: var.destroy<Masked_IMEISV>(); break;
			case 12: var.destroy<UE_HistoryInformationFromTheUE>(); break;
			case 13: var.destroy<ExpectedUEBehaviour>(); break;
			case 14: var.destroy<ProSeAuthorized>(); break;
			case 15: var.destroy<UE_ContextReferenceAtSeNB>(); break;
			case 16: var.destroy<UE_X2AP_ID_Extension>(); break;
			case 17: var.destroy<V2XServicesAuthorized>(); break;
			case 18: var.destroy<UE_ContextReferenceAtWT>(); break;
			case 19: var.destroy<NRUESecurityCapabilities>(); break;
			case 20: var.destroy<UE_ContextReferenceAtSgNB>(); break;
			case 21: var.destroy<AerialUEsubscriptionInformation>(); break;
			case 22: var.destroy<Subscription_Based_UE_DifferentiationInfo>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<UE_X2AP_ID>(1);
			v.template operator()<Cause>(2);
			v.template operator()<ECGI>(3);
			v.template operator()<GUMMEI>(4);
			v.template operator()<UE_ContextInformation>(5);
			v.template operator()<UE_HistoryInformation>(6);
			v.template operator()<TraceActivation>(7);
			v.template operator()<SRVCCOperationPossible>(8);
			v.template operator()<CSGMembershipStatus>(9);
			v.template operator()<MobilityInformation>(10);
			v.template operator()<Masked_IMEISV>(11);
			v.template operator()<UE_HistoryInformationFromTheUE>(12);
			v.template operator()<ExpectedUEBehaviour>(13);
			v.template operator()<ProSeAuthorized>(14);
			v.template operator()<UE_ContextReferenceAtSeNB>(15);
			v.template operator()<UE_X2AP_ID_Extension>(16);
			v.template operator()<V2XServicesAuthorized>(17);
			v.template operator()<UE_ContextReferenceAtWT>(18);
			v.template operator()<NRUESecurityCapabilities>(19);
			v.template operator()<UE_ContextReferenceAtSgNB>(20);
			v.template operator()<AerialUEsubscriptionInformation>(21);
			v.template operator()<Subscription_Based_UE_DifferentiationInfo>(22);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_Old_eNB_UE_X2AP_ID()); return true;
			case 2: v(select_id_Cause()); return true;
			case 3: v(select_id_TargetCell_ID()); return true;
			case 4: v(select_id_GUMMEI_ID()); return true;
			case 5: v(select_id_UE_ContextInformation()); return true;
			case 6: v(select_id_UE_HistoryInformation()); return true;
			case 7: v(select_id_TraceActivation()); return true;
			case 8: v(select_id_SRVCCOperationPossible()); return true;
			case 9: v(select_id_CSGMembershipStatus()); return true;
			case 10: v(select_id_MobilityInformation()); return true;
			case 11: v(select_id_Masked_IMEISV()); return true;
			case 12: v(select_id_UE_HistoryInformationFromTheUE()); return true;
			case 13: v(select_id_ExpectedUEBehaviour()); return true;
			case 14: v(select_id_ProSeAuthorized()); return true;
			case 15: v(select_id_UE_ContextReferenceAtSeNB()); return true;
			case 16: v(select_id_Old_eNB_UE_X2AP_ID_Extension()); return true;
			case 17: v(select_id_V2XServicesAuthorized()); return true;
			case 18: v(select_id_UE_ContextReferenceAtWT()); return true;
			case 19: v(select_id_NRUESecurityCapabilities()); return true;
			case 20: v(select_id_UE_ContextReferenceAtSgNB()); return true;
			case 21: v(select_id_AerialUEsubscriptionInformation()); return true;
			case 22: v(select_id_Subscription_Based_UE_DifferentiationInfo()); return true;
			case 23: if(type != 23) {clear(); asn::base::set();} type = 23; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<UE_X2AP_ID>()); return true;
			case 2: v(var.as<Cause>()); return true;
			case 3: v(var.as<ECGI>()); return true;
			case 4: v(var.as<GUMMEI>()); return true;
			case 5: v(var.as<UE_ContextInformation>()); return true;
			case 6: v(var.as<UE_HistoryInformation>()); return true;
			case 7: v(var.as<TraceActivation>()); return true;
			case 8: v(var.as<SRVCCOperationPossible>()); return true;
			case 9: v(var.as<CSGMembershipStatus>()); return true;
			case 10: v(var.as<MobilityInformation>()); return true;
			case 11: v(var.as<Masked_IMEISV>()); return true;
			case 12: v(var.as<UE_HistoryInformationFromTheUE>()); return true;
			case 13: v(var.as<ExpectedUEBehaviour>()); return true;
			case 14: v(var.as<ProSeAuthorized>()); return true;
			case 15: v(var.as<UE_ContextReferenceAtSeNB>()); return true;
			case 16: v(var.as<UE_X2AP_ID_Extension>()); return true;
			case 17: v(var.as<V2XServicesAuthorized>()); return true;
			case 18: v(var.as<UE_ContextReferenceAtWT>()); return true;
			case 19: v(var.as<NRUESecurityCapabilities>()); return true;
			case 20: v(var.as<UE_ContextReferenceAtSgNB>()); return true;
			case 21: v(var.as<AerialUEsubscriptionInformation>()); return true;
			case 22: v(var.as<Subscription_Based_UE_DifferentiationInfo>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(AerialUEsubscriptionInformation)];
			char dummy2[sizeof(CSGMembershipStatus)];
			char dummy3[sizeof(Cause)];
			char dummy4[sizeof(ECGI)];
			char dummy5[sizeof(ExpectedUEBehaviour)];
			char dummy6[sizeof(GUMMEI)];
			char dummy7[sizeof(Masked_IMEISV)];
			char dummy8[sizeof(MobilityInformation)];
			char dummy9[sizeof(NRUESecurityCapabilities)];
			char dummy10[sizeof(ProSeAuthorized)];
			char dummy11[sizeof(SRVCCOperationPossible)];
			char dummy12[sizeof(Subscription_Based_UE_DifferentiationInfo)];
			char dummy13[sizeof(TraceActivation)];
			char dummy14[sizeof(UE_ContextInformation)];
			char dummy15[sizeof(UE_ContextReferenceAtSeNB)];
			char dummy16[sizeof(UE_ContextReferenceAtSgNB)];
			char dummy17[sizeof(UE_ContextReferenceAtWT)];
			char dummy18[sizeof(UE_HistoryInformation)];
			char dummy19[sizeof(UE_HistoryInformationFromTheUE)];
			char dummy20[sizeof(UE_X2AP_ID)];
			char dummy21[sizeof(UE_X2AP_ID_Extension)];
			char dummy22[sizeof(V2XServicesAuthorized)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 23; }
		void clear() {type = 0;}
		void select_id_Old_eNB_UE_X2AP_ID() { set(mandatory); type=1;}
		void select_id_Cause() { set(mandatory); type=2;}
		void select_id_TargetCell_ID() { set(mandatory); type=3;}
		void select_id_GUMMEI_ID() { set(mandatory); type=4;}
		void select_id_UE_ContextInformation() { set(mandatory); type=5;}
		void select_id_UE_HistoryInformation() { set(mandatory); type=6;}
		void select_id_TraceActivation() { set(optional); type=7;}
		void select_id_SRVCCOperationPossible() { set(optional); type=8;}
		void select_id_CSGMembershipStatus() { set(optional); type=9;}
		void select_id_MobilityInformation() { set(optional); type=10;}
		void select_id_Masked_IMEISV() { set(optional); type=11;}
		void select_id_UE_HistoryInformationFromTheUE() { set(optional); type=12;}
		void select_id_ExpectedUEBehaviour() { set(optional); type=13;}
		void select_id_ProSeAuthorized() { set(optional); type=14;}
		void select_id_UE_ContextReferenceAtSeNB() { set(optional); type=15;}
		void select_id_Old_eNB_UE_X2AP_ID_Extension() { set(optional); type=16;}
		void select_id_V2XServicesAuthorized() { set(optional); type=17;}
		void select_id_UE_ContextReferenceAtWT() { set(optional); type=18;}
		void select_id_NRUESecurityCapabilities() { set(optional); type=19;}
		void select_id_UE_ContextReferenceAtSgNB() { set(optional); type=20;}
		void select_id_AerialUEsubscriptionInformation() { set(optional); type=21;}
		void select_id_Subscription_Based_UE_DifferentiationInfo() { set(optional); type=22;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(mandatory)) { type = 2; return true; }
			else if(equal(mandatory)) { type = 3; return true; }
			else if(equal(mandatory)) { type = 4; return true; }
			else if(equal(mandatory)) { type = 5; return true; }
			else if(equal(mandatory)) { type = 6; return true; }
			else if(equal(optional)) { type = 7; return true; }
			else if(equal(optional)) { type = 8; return true; }
			else if(equal(optional)) { type = 9; return true; }
			else if(equal(optional)) { type = 10; return true; }
			else if(equal(optional)) { type = 11; return true; }
			else if(equal(optional)) { type = 12; return true; }
			else if(equal(optional)) { type = 13; return true; }
			else if(equal(optional)) { type = 14; return true; }
			else if(equal(optional)) { type = 15; return true; }
			else if(equal(optional)) { type = 16; return true; }
			else if(equal(optional)) { type = 17; return true; }
			else if(equal(optional)) { type = 18; return true; }
			else if(equal(optional)) { type = 19; return true; }
			else if(equal(optional)) { type = 20; return true; }
			else if(equal(optional)) { type = 21; return true; }
			else if(equal(optional)) { type = 22; return true; }
			else { type = 23; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 7: type = 7; if(v(ref_nested())) { return equal(optional);} return false;
			case 8: type = 8; if(v(ref_nested())) { return equal(optional);} return false;
			case 9: type = 9; if(v(ref_nested())) { return equal(optional);} return false;
			case 10: type = 10; if(v(ref_nested())) { return equal(optional);} return false;
			case 11: type = 11; if(v(ref_nested())) { return equal(optional);} return false;
			case 12: type = 12; if(v(ref_nested())) { return equal(optional);} return false;
			case 13: type = 13; if(v(ref_nested())) { return equal(optional);} return false;
			case 14: type = 14; if(v(ref_nested())) { return equal(optional);} return false;
			case 15: type = 15; if(v(ref_nested())) { return equal(optional);} return false;
			case 16: type = 16; if(v(ref_nested())) { return equal(optional);} return false;
			case 17: type = 17; if(v(ref_nested())) { return equal(optional);} return false;
			case 18: type = 18; if(v(ref_nested())) { return equal(optional);} return false;
			case 19: type = 19; if(v(ref_nested())) { return equal(optional);} return false;
			case 20: type = 20; if(v(ref_nested())) { return equal(optional);} return false;
			case 21: type = 21; if(v(ref_nested())) { return equal(optional);} return false;
			case 22: type = 22; if(v(ref_nested())) { return equal(optional);} return false;
			case 23: type = 23; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
HandoverRequest ::= SEQUENCE {
	protocolIEs			ProtocolIE-Container	{{HandoverRequest-IEs}},
	...
}
*/

struct HandoverRequest : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "HandoverRequest";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<HandoverRequest_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<HandoverRequest_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
HandoverRequestAcknowledge-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-Old-eNB-UE-X2AP-ID							CRITICALITY ignore	TYPE UE-X2AP-ID		PRESENCE mandatory}|
	{ ID id-New-eNB-UE-X2AP-ID							CRITICALITY ignore	TYPE UE-X2AP-ID		PRESENCE mandatory}|
	{ ID id-E-RABs-Admitted-List						CRITICALITY ignore	TYPE E-RABs-Admitted-List	PRESENCE mandatory}|
	{ ID id-E-RABs-NotAdmitted-List						CRITICALITY ignore	TYPE E-RAB-List		PRESENCE optional}|
	{ ID id-TargeteNBtoSource-eNBTransparentContainer	CRITICALITY ignore	TYPE TargeteNBtoSource-eNBTransparentContainer	PRESENCE mandatory}|
	{ ID id-CriticalityDiagnostics						CRITICALITY ignore	TYPE CriticalityDiagnostics	PRESENCE optional}|
	{ ID id-UE-ContextKeptIndicator						CRITICALITY ignore	TYPE UE-ContextKeptIndicator	PRESENCE optional}|
	{ ID id-SeNB-UE-X2AP-ID-Extension					CRITICALITY ignore	TYPE UE-X2AP-ID-Extension	PRESENCE optional}|
	{ ID id-Old-eNB-UE-X2AP-ID-Extension				CRITICALITY ignore	TYPE UE-X2AP-ID-Extension	PRESENCE optional}|
	{ ID id-New-eNB-UE-X2AP-ID-Extension				CRITICALITY reject	TYPE UE-X2AP-ID-Extension	PRESENCE optional}|
	{ ID id-WT-UE-ContextKeptIndicator					CRITICALITY ignore	TYPE UE-ContextKeptIndicator	PRESENCE optional},
	...
}
*/

struct HandoverRequestAcknowledge_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 12; }
		void clear() {type = 0;}
		void select_id_Old_eNB_UE_X2AP_ID() { set(id_Old_eNB_UE_X2AP_ID); type=1;}
		void select_id_New_eNB_UE_X2AP_ID() { set(id_New_eNB_UE_X2AP_ID); type=2;}
		void select_id_E_RABs_Admitted_List() { set(id_E_RABs_Admitted_List); type=3;}
		void select_id_E_RABs_NotAdmitted_List() { set(id_E_RABs_NotAdmitted_List); type=4;}
		void select_id_TargeteNBtoSource_eNBTransparentContainer() { set(id_TargeteNBtoSource_eNBTransparentContainer); type=5;}
		void select_id_CriticalityDiagnostics() { set(id_CriticalityDiagnostics); type=6;}
		void select_id_UE_ContextKeptIndicator() { set(id_UE_ContextKeptIndicator); type=7;}
		void select_id_SeNB_UE_X2AP_ID_Extension() { set(id_SeNB_UE_X2AP_ID_Extension); type=8;}
		void select_id_Old_eNB_UE_X2AP_ID_Extension() { set(id_Old_eNB_UE_X2AP_ID_Extension); type=9;}
		void select_id_New_eNB_UE_X2AP_ID_Extension() { set(id_New_eNB_UE_X2AP_ID_Extension); type=10;}
		void select_id_WT_UE_ContextKeptIndicator() { set(id_WT_UE_ContextKeptIndicator); type=11;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_Old_eNB_UE_X2AP_ID)) { type = 1; return true; }
			else if(equal(id_New_eNB_UE_X2AP_ID)) { type = 2; return true; }
			else if(equal(id_E_RABs_Admitted_List)) { type = 3; return true; }
			else if(equal(id_E_RABs_NotAdmitted_List)) { type = 4; return true; }
			else if(equal(id_TargeteNBtoSource_eNBTransparentContainer)) { type = 5; return true; }
			else if(equal(id_CriticalityDiagnostics)) { type = 6; return true; }
			else if(equal(id_UE_ContextKeptIndicator)) { type = 7; return true; }
			else if(equal(id_SeNB_UE_X2AP_ID_Extension)) { type = 8; return true; }
			else if(equal(id_Old_eNB_UE_X2AP_ID_Extension)) { type = 9; return true; }
			else if(equal(id_New_eNB_UE_X2AP_ID_Extension)) { type = 10; return true; }
			else if(equal(id_WT_UE_ContextKeptIndicator)) { type = 11; return true; }
			else { type = 12; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_Old_eNB_UE_X2AP_ID);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_New_eNB_UE_X2AP_ID);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_E_RABs_Admitted_List);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(id_E_RABs_NotAdmitted_List);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(id_TargeteNBtoSource_eNBTransparentContainer);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(id_CriticalityDiagnostics);} return false;
			case 7: type = 7; if(v(ref_nested())) { return equal(id_UE_ContextKeptIndicator);} return false;
			case 8: type = 8; if(v(ref_nested())) { return equal(id_SeNB_UE_X2AP_ID_Extension);} return false;
			case 9: type = 9; if(v(ref_nested())) { return equal(id_Old_eNB_UE_X2AP_ID_Extension);} return false;
			case 10: type = 10; if(v(ref_nested())) { return equal(id_New_eNB_UE_X2AP_ID_Extension);} return false;
			case 11: type = 11; if(v(ref_nested())) { return equal(id_WT_UE_ContextKeptIndicator);} return false;
			case 12: type = 12; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 12; }
		void clear() {type = 0;}
		void select_id_Old_eNB_UE_X2AP_ID() { set(ignore); type=1;}
		void select_id_New_eNB_UE_X2AP_ID() { set(ignore); type=2;}
		void select_id_E_RABs_Admitted_List() { set(ignore); type=3;}
		void select_id_E_RABs_NotAdmitted_List() { set(ignore); type=4;}
		void select_id_TargeteNBtoSource_eNBTransparentContainer() { set(ignore); type=5;}
		void select_id_CriticalityDiagnostics() { set(ignore); type=6;}
		void select_id_UE_ContextKeptIndicator() { set(ignore); type=7;}
		void select_id_SeNB_UE_X2AP_ID_Extension() { set(ignore); type=8;}
		void select_id_Old_eNB_UE_X2AP_ID_Extension() { set(ignore); type=9;}
		void select_id_New_eNB_UE_X2AP_ID_Extension() { set(reject); type=10;}
		void select_id_WT_UE_ContextKeptIndicator() { set(ignore); type=11;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else if(equal(ignore)) { type = 2; return true; }
			else if(equal(ignore)) { type = 3; return true; }
			else if(equal(ignore)) { type = 4; return true; }
			else if(equal(ignore)) { type = 5; return true; }
			else if(equal(ignore)) { type = 6; return true; }
			else if(equal(ignore)) { type = 7; return true; }
			else if(equal(ignore)) { type = 8; return true; }
			else if(equal(ignore)) { type = 9; return true; }
			else if(equal(reject)) { type = 10; return true; }
			else if(equal(ignore)) { type = 11; return true; }
			else { type = 12; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(ignore);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(ignore);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(ignore);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(ignore);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(ignore);} return false;
			case 7: type = 7; if(v(ref_nested())) { return equal(ignore);} return false;
			case 8: type = 8; if(v(ref_nested())) { return equal(ignore);} return false;
			case 9: type = 9; if(v(ref_nested())) { return equal(ignore);} return false;
			case 10: type = 10; if(v(ref_nested())) { return equal(reject);} return false;
			case 11: type = 11; if(v(ref_nested())) { return equal(ignore);} return false;
			case 12: type = 12; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		UE_X2AP_ID& select_id_Old_eNB_UE_X2AP_ID() { return set<UE_X2AP_ID>(1); }
		UE_X2AP_ID const* get_id_Old_eNB_UE_X2AP_ID() const { return get<UE_X2AP_ID>(1); }
		UE_X2AP_ID& select_id_New_eNB_UE_X2AP_ID() { return set<UE_X2AP_ID>(2); }
		UE_X2AP_ID const* get_id_New_eNB_UE_X2AP_ID() const { return get<UE_X2AP_ID>(2); }
		E_RABs_Admitted_List& select_id_E_RABs_Admitted_List() { return set<E_RABs_Admitted_List>(3); }
		E_RABs_Admitted_List const* get_id_E_RABs_Admitted_List() const { return get<E_RABs_Admitted_List>(3); }
		E_RAB_List& select_id_E_RABs_NotAdmitted_List() { return set<E_RAB_List>(4); }
		E_RAB_List const* get_id_E_RABs_NotAdmitted_List() const { return get<E_RAB_List>(4); }
		TargeteNBtoSource_eNBTransparentContainer& select_id_TargeteNBtoSource_eNBTransparentContainer() { return set<TargeteNBtoSource_eNBTransparentContainer>(5); }
		TargeteNBtoSource_eNBTransparentContainer const* get_id_TargeteNBtoSource_eNBTransparentContainer() const { return get<TargeteNBtoSource_eNBTransparentContainer>(5); }
		CriticalityDiagnostics& select_id_CriticalityDiagnostics() { return set<CriticalityDiagnostics>(6); }
		CriticalityDiagnostics const* get_id_CriticalityDiagnostics() const { return get<CriticalityDiagnostics>(6); }
		UE_ContextKeptIndicator& select_id_UE_ContextKeptIndicator() { return set<UE_ContextKeptIndicator>(7); }
		UE_ContextKeptIndicator const* get_id_UE_ContextKeptIndicator() const { return get<UE_ContextKeptIndicator>(7); }
		UE_X2AP_ID_Extension& select_id_SeNB_UE_X2AP_ID_Extension() { return set<UE_X2AP_ID_Extension>(8); }
		UE_X2AP_ID_Extension const* get_id_SeNB_UE_X2AP_ID_Extension() const { return get<UE_X2AP_ID_Extension>(8); }
		UE_X2AP_ID_Extension& select_id_Old_eNB_UE_X2AP_ID_Extension() { return set<UE_X2AP_ID_Extension>(9); }
		UE_X2AP_ID_Extension const* get_id_Old_eNB_UE_X2AP_ID_Extension() const { return get<UE_X2AP_ID_Extension>(9); }
		UE_X2AP_ID_Extension& select_id_New_eNB_UE_X2AP_ID_Extension() { return set<UE_X2AP_ID_Extension>(10); }
		UE_X2AP_ID_Extension const* get_id_New_eNB_UE_X2AP_ID_Extension() const { return get<UE_X2AP_ID_Extension>(10); }
		UE_ContextKeptIndicator& select_id_WT_UE_ContextKeptIndicator() { return set<UE_ContextKeptIndicator>(11); }
		UE_ContextKeptIndicator const* get_id_WT_UE_ContextKeptIndicator() const { return get<UE_ContextKeptIndicator>(11); }
		bool is_unknown() const { return type == 12; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<UE_X2AP_ID>(); break;
			case 2: var.destroy<UE_X2AP_ID>(); break;
			case 3: var.destroy<E_RABs_Admitted_List>(); break;
			case 4: var.destroy<E_RAB_List>(); break;
			case 5: var.destroy<TargeteNBtoSource_eNBTransparentContainer>(); break;
			case 6: var.destroy<CriticalityDiagnostics>(); break;
			case 7: var.destroy<UE_ContextKeptIndicator>(); break;
			case 8: var.destroy<UE_X2AP_ID_Extension>(); break;
			case 9: var.destroy<UE_X2AP_ID_Extension>(); break;
			case 10: var.destroy<UE_X2AP_ID_Extension>(); break;
			case 11: var.destroy<UE_ContextKeptIndicator>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<UE_X2AP_ID>(1);
			v.template operator()<UE_X2AP_ID>(2);
			v.template operator()<E_RABs_Admitted_List>(3);
			v.template operator()<E_RAB_List>(4);
			v.template operator()<TargeteNBtoSource_eNBTransparentContainer>(5);
			v.template operator()<CriticalityDiagnostics>(6);
			v.template operator()<UE_ContextKeptIndicator>(7);
			v.template operator()<UE_X2AP_ID_Extension>(8);
			v.template operator()<UE_X2AP_ID_Extension>(9);
			v.template operator()<UE_X2AP_ID_Extension>(10);
			v.template operator()<UE_ContextKeptIndicator>(11);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_Old_eNB_UE_X2AP_ID()); return true;
			case 2: v(select_id_New_eNB_UE_X2AP_ID()); return true;
			case 3: v(select_id_E_RABs_Admitted_List()); return true;
			case 4: v(select_id_E_RABs_NotAdmitted_List()); return true;
			case 5: v(select_id_TargeteNBtoSource_eNBTransparentContainer()); return true;
			case 6: v(select_id_CriticalityDiagnostics()); return true;
			case 7: v(select_id_UE_ContextKeptIndicator()); return true;
			case 8: v(select_id_SeNB_UE_X2AP_ID_Extension()); return true;
			case 9: v(select_id_Old_eNB_UE_X2AP_ID_Extension()); return true;
			case 10: v(select_id_New_eNB_UE_X2AP_ID_Extension()); return true;
			case 11: v(select_id_WT_UE_ContextKeptIndicator()); return true;
			case 12: if(type != 12) {clear(); asn::base::set();} type = 12; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<UE_X2AP_ID>()); return true;
			case 2: v(var.as<UE_X2AP_ID>()); return true;
			case 3: v(var.as<E_RABs_Admitted_List>()); return true;
			case 4: v(var.as<E_RAB_List>()); return true;
			case 5: v(var.as<TargeteNBtoSource_eNBTransparentContainer>()); return true;
			case 6: v(var.as<CriticalityDiagnostics>()); return true;
			case 7: v(var.as<UE_ContextKeptIndicator>()); return true;
			case 8: v(var.as<UE_X2AP_ID_Extension>()); return true;
			case 9: v(var.as<UE_X2AP_ID_Extension>()); return true;
			case 10: v(var.as<UE_X2AP_ID_Extension>()); return true;
			case 11: v(var.as<UE_ContextKeptIndicator>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(CriticalityDiagnostics)];
			char dummy2[sizeof(E_RAB_List)];
			char dummy3[sizeof(E_RABs_Admitted_List)];
			char dummy4[sizeof(TargeteNBtoSource_eNBTransparentContainer)];
			char dummy5[sizeof(UE_ContextKeptIndicator)];
			char dummy6[sizeof(UE_X2AP_ID)];
			char dummy7[sizeof(UE_X2AP_ID_Extension)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 12; }
		void clear() {type = 0;}
		void select_id_Old_eNB_UE_X2AP_ID() { set(mandatory); type=1;}
		void select_id_New_eNB_UE_X2AP_ID() { set(mandatory); type=2;}
		void select_id_E_RABs_Admitted_List() { set(mandatory); type=3;}
		void select_id_E_RABs_NotAdmitted_List() { set(optional); type=4;}
		void select_id_TargeteNBtoSource_eNBTransparentContainer() { set(mandatory); type=5;}
		void select_id_CriticalityDiagnostics() { set(optional); type=6;}
		void select_id_UE_ContextKeptIndicator() { set(optional); type=7;}
		void select_id_SeNB_UE_X2AP_ID_Extension() { set(optional); type=8;}
		void select_id_Old_eNB_UE_X2AP_ID_Extension() { set(optional); type=9;}
		void select_id_New_eNB_UE_X2AP_ID_Extension() { set(optional); type=10;}
		void select_id_WT_UE_ContextKeptIndicator() { set(optional); type=11;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(mandatory)) { type = 2; return true; }
			else if(equal(mandatory)) { type = 3; return true; }
			else if(equal(optional)) { type = 4; return true; }
			else if(equal(mandatory)) { type = 5; return true; }
			else if(equal(optional)) { type = 6; return true; }
			else if(equal(optional)) { type = 7; return true; }
			else if(equal(optional)) { type = 8; return true; }
			else if(equal(optional)) { type = 9; return true; }
			else if(equal(optional)) { type = 10; return true; }
			else if(equal(optional)) { type = 11; return true; }
			else { type = 12; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(optional);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(optional);} return false;
			case 7: type = 7; if(v(ref_nested())) { return equal(optional);} return false;
			case 8: type = 8; if(v(ref_nested())) { return equal(optional);} return false;
			case 9: type = 9; if(v(ref_nested())) { return equal(optional);} return false;
			case 10: type = 10; if(v(ref_nested())) { return equal(optional);} return false;
			case 11: type = 11; if(v(ref_nested())) { return equal(optional);} return false;
			case 12: type = 12; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
HandoverRequestAcknowledge ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{HandoverRequestAcknowledge-IEs}},
	...
}
*/

struct HandoverRequestAcknowledge : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "HandoverRequestAcknowledge";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<HandoverRequestAcknowledge_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<HandoverRequestAcknowledge_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
LoadInformation-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-CellInformation				CRITICALITY ignore	TYPE CellInformation-List		PRESENCE mandatory} ,
	...
}
*/

struct LoadInformation_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_CellInformation() { set(id_CellInformation); type=1;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_CellInformation)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_CellInformation);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_CellInformation() { set(ignore); type=1;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		CellInformation_List& select_id_CellInformation() { return set<CellInformation_List>(1); }
		CellInformation_List const* get_id_CellInformation() const { return get<CellInformation_List>(1); }
		bool is_unknown() const { return type == 2; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<CellInformation_List>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<CellInformation_List>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_CellInformation()); return true;
			case 2: if(type != 2) {clear(); asn::base::set();} type = 2; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<CellInformation_List>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(CellInformation_List)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_CellInformation() { set(mandatory); type=1;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
LoadInformation ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{LoadInformation-IEs}},
	...
}
*/

struct LoadInformation : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "LoadInformation";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<LoadInformation_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<LoadInformation_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
MeasurementInitiationResult-Item-ExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct MeasurementInitiationResult_Item_ExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
MeasurementInitiationResult-Item ::= SEQUENCE {
	cell-ID											ECGI,
	measurementFailureCause-List					MeasurementFailureCause-List	OPTIONAL,
	iE-Extensions									ProtocolExtensionContainer { {MeasurementInitiationResult-Item-ExtIEs} }	OPTIONAL,
	...
}
*/

struct MeasurementInitiationResult_Item : asn::sequence<3, 0, true, 2>
{
	static constexpr const char* name() {return "MeasurementInitiationResult-Item";}
	using parent_t = asn::sequence<3, 0, true, 2>;
	struct cell_ID_t : ECGI
	{
		static constexpr const char* name() {return "cell_ID_t";}
		using parent_t = ECGI;

	};
	cell_ID_t& ref_cell_ID() {return cell_ID;}
	cell_ID_t const& ref_cell_ID() const {return cell_ID;}
	struct measurementFailureCause_List_t : MeasurementFailureCause_List
	{
		static constexpr const char* name() {return "measurementFailureCause_List_t";}
		using parent_t = MeasurementFailureCause_List;
		static constexpr bool optional = true;

	};
	measurementFailureCause_List_t& set_measurementFailureCause_List() { measurementFailureCause_List.setpresent(true); return measurementFailureCause_List;}
	measurementFailureCause_List_t const* get_measurementFailureCause_List() const {return measurementFailureCause_List.is_valid() ? &measurementFailureCause_List : nullptr;}
	struct iE_Extensions_t : ProtocolExtensionContainer<MeasurementInitiationResult_Item_ExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<MeasurementInitiationResult_Item_ExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(cell_ID);
		v(measurementFailureCause_List);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(cell_ID);
		v(measurementFailureCause_List);
		v(iE_Extensions);

	};
	void clear()
	{
		cell_ID.clear();
		measurementFailureCause_List.clear();
		iE_Extensions.clear();

	};
	private:
	cell_ID_t	cell_ID;
	measurementFailureCause_List_t	measurementFailureCause_List;
	iE_Extensions_t	iE_Extensions;

};
/*
MeasurementInitiationResult-ItemIEs X2AP-PROTOCOL-IES ::= {
	{ ID id-MeasurementInitiationResult-Item	CRITICALITY ignore	TYPE MeasurementInitiationResult-Item	PRESENCE mandatory}
}
*/

struct MeasurementInitiationResult_ItemIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, false>
	{
		size_t get_index() const {return type;}
		void clear() {type = 0;}
		void select_id_MeasurementInitiationResult_Item() { set(id_MeasurementInitiationResult_Item); type=1;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_MeasurementInitiationResult_Item)) { type = 1; return true; }
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_MeasurementInitiationResult_Item);} return false;
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, false>
	{
		size_t get_index() const {return type;}
		void clear() {type = 0;}
		void select_id_MeasurementInitiationResult_Item() { set(ignore); type=1;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<false>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		MeasurementInitiationResult_Item& select_id_MeasurementInitiationResult_Item() { return set<MeasurementInitiationResult_Item>(1); }
		MeasurementInitiationResult_Item const* get_id_MeasurementInitiationResult_Item() const { return get<MeasurementInitiationResult_Item>(1); }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<MeasurementInitiationResult_Item>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<MeasurementInitiationResult_Item>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_MeasurementInitiationResult_Item()); return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<MeasurementInitiationResult_Item>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(MeasurementInitiationResult_Item)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, false>
	{
		size_t get_index() const {return type;}
		void clear() {type = 0;}
		void select_id_MeasurementInitiationResult_Item() { set(mandatory); type=1;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
MeasurementInitiationResult-List ::= SEQUENCE (SIZE (1..maxCellineNB)) OF ProtocolIE-Single-Container { {MeasurementInitiationResult-ItemIEs} }
*/

struct MeasurementInitiationResult_List_elm : ProtocolIE_Single_Container<MeasurementInitiationResult_ItemIEs>
{
	static constexpr const char* name() {return "MeasurementInitiationResult_List_elm";}
	using parent_t = ProtocolIE_Single_Container<MeasurementInitiationResult_ItemIEs>;

};
struct MeasurementInitiationResult_List : asn::sequenceof<MeasurementInitiationResult_List_elm>
{
	static constexpr const char* name() {return "MeasurementInitiationResult-List";}
	using parent_t = asn::sequenceof<MeasurementInitiationResult_List_elm>;
	using constraint_t = asn::constraints<false,asn::span<1,  maxCellineNB >>;

};
/*
MobilityChangeAcknowledge-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-ENB1-Cell-ID			CRITICALITY reject	TYPE ECGI							PRESENCE mandatory}|
	{ ID id-ENB2-Cell-ID			CRITICALITY reject	TYPE ECGI							PRESENCE mandatory}|
	{ ID id-CriticalityDiagnostics	CRITICALITY ignore	TYPE CriticalityDiagnostics			PRESENCE optional},
	...
}
*/

struct MobilityChangeAcknowledge_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 4; }
		void clear() {type = 0;}
		void select_id_ENB1_Cell_ID() { set(id_ENB1_Cell_ID); type=1;}
		void select_id_ENB2_Cell_ID() { set(id_ENB2_Cell_ID); type=2;}
		void select_id_CriticalityDiagnostics() { set(id_CriticalityDiagnostics); type=3;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_ENB1_Cell_ID)) { type = 1; return true; }
			else if(equal(id_ENB2_Cell_ID)) { type = 2; return true; }
			else if(equal(id_CriticalityDiagnostics)) { type = 3; return true; }
			else { type = 4; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_ENB1_Cell_ID);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_ENB2_Cell_ID);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_CriticalityDiagnostics);} return false;
			case 4: type = 4; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 4; }
		void clear() {type = 0;}
		void select_id_ENB1_Cell_ID() { set(reject); type=1;}
		void select_id_ENB2_Cell_ID() { set(reject); type=2;}
		void select_id_CriticalityDiagnostics() { set(ignore); type=3;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else if(equal(reject)) { type = 2; return true; }
			else if(equal(ignore)) { type = 3; return true; }
			else { type = 4; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(reject);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(ignore);} return false;
			case 4: type = 4; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		ECGI& select_id_ENB1_Cell_ID() { return set<ECGI>(1); }
		ECGI const* get_id_ENB1_Cell_ID() const { return get<ECGI>(1); }
		ECGI& select_id_ENB2_Cell_ID() { return set<ECGI>(2); }
		ECGI const* get_id_ENB2_Cell_ID() const { return get<ECGI>(2); }
		CriticalityDiagnostics& select_id_CriticalityDiagnostics() { return set<CriticalityDiagnostics>(3); }
		CriticalityDiagnostics const* get_id_CriticalityDiagnostics() const { return get<CriticalityDiagnostics>(3); }
		bool is_unknown() const { return type == 4; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<ECGI>(); break;
			case 2: var.destroy<ECGI>(); break;
			case 3: var.destroy<CriticalityDiagnostics>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<ECGI>(1);
			v.template operator()<ECGI>(2);
			v.template operator()<CriticalityDiagnostics>(3);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_ENB1_Cell_ID()); return true;
			case 2: v(select_id_ENB2_Cell_ID()); return true;
			case 3: v(select_id_CriticalityDiagnostics()); return true;
			case 4: if(type != 4) {clear(); asn::base::set();} type = 4; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<ECGI>()); return true;
			case 2: v(var.as<ECGI>()); return true;
			case 3: v(var.as<CriticalityDiagnostics>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(CriticalityDiagnostics)];
			char dummy2[sizeof(ECGI)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 4; }
		void clear() {type = 0;}
		void select_id_ENB1_Cell_ID() { set(mandatory); type=1;}
		void select_id_ENB2_Cell_ID() { set(mandatory); type=2;}
		void select_id_CriticalityDiagnostics() { set(optional); type=3;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(mandatory)) { type = 2; return true; }
			else if(equal(optional)) { type = 3; return true; }
			else { type = 4; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(optional);} return false;
			case 4: type = 4; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
MobilityChangeAcknowledge ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{MobilityChangeAcknowledge-IEs}},
	...
}
*/

struct MobilityChangeAcknowledge : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "MobilityChangeAcknowledge";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<MobilityChangeAcknowledge_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<MobilityChangeAcknowledge_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
MobilityChangeFailure-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-ENB1-Cell-ID									CRITICALITY ignore	TYPE ECGI												PRESENCE mandatory}|
	{ ID id-ENB2-Cell-ID									CRITICALITY ignore	TYPE ECGI												PRESENCE mandatory}|
	{ ID id-Cause											CRITICALITY ignore	TYPE Cause												PRESENCE mandatory}|
	{ ID id-ENB2-Mobility-Parameters-Modification-Range		CRITICALITY ignore	TYPE MobilityParametersModificationRange		PRESENCE optional}|
	{ ID id-CriticalityDiagnostics							CRITICALITY ignore	TYPE CriticalityDiagnostics						PRESENCE optional},
	...
}
*/

struct MobilityChangeFailure_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 6; }
		void clear() {type = 0;}
		void select_id_ENB1_Cell_ID() { set(id_ENB1_Cell_ID); type=1;}
		void select_id_ENB2_Cell_ID() { set(id_ENB2_Cell_ID); type=2;}
		void select_id_Cause() { set(id_Cause); type=3;}
		void select_id_ENB2_Mobility_Parameters_Modification_Range() { set(id_ENB2_Mobility_Parameters_Modification_Range); type=4;}
		void select_id_CriticalityDiagnostics() { set(id_CriticalityDiagnostics); type=5;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_ENB1_Cell_ID)) { type = 1; return true; }
			else if(equal(id_ENB2_Cell_ID)) { type = 2; return true; }
			else if(equal(id_Cause)) { type = 3; return true; }
			else if(equal(id_ENB2_Mobility_Parameters_Modification_Range)) { type = 4; return true; }
			else if(equal(id_CriticalityDiagnostics)) { type = 5; return true; }
			else { type = 6; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_ENB1_Cell_ID);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_ENB2_Cell_ID);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_Cause);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(id_ENB2_Mobility_Parameters_Modification_Range);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(id_CriticalityDiagnostics);} return false;
			case 6: type = 6; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 6; }
		void clear() {type = 0;}
		void select_id_ENB1_Cell_ID() { set(ignore); type=1;}
		void select_id_ENB2_Cell_ID() { set(ignore); type=2;}
		void select_id_Cause() { set(ignore); type=3;}
		void select_id_ENB2_Mobility_Parameters_Modification_Range() { set(ignore); type=4;}
		void select_id_CriticalityDiagnostics() { set(ignore); type=5;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else if(equal(ignore)) { type = 2; return true; }
			else if(equal(ignore)) { type = 3; return true; }
			else if(equal(ignore)) { type = 4; return true; }
			else if(equal(ignore)) { type = 5; return true; }
			else { type = 6; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(ignore);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(ignore);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(ignore);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(ignore);} return false;
			case 6: type = 6; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		ECGI& select_id_ENB1_Cell_ID() { return set<ECGI>(1); }
		ECGI const* get_id_ENB1_Cell_ID() const { return get<ECGI>(1); }
		ECGI& select_id_ENB2_Cell_ID() { return set<ECGI>(2); }
		ECGI const* get_id_ENB2_Cell_ID() const { return get<ECGI>(2); }
		Cause& select_id_Cause() { return set<Cause>(3); }
		Cause const* get_id_Cause() const { return get<Cause>(3); }
		MobilityParametersModificationRange& select_id_ENB2_Mobility_Parameters_Modification_Range() { return set<MobilityParametersModificationRange>(4); }
		MobilityParametersModificationRange const* get_id_ENB2_Mobility_Parameters_Modification_Range() const { return get<MobilityParametersModificationRange>(4); }
		CriticalityDiagnostics& select_id_CriticalityDiagnostics() { return set<CriticalityDiagnostics>(5); }
		CriticalityDiagnostics const* get_id_CriticalityDiagnostics() const { return get<CriticalityDiagnostics>(5); }
		bool is_unknown() const { return type == 6; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<ECGI>(); break;
			case 2: var.destroy<ECGI>(); break;
			case 3: var.destroy<Cause>(); break;
			case 4: var.destroy<MobilityParametersModificationRange>(); break;
			case 5: var.destroy<CriticalityDiagnostics>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<ECGI>(1);
			v.template operator()<ECGI>(2);
			v.template operator()<Cause>(3);
			v.template operator()<MobilityParametersModificationRange>(4);
			v.template operator()<CriticalityDiagnostics>(5);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_ENB1_Cell_ID()); return true;
			case 2: v(select_id_ENB2_Cell_ID()); return true;
			case 3: v(select_id_Cause()); return true;
			case 4: v(select_id_ENB2_Mobility_Parameters_Modification_Range()); return true;
			case 5: v(select_id_CriticalityDiagnostics()); return true;
			case 6: if(type != 6) {clear(); asn::base::set();} type = 6; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<ECGI>()); return true;
			case 2: v(var.as<ECGI>()); return true;
			case 3: v(var.as<Cause>()); return true;
			case 4: v(var.as<MobilityParametersModificationRange>()); return true;
			case 5: v(var.as<CriticalityDiagnostics>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(Cause)];
			char dummy2[sizeof(CriticalityDiagnostics)];
			char dummy3[sizeof(ECGI)];
			char dummy4[sizeof(MobilityParametersModificationRange)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 6; }
		void clear() {type = 0;}
		void select_id_ENB1_Cell_ID() { set(mandatory); type=1;}
		void select_id_ENB2_Cell_ID() { set(mandatory); type=2;}
		void select_id_Cause() { set(mandatory); type=3;}
		void select_id_ENB2_Mobility_Parameters_Modification_Range() { set(optional); type=4;}
		void select_id_CriticalityDiagnostics() { set(optional); type=5;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(mandatory)) { type = 2; return true; }
			else if(equal(mandatory)) { type = 3; return true; }
			else if(equal(optional)) { type = 4; return true; }
			else if(equal(optional)) { type = 5; return true; }
			else { type = 6; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(optional);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(optional);} return false;
			case 6: type = 6; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
MobilityChangeFailure ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{MobilityChangeFailure-IEs}},
	...
}
*/

struct MobilityChangeFailure : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "MobilityChangeFailure";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<MobilityChangeFailure_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<MobilityChangeFailure_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
MobilityChangeRequest-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-ENB1-Cell-ID						CRITICALITY reject	TYPE ECGI											PRESENCE mandatory}|
	{ ID id-ENB2-Cell-ID						CRITICALITY reject	TYPE ECGI											PRESENCE mandatory}|
	{ ID id-ENB1-Mobility-Parameters			CRITICALITY ignore	TYPE MobilityParametersInformation				PRESENCE optional}|
	{ ID id-ENB2-Proposed-Mobility-Parameters	CRITICALITY reject	TYPE MobilityParametersInformation				PRESENCE mandatory}|
	{ ID id-Cause								CRITICALITY reject	TYPE Cause											PRESENCE mandatory},
	...
}
*/

struct MobilityChangeRequest_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 6; }
		void clear() {type = 0;}
		void select_id_ENB1_Cell_ID() { set(id_ENB1_Cell_ID); type=1;}
		void select_id_ENB2_Cell_ID() { set(id_ENB2_Cell_ID); type=2;}
		void select_id_ENB1_Mobility_Parameters() { set(id_ENB1_Mobility_Parameters); type=3;}
		void select_id_ENB2_Proposed_Mobility_Parameters() { set(id_ENB2_Proposed_Mobility_Parameters); type=4;}
		void select_id_Cause() { set(id_Cause); type=5;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_ENB1_Cell_ID)) { type = 1; return true; }
			else if(equal(id_ENB2_Cell_ID)) { type = 2; return true; }
			else if(equal(id_ENB1_Mobility_Parameters)) { type = 3; return true; }
			else if(equal(id_ENB2_Proposed_Mobility_Parameters)) { type = 4; return true; }
			else if(equal(id_Cause)) { type = 5; return true; }
			else { type = 6; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_ENB1_Cell_ID);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_ENB2_Cell_ID);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_ENB1_Mobility_Parameters);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(id_ENB2_Proposed_Mobility_Parameters);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(id_Cause);} return false;
			case 6: type = 6; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 6; }
		void clear() {type = 0;}
		void select_id_ENB1_Cell_ID() { set(reject); type=1;}
		void select_id_ENB2_Cell_ID() { set(reject); type=2;}
		void select_id_ENB1_Mobility_Parameters() { set(ignore); type=3;}
		void select_id_ENB2_Proposed_Mobility_Parameters() { set(reject); type=4;}
		void select_id_Cause() { set(reject); type=5;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else if(equal(reject)) { type = 2; return true; }
			else if(equal(ignore)) { type = 3; return true; }
			else if(equal(reject)) { type = 4; return true; }
			else if(equal(reject)) { type = 5; return true; }
			else { type = 6; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(reject);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(ignore);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(reject);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(reject);} return false;
			case 6: type = 6; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		ECGI& select_id_ENB1_Cell_ID() { return set<ECGI>(1); }
		ECGI const* get_id_ENB1_Cell_ID() const { return get<ECGI>(1); }
		ECGI& select_id_ENB2_Cell_ID() { return set<ECGI>(2); }
		ECGI const* get_id_ENB2_Cell_ID() const { return get<ECGI>(2); }
		MobilityParametersInformation& select_id_ENB1_Mobility_Parameters() { return set<MobilityParametersInformation>(3); }
		MobilityParametersInformation const* get_id_ENB1_Mobility_Parameters() const { return get<MobilityParametersInformation>(3); }
		MobilityParametersInformation& select_id_ENB2_Proposed_Mobility_Parameters() { return set<MobilityParametersInformation>(4); }
		MobilityParametersInformation const* get_id_ENB2_Proposed_Mobility_Parameters() const { return get<MobilityParametersInformation>(4); }
		Cause& select_id_Cause() { return set<Cause>(5); }
		Cause const* get_id_Cause() const { return get<Cause>(5); }
		bool is_unknown() const { return type == 6; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<ECGI>(); break;
			case 2: var.destroy<ECGI>(); break;
			case 3: var.destroy<MobilityParametersInformation>(); break;
			case 4: var.destroy<MobilityParametersInformation>(); break;
			case 5: var.destroy<Cause>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<ECGI>(1);
			v.template operator()<ECGI>(2);
			v.template operator()<MobilityParametersInformation>(3);
			v.template operator()<MobilityParametersInformation>(4);
			v.template operator()<Cause>(5);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_ENB1_Cell_ID()); return true;
			case 2: v(select_id_ENB2_Cell_ID()); return true;
			case 3: v(select_id_ENB1_Mobility_Parameters()); return true;
			case 4: v(select_id_ENB2_Proposed_Mobility_Parameters()); return true;
			case 5: v(select_id_Cause()); return true;
			case 6: if(type != 6) {clear(); asn::base::set();} type = 6; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<ECGI>()); return true;
			case 2: v(var.as<ECGI>()); return true;
			case 3: v(var.as<MobilityParametersInformation>()); return true;
			case 4: v(var.as<MobilityParametersInformation>()); return true;
			case 5: v(var.as<Cause>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(Cause)];
			char dummy2[sizeof(ECGI)];
			char dummy3[sizeof(MobilityParametersInformation)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 6; }
		void clear() {type = 0;}
		void select_id_ENB1_Cell_ID() { set(mandatory); type=1;}
		void select_id_ENB2_Cell_ID() { set(mandatory); type=2;}
		void select_id_ENB1_Mobility_Parameters() { set(optional); type=3;}
		void select_id_ENB2_Proposed_Mobility_Parameters() { set(mandatory); type=4;}
		void select_id_Cause() { set(mandatory); type=5;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(mandatory)) { type = 2; return true; }
			else if(equal(optional)) { type = 3; return true; }
			else if(equal(mandatory)) { type = 4; return true; }
			else if(equal(mandatory)) { type = 5; return true; }
			else { type = 6; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(optional);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 6: type = 6; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
MobilityChangeRequest ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{MobilityChangeRequest-IEs}},
	...
}
*/

struct MobilityChangeRequest : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "MobilityChangeRequest";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<MobilityChangeRequest_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<MobilityChangeRequest_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
PartialSuccessIndicator ::= ENUMERATED {
	partial-success-allowed,
...
}
*/

struct PartialSuccessIndicator : asn::enumerated<1, 0, true>
{
	static constexpr const char* name() {return "PartialSuccessIndicator";}
	using parent_t = asn::enumerated<1, 0, true>;
	typedef enum {
		partial_success_allowed
	} index_t;

};

/*
PrivateMessage-IEs X2AP-PRIVATE-IES ::= {
	...
}
*/

struct PrivateMessage_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PRIVATE_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PRIVATE_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PRIVATE_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PRIVATE_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PRIVATE_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PRIVATE_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
PrivateMessage ::= SEQUENCE {
	privateIEs		PrivateIE-Container	{{PrivateMessage-IEs}},
	...
}
*/

struct PrivateMessage : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "PrivateMessage";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct privateIEs_t : PrivateIE_Container<PrivateMessage_IEs>
	{
		static constexpr const char* name() {return "privateIEs_t";}
		using parent_t = PrivateIE_Container<PrivateMessage_IEs>;

	};
	privateIEs_t& ref_privateIEs() {return privateIEs;}
	privateIEs_t const& ref_privateIEs() const {return privateIEs;}
	template<typename V> void decode(V& v)
	{
		v(privateIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(privateIEs);

	};
	void clear()
	{
		privateIEs.clear();

	};
	private:
	privateIEs_t	privateIEs;

};
/*
RLFIndication-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-FailureCellPCI								CRITICALITY ignore	TYPE PCI														PRESENCE mandatory}|
	{ ID id-Re-establishmentCellECGI					CRITICALITY ignore	TYPE ECGI														PRESENCE mandatory}|
	{ ID id-FailureCellCRNTI							CRITICALITY ignore	TYPE CRNTI														PRESENCE mandatory}|
	{ ID id-ShortMAC-I									CRITICALITY ignore	TYPE ShortMAC-I													PRESENCE optional}|
	{ ID id-UE-RLF-Report-Container						CRITICALITY ignore	TYPE UE-RLF-Report-Container								PRESENCE optional}|
	{ ID id-RRCConnSetupIndicator						CRITICALITY reject	TYPE RRCConnSetupIndicator									PRESENCE optional}|
	{ ID id-RRCConnReestabIndicator						CRITICALITY ignore	TYPE RRCConnReestabIndicator								PRESENCE optional}|
	{ ID id-UE-RLF-Report-Container-for-extended-bands	CRITICALITY ignore	TYPE UE-RLF-Report-Container-for-extended-bands		PRESENCE optional},
	...
}
*/

struct RLFIndication_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 9; }
		void clear() {type = 0;}
		void select_id_FailureCellPCI() { set(id_FailureCellPCI); type=1;}
		void select_id_Re_establishmentCellECGI() { set(id_Re_establishmentCellECGI); type=2;}
		void select_id_FailureCellCRNTI() { set(id_FailureCellCRNTI); type=3;}
		void select_id_ShortMAC_I() { set(id_ShortMAC_I); type=4;}
		void select_id_UE_RLF_Report_Container() { set(id_UE_RLF_Report_Container); type=5;}
		void select_id_RRCConnSetupIndicator() { set(id_RRCConnSetupIndicator); type=6;}
		void select_id_RRCConnReestabIndicator() { set(id_RRCConnReestabIndicator); type=7;}
		void select_id_UE_RLF_Report_Container_for_extended_bands() { set(id_UE_RLF_Report_Container_for_extended_bands); type=8;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_FailureCellPCI)) { type = 1; return true; }
			else if(equal(id_Re_establishmentCellECGI)) { type = 2; return true; }
			else if(equal(id_FailureCellCRNTI)) { type = 3; return true; }
			else if(equal(id_ShortMAC_I)) { type = 4; return true; }
			else if(equal(id_UE_RLF_Report_Container)) { type = 5; return true; }
			else if(equal(id_RRCConnSetupIndicator)) { type = 6; return true; }
			else if(equal(id_RRCConnReestabIndicator)) { type = 7; return true; }
			else if(equal(id_UE_RLF_Report_Container_for_extended_bands)) { type = 8; return true; }
			else { type = 9; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_FailureCellPCI);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_Re_establishmentCellECGI);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_FailureCellCRNTI);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(id_ShortMAC_I);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(id_UE_RLF_Report_Container);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(id_RRCConnSetupIndicator);} return false;
			case 7: type = 7; if(v(ref_nested())) { return equal(id_RRCConnReestabIndicator);} return false;
			case 8: type = 8; if(v(ref_nested())) { return equal(id_UE_RLF_Report_Container_for_extended_bands);} return false;
			case 9: type = 9; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 9; }
		void clear() {type = 0;}
		void select_id_FailureCellPCI() { set(ignore); type=1;}
		void select_id_Re_establishmentCellECGI() { set(ignore); type=2;}
		void select_id_FailureCellCRNTI() { set(ignore); type=3;}
		void select_id_ShortMAC_I() { set(ignore); type=4;}
		void select_id_UE_RLF_Report_Container() { set(ignore); type=5;}
		void select_id_RRCConnSetupIndicator() { set(reject); type=6;}
		void select_id_RRCConnReestabIndicator() { set(ignore); type=7;}
		void select_id_UE_RLF_Report_Container_for_extended_bands() { set(ignore); type=8;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else if(equal(ignore)) { type = 2; return true; }
			else if(equal(ignore)) { type = 3; return true; }
			else if(equal(ignore)) { type = 4; return true; }
			else if(equal(ignore)) { type = 5; return true; }
			else if(equal(reject)) { type = 6; return true; }
			else if(equal(ignore)) { type = 7; return true; }
			else if(equal(ignore)) { type = 8; return true; }
			else { type = 9; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(ignore);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(ignore);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(ignore);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(ignore);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(reject);} return false;
			case 7: type = 7; if(v(ref_nested())) { return equal(ignore);} return false;
			case 8: type = 8; if(v(ref_nested())) { return equal(ignore);} return false;
			case 9: type = 9; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		PCI& select_id_FailureCellPCI() { return set<PCI>(1); }
		PCI const* get_id_FailureCellPCI() const { return get<PCI>(1); }
		ECGI& select_id_Re_establishmentCellECGI() { return set<ECGI>(2); }
		ECGI const* get_id_Re_establishmentCellECGI() const { return get<ECGI>(2); }
		CRNTI& select_id_FailureCellCRNTI() { return set<CRNTI>(3); }
		CRNTI const* get_id_FailureCellCRNTI() const { return get<CRNTI>(3); }
		ShortMAC_I& select_id_ShortMAC_I() { return set<ShortMAC_I>(4); }
		ShortMAC_I const* get_id_ShortMAC_I() const { return get<ShortMAC_I>(4); }
		UE_RLF_Report_Container& select_id_UE_RLF_Report_Container() { return set<UE_RLF_Report_Container>(5); }
		UE_RLF_Report_Container const* get_id_UE_RLF_Report_Container() const { return get<UE_RLF_Report_Container>(5); }
		RRCConnSetupIndicator& select_id_RRCConnSetupIndicator() { return set<RRCConnSetupIndicator>(6); }
		RRCConnSetupIndicator const* get_id_RRCConnSetupIndicator() const { return get<RRCConnSetupIndicator>(6); }
		RRCConnReestabIndicator& select_id_RRCConnReestabIndicator() { return set<RRCConnReestabIndicator>(7); }
		RRCConnReestabIndicator const* get_id_RRCConnReestabIndicator() const { return get<RRCConnReestabIndicator>(7); }
		UE_RLF_Report_Container_for_extended_bands& select_id_UE_RLF_Report_Container_for_extended_bands() { return set<UE_RLF_Report_Container_for_extended_bands>(8); }
		UE_RLF_Report_Container_for_extended_bands const* get_id_UE_RLF_Report_Container_for_extended_bands() const { return get<UE_RLF_Report_Container_for_extended_bands>(8); }
		bool is_unknown() const { return type == 9; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<PCI>(); break;
			case 2: var.destroy<ECGI>(); break;
			case 3: var.destroy<CRNTI>(); break;
			case 4: var.destroy<ShortMAC_I>(); break;
			case 5: var.destroy<UE_RLF_Report_Container>(); break;
			case 6: var.destroy<RRCConnSetupIndicator>(); break;
			case 7: var.destroy<RRCConnReestabIndicator>(); break;
			case 8: var.destroy<UE_RLF_Report_Container_for_extended_bands>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<PCI>(1);
			v.template operator()<ECGI>(2);
			v.template operator()<CRNTI>(3);
			v.template operator()<ShortMAC_I>(4);
			v.template operator()<UE_RLF_Report_Container>(5);
			v.template operator()<RRCConnSetupIndicator>(6);
			v.template operator()<RRCConnReestabIndicator>(7);
			v.template operator()<UE_RLF_Report_Container_for_extended_bands>(8);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_FailureCellPCI()); return true;
			case 2: v(select_id_Re_establishmentCellECGI()); return true;
			case 3: v(select_id_FailureCellCRNTI()); return true;
			case 4: v(select_id_ShortMAC_I()); return true;
			case 5: v(select_id_UE_RLF_Report_Container()); return true;
			case 6: v(select_id_RRCConnSetupIndicator()); return true;
			case 7: v(select_id_RRCConnReestabIndicator()); return true;
			case 8: v(select_id_UE_RLF_Report_Container_for_extended_bands()); return true;
			case 9: if(type != 9) {clear(); asn::base::set();} type = 9; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<PCI>()); return true;
			case 2: v(var.as<ECGI>()); return true;
			case 3: v(var.as<CRNTI>()); return true;
			case 4: v(var.as<ShortMAC_I>()); return true;
			case 5: v(var.as<UE_RLF_Report_Container>()); return true;
			case 6: v(var.as<RRCConnSetupIndicator>()); return true;
			case 7: v(var.as<RRCConnReestabIndicator>()); return true;
			case 8: v(var.as<UE_RLF_Report_Container_for_extended_bands>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(CRNTI)];
			char dummy2[sizeof(ECGI)];
			char dummy3[sizeof(PCI)];
			char dummy4[sizeof(RRCConnReestabIndicator)];
			char dummy5[sizeof(RRCConnSetupIndicator)];
			char dummy6[sizeof(ShortMAC_I)];
			char dummy7[sizeof(UE_RLF_Report_Container)];
			char dummy8[sizeof(UE_RLF_Report_Container_for_extended_bands)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 9; }
		void clear() {type = 0;}
		void select_id_FailureCellPCI() { set(mandatory); type=1;}
		void select_id_Re_establishmentCellECGI() { set(mandatory); type=2;}
		void select_id_FailureCellCRNTI() { set(mandatory); type=3;}
		void select_id_ShortMAC_I() { set(optional); type=4;}
		void select_id_UE_RLF_Report_Container() { set(optional); type=5;}
		void select_id_RRCConnSetupIndicator() { set(optional); type=6;}
		void select_id_RRCConnReestabIndicator() { set(optional); type=7;}
		void select_id_UE_RLF_Report_Container_for_extended_bands() { set(optional); type=8;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(mandatory)) { type = 2; return true; }
			else if(equal(mandatory)) { type = 3; return true; }
			else if(equal(optional)) { type = 4; return true; }
			else if(equal(optional)) { type = 5; return true; }
			else if(equal(optional)) { type = 6; return true; }
			else if(equal(optional)) { type = 7; return true; }
			else if(equal(optional)) { type = 8; return true; }
			else { type = 9; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(optional);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(optional);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(optional);} return false;
			case 7: type = 7; if(v(ref_nested())) { return equal(optional);} return false;
			case 8: type = 8; if(v(ref_nested())) { return equal(optional);} return false;
			case 9: type = 9; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
RLFIndication ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{RLFIndication-IEs}},
	...
}
*/

struct RLFIndication : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "RLFIndication";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<RLFIndication_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<RLFIndication_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
RNL-Header-Item-ExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct RNL_Header_Item_ExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
RNL-Header ::= SEQUENCE {
	source-GlobalENB-ID	GlobalENB-ID,
	target-GlobalENB-ID	GlobalENB-ID	OPTIONAL,
	iE-Extensions						ProtocolExtensionContainer { {RNL-Header-Item-ExtIEs} } OPTIONAL,
	...
}
*/

struct RNL_Header : asn::sequence<3, 0, true, 2>
{
	static constexpr const char* name() {return "RNL-Header";}
	using parent_t = asn::sequence<3, 0, true, 2>;
	struct source_GlobalENB_ID_t : GlobalENB_ID
	{
		static constexpr const char* name() {return "source_GlobalENB_ID_t";}
		using parent_t = GlobalENB_ID;

	};
	source_GlobalENB_ID_t& ref_source_GlobalENB_ID() {return source_GlobalENB_ID;}
	source_GlobalENB_ID_t const& ref_source_GlobalENB_ID() const {return source_GlobalENB_ID;}
	struct target_GlobalENB_ID_t : GlobalENB_ID
	{
		static constexpr const char* name() {return "target_GlobalENB_ID_t";}
		using parent_t = GlobalENB_ID;
		static constexpr bool optional = true;

	};
	target_GlobalENB_ID_t& set_target_GlobalENB_ID() { target_GlobalENB_ID.setpresent(true); return target_GlobalENB_ID;}
	target_GlobalENB_ID_t const* get_target_GlobalENB_ID() const {return target_GlobalENB_ID.is_valid() ? &target_GlobalENB_ID : nullptr;}
	struct iE_Extensions_t : ProtocolExtensionContainer<RNL_Header_Item_ExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<RNL_Header_Item_ExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(source_GlobalENB_ID);
		v(target_GlobalENB_ID);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(source_GlobalENB_ID);
		v(target_GlobalENB_ID);
		v(iE_Extensions);

	};
	void clear()
	{
		source_GlobalENB_ID.clear();
		target_GlobalENB_ID.clear();
		iE_Extensions.clear();

	};
	private:
	source_GlobalENB_ID_t	source_GlobalENB_ID;
	target_GlobalENB_ID_t	target_GlobalENB_ID;
	iE_Extensions_t	iE_Extensions;

};
/*
RRCTransfer-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-MeNB-UE-X2AP-ID						CRITICALITY reject	TYPE UE-X2AP-ID					PRESENCE mandatory}|
	{ ID id-SgNB-UE-X2AP-ID						CRITICALITY reject	TYPE SgNB-UE-X2AP-ID				PRESENCE mandatory}|
	{ ID id-SplitSRB								CRITICALITY reject	TYPE SplitSRB					PRESENCE optional}|
	{ ID id-UENRMeasurement						CRITICALITY reject	TYPE UENRMeasurement				PRESENCE optional}|
	{ ID id-MeNB-UE-X2AP-ID-Extension			CRITICALITY reject	TYPE UE-X2AP-ID-Extension		PRESENCE optional},
	...
}
*/

struct RRCTransfer_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 6; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(id_MeNB_UE_X2AP_ID); type=1;}
		void select_id_SgNB_UE_X2AP_ID() { set(id_SgNB_UE_X2AP_ID); type=2;}
		void select_id_SplitSRB() { set(id_SplitSRB); type=3;}
		void select_id_UENRMeasurement() { set(id_UENRMeasurement); type=4;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(id_MeNB_UE_X2AP_ID_Extension); type=5;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_MeNB_UE_X2AP_ID)) { type = 1; return true; }
			else if(equal(id_SgNB_UE_X2AP_ID)) { type = 2; return true; }
			else if(equal(id_SplitSRB)) { type = 3; return true; }
			else if(equal(id_UENRMeasurement)) { type = 4; return true; }
			else if(equal(id_MeNB_UE_X2AP_ID_Extension)) { type = 5; return true; }
			else { type = 6; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_SgNB_UE_X2AP_ID);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_SplitSRB);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(id_UENRMeasurement);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID_Extension);} return false;
			case 6: type = 6; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 6; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(reject); type=1;}
		void select_id_SgNB_UE_X2AP_ID() { set(reject); type=2;}
		void select_id_SplitSRB() { set(reject); type=3;}
		void select_id_UENRMeasurement() { set(reject); type=4;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(reject); type=5;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else if(equal(reject)) { type = 2; return true; }
			else if(equal(reject)) { type = 3; return true; }
			else if(equal(reject)) { type = 4; return true; }
			else if(equal(reject)) { type = 5; return true; }
			else { type = 6; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(reject);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(reject);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(reject);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(reject);} return false;
			case 6: type = 6; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		UE_X2AP_ID& select_id_MeNB_UE_X2AP_ID() { return set<UE_X2AP_ID>(1); }
		UE_X2AP_ID const* get_id_MeNB_UE_X2AP_ID() const { return get<UE_X2AP_ID>(1); }
		SgNB_UE_X2AP_ID& select_id_SgNB_UE_X2AP_ID() { return set<SgNB_UE_X2AP_ID>(2); }
		SgNB_UE_X2AP_ID const* get_id_SgNB_UE_X2AP_ID() const { return get<SgNB_UE_X2AP_ID>(2); }
		SplitSRB& select_id_SplitSRB() { return set<SplitSRB>(3); }
		SplitSRB const* get_id_SplitSRB() const { return get<SplitSRB>(3); }
		UENRMeasurement& select_id_UENRMeasurement() { return set<UENRMeasurement>(4); }
		UENRMeasurement const* get_id_UENRMeasurement() const { return get<UENRMeasurement>(4); }
		UE_X2AP_ID_Extension& select_id_MeNB_UE_X2AP_ID_Extension() { return set<UE_X2AP_ID_Extension>(5); }
		UE_X2AP_ID_Extension const* get_id_MeNB_UE_X2AP_ID_Extension() const { return get<UE_X2AP_ID_Extension>(5); }
		bool is_unknown() const { return type == 6; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<UE_X2AP_ID>(); break;
			case 2: var.destroy<SgNB_UE_X2AP_ID>(); break;
			case 3: var.destroy<SplitSRB>(); break;
			case 4: var.destroy<UENRMeasurement>(); break;
			case 5: var.destroy<UE_X2AP_ID_Extension>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<UE_X2AP_ID>(1);
			v.template operator()<SgNB_UE_X2AP_ID>(2);
			v.template operator()<SplitSRB>(3);
			v.template operator()<UENRMeasurement>(4);
			v.template operator()<UE_X2AP_ID_Extension>(5);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_MeNB_UE_X2AP_ID()); return true;
			case 2: v(select_id_SgNB_UE_X2AP_ID()); return true;
			case 3: v(select_id_SplitSRB()); return true;
			case 4: v(select_id_UENRMeasurement()); return true;
			case 5: v(select_id_MeNB_UE_X2AP_ID_Extension()); return true;
			case 6: if(type != 6) {clear(); asn::base::set();} type = 6; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<UE_X2AP_ID>()); return true;
			case 2: v(var.as<SgNB_UE_X2AP_ID>()); return true;
			case 3: v(var.as<SplitSRB>()); return true;
			case 4: v(var.as<UENRMeasurement>()); return true;
			case 5: v(var.as<UE_X2AP_ID_Extension>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(SgNB_UE_X2AP_ID)];
			char dummy2[sizeof(SplitSRB)];
			char dummy3[sizeof(UENRMeasurement)];
			char dummy4[sizeof(UE_X2AP_ID)];
			char dummy5[sizeof(UE_X2AP_ID_Extension)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 6; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(mandatory); type=1;}
		void select_id_SgNB_UE_X2AP_ID() { set(mandatory); type=2;}
		void select_id_SplitSRB() { set(optional); type=3;}
		void select_id_UENRMeasurement() { set(optional); type=4;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(optional); type=5;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(mandatory)) { type = 2; return true; }
			else if(equal(optional)) { type = 3; return true; }
			else if(equal(optional)) { type = 4; return true; }
			else if(equal(optional)) { type = 5; return true; }
			else { type = 6; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(optional);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(optional);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(optional);} return false;
			case 6: type = 6; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
RRCTransfer ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container		{{RRCTransfer-IEs}},
	...
}
*/

struct RRCTransfer : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "RRCTransfer";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<RRCTransfer_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<RRCTransfer_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
ReportingPeriodicity ::= ENUMERATED {
	one-thousand-ms,
	two-thousand-ms,
	five-thousand-ms,
	ten-thousand-ms,
...
}
*/

struct ReportingPeriodicity : asn::enumerated<4, 0, true>
{
	static constexpr const char* name() {return "ReportingPeriodicity";}
	using parent_t = asn::enumerated<4, 0, true>;
	typedef enum {
		one_thousand_ms
		,two_thousand_ms
		,five_thousand_ms
		,ten_thousand_ms
	} index_t;

};

/*
ResetRequest-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-Cause				CRITICALITY ignore	TYPE Cause				PRESENCE mandatory},
	...
}
*/

struct ResetRequest_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_Cause() { set(id_Cause); type=1;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_Cause)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_Cause);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_Cause() { set(ignore); type=1;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		Cause& select_id_Cause() { return set<Cause>(1); }
		Cause const* get_id_Cause() const { return get<Cause>(1); }
		bool is_unknown() const { return type == 2; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<Cause>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<Cause>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_Cause()); return true;
			case 2: if(type != 2) {clear(); asn::base::set();} type = 2; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<Cause>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(Cause)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_Cause() { set(mandatory); type=1;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
ResetRequest ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{ResetRequest-IEs}},
	...
}
*/

struct ResetRequest : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "ResetRequest";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<ResetRequest_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<ResetRequest_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
ResetResponse-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-CriticalityDiagnostics	CRITICALITY ignore	TYPE CriticalityDiagnostics			PRESENCE optional },
	...
}
*/

struct ResetResponse_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_CriticalityDiagnostics() { set(id_CriticalityDiagnostics); type=1;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_CriticalityDiagnostics)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_CriticalityDiagnostics);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_CriticalityDiagnostics() { set(ignore); type=1;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		CriticalityDiagnostics& select_id_CriticalityDiagnostics() { return set<CriticalityDiagnostics>(1); }
		CriticalityDiagnostics const* get_id_CriticalityDiagnostics() const { return get<CriticalityDiagnostics>(1); }
		bool is_unknown() const { return type == 2; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<CriticalityDiagnostics>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<CriticalityDiagnostics>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_CriticalityDiagnostics()); return true;
			case 2: if(type != 2) {clear(); asn::base::set();} type = 2; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<CriticalityDiagnostics>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(CriticalityDiagnostics)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_CriticalityDiagnostics() { set(optional); type=1;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(optional)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(optional);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
ResetResponse ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{ResetResponse-IEs}},
	...
}
*/

struct ResetResponse : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "ResetResponse";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<ResetResponse_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<ResetResponse_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
ResourceStatusFailure-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-ENB1-Measurement-ID						CRITICALITY reject	TYPE Measurement-ID									PRESENCE mandatory}|
	{ ID id-ENB2-Measurement-ID						CRITICALITY reject	TYPE Measurement-ID									PRESENCE mandatory}|
	{ ID id-Cause									CRITICALITY ignore	TYPE Cause											PRESENCE mandatory}|
	{ ID id-CriticalityDiagnostics					CRITICALITY ignore	TYPE CriticalityDiagnostics						PRESENCE optional}|
	{ ID id-CompleteFailureCauseInformation-List	CRITICALITY ignore	TYPE CompleteFailureCauseInformation-List	PRESENCE optional},
	...
}
*/

struct ResourceStatusFailure_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 6; }
		void clear() {type = 0;}
		void select_id_ENB1_Measurement_ID() { set(id_ENB1_Measurement_ID); type=1;}
		void select_id_ENB2_Measurement_ID() { set(id_ENB2_Measurement_ID); type=2;}
		void select_id_Cause() { set(id_Cause); type=3;}
		void select_id_CriticalityDiagnostics() { set(id_CriticalityDiagnostics); type=4;}
		void select_id_CompleteFailureCauseInformation_List() { set(id_CompleteFailureCauseInformation_List); type=5;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_ENB1_Measurement_ID)) { type = 1; return true; }
			else if(equal(id_ENB2_Measurement_ID)) { type = 2; return true; }
			else if(equal(id_Cause)) { type = 3; return true; }
			else if(equal(id_CriticalityDiagnostics)) { type = 4; return true; }
			else if(equal(id_CompleteFailureCauseInformation_List)) { type = 5; return true; }
			else { type = 6; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_ENB1_Measurement_ID);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_ENB2_Measurement_ID);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_Cause);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(id_CriticalityDiagnostics);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(id_CompleteFailureCauseInformation_List);} return false;
			case 6: type = 6; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 6; }
		void clear() {type = 0;}
		void select_id_ENB1_Measurement_ID() { set(reject); type=1;}
		void select_id_ENB2_Measurement_ID() { set(reject); type=2;}
		void select_id_Cause() { set(ignore); type=3;}
		void select_id_CriticalityDiagnostics() { set(ignore); type=4;}
		void select_id_CompleteFailureCauseInformation_List() { set(ignore); type=5;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else if(equal(reject)) { type = 2; return true; }
			else if(equal(ignore)) { type = 3; return true; }
			else if(equal(ignore)) { type = 4; return true; }
			else if(equal(ignore)) { type = 5; return true; }
			else { type = 6; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(reject);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(ignore);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(ignore);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(ignore);} return false;
			case 6: type = 6; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		Measurement_ID& select_id_ENB1_Measurement_ID() { return set<Measurement_ID>(1); }
		Measurement_ID const* get_id_ENB1_Measurement_ID() const { return get<Measurement_ID>(1); }
		Measurement_ID& select_id_ENB2_Measurement_ID() { return set<Measurement_ID>(2); }
		Measurement_ID const* get_id_ENB2_Measurement_ID() const { return get<Measurement_ID>(2); }
		Cause& select_id_Cause() { return set<Cause>(3); }
		Cause const* get_id_Cause() const { return get<Cause>(3); }
		CriticalityDiagnostics& select_id_CriticalityDiagnostics() { return set<CriticalityDiagnostics>(4); }
		CriticalityDiagnostics const* get_id_CriticalityDiagnostics() const { return get<CriticalityDiagnostics>(4); }
		CompleteFailureCauseInformation_List& select_id_CompleteFailureCauseInformation_List() { return set<CompleteFailureCauseInformation_List>(5); }
		CompleteFailureCauseInformation_List const* get_id_CompleteFailureCauseInformation_List() const { return get<CompleteFailureCauseInformation_List>(5); }
		bool is_unknown() const { return type == 6; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<Measurement_ID>(); break;
			case 2: var.destroy<Measurement_ID>(); break;
			case 3: var.destroy<Cause>(); break;
			case 4: var.destroy<CriticalityDiagnostics>(); break;
			case 5: var.destroy<CompleteFailureCauseInformation_List>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<Measurement_ID>(1);
			v.template operator()<Measurement_ID>(2);
			v.template operator()<Cause>(3);
			v.template operator()<CriticalityDiagnostics>(4);
			v.template operator()<CompleteFailureCauseInformation_List>(5);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_ENB1_Measurement_ID()); return true;
			case 2: v(select_id_ENB2_Measurement_ID()); return true;
			case 3: v(select_id_Cause()); return true;
			case 4: v(select_id_CriticalityDiagnostics()); return true;
			case 5: v(select_id_CompleteFailureCauseInformation_List()); return true;
			case 6: if(type != 6) {clear(); asn::base::set();} type = 6; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<Measurement_ID>()); return true;
			case 2: v(var.as<Measurement_ID>()); return true;
			case 3: v(var.as<Cause>()); return true;
			case 4: v(var.as<CriticalityDiagnostics>()); return true;
			case 5: v(var.as<CompleteFailureCauseInformation_List>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(Cause)];
			char dummy2[sizeof(CompleteFailureCauseInformation_List)];
			char dummy3[sizeof(CriticalityDiagnostics)];
			char dummy4[sizeof(Measurement_ID)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 6; }
		void clear() {type = 0;}
		void select_id_ENB1_Measurement_ID() { set(mandatory); type=1;}
		void select_id_ENB2_Measurement_ID() { set(mandatory); type=2;}
		void select_id_Cause() { set(mandatory); type=3;}
		void select_id_CriticalityDiagnostics() { set(optional); type=4;}
		void select_id_CompleteFailureCauseInformation_List() { set(optional); type=5;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(mandatory)) { type = 2; return true; }
			else if(equal(mandatory)) { type = 3; return true; }
			else if(equal(optional)) { type = 4; return true; }
			else if(equal(optional)) { type = 5; return true; }
			else { type = 6; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(optional);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(optional);} return false;
			case 6: type = 6; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
ResourceStatusFailure ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{ResourceStatusFailure-IEs}},
	...
}
*/

struct ResourceStatusFailure : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "ResourceStatusFailure";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<ResourceStatusFailure_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<ResourceStatusFailure_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
ResourceStatusRequest-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-ENB1-Measurement-ID			CRITICALITY reject	TYPE Measurement-ID					PRESENCE mandatory}|
	{ ID id-ENB2-Measurement-ID			CRITICALITY ignore	TYPE Measurement-ID					PRESENCE conditional}|-- The IE shall be present if the Registration Request IE is set to Stop, Partial stop or to Add--
	{ ID id-Registration-Request		CRITICALITY reject	TYPE Registration-Request			PRESENCE mandatory}|
	{ ID id-ReportCharacteristics		CRITICALITY reject	TYPE ReportCharacteristics			PRESENCE optional}|
	{ ID id-CellToReport				CRITICALITY ignore	TYPE CellToReport-List				PRESENCE mandatory}|
	{ ID id-ReportingPeriodicity		CRITICALITY ignore	TYPE ReportingPeriodicity			PRESENCE optional}|
	{ ID id-PartialSuccessIndicator		CRITICALITY ignore	TYPE PartialSuccessIndicator		PRESENCE optional}|
	{ ID id-ReportingPeriodicityRSRPMR	CRITICALITY ignore	TYPE ReportingPeriodicityRSRPMR		PRESENCE optional}|
	{ ID id-ReportingPeriodicityCSIR	CRITICALITY ignore	TYPE ReportingPeriodicityCSIR		PRESENCE optional},
	...
}
*/

struct ResourceStatusRequest_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 10; }
		void clear() {type = 0;}
		void select_id_ENB1_Measurement_ID() { set(id_ENB1_Measurement_ID); type=1;}
		void select_id_ENB2_Measurement_ID() { set(id_ENB2_Measurement_ID); type=2;}
		void select_id_Registration_Request() { set(id_Registration_Request); type=3;}
		void select_id_ReportCharacteristics() { set(id_ReportCharacteristics); type=4;}
		void select_id_CellToReport() { set(id_CellToReport); type=5;}
		void select_id_ReportingPeriodicity() { set(id_ReportingPeriodicity); type=6;}
		void select_id_PartialSuccessIndicator() { set(id_PartialSuccessIndicator); type=7;}
		void select_id_ReportingPeriodicityRSRPMR() { set(id_ReportingPeriodicityRSRPMR); type=8;}
		void select_id_ReportingPeriodicityCSIR() { set(id_ReportingPeriodicityCSIR); type=9;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_ENB1_Measurement_ID)) { type = 1; return true; }
			else if(equal(id_ENB2_Measurement_ID)) { type = 2; return true; }
			else if(equal(id_Registration_Request)) { type = 3; return true; }
			else if(equal(id_ReportCharacteristics)) { type = 4; return true; }
			else if(equal(id_CellToReport)) { type = 5; return true; }
			else if(equal(id_ReportingPeriodicity)) { type = 6; return true; }
			else if(equal(id_PartialSuccessIndicator)) { type = 7; return true; }
			else if(equal(id_ReportingPeriodicityRSRPMR)) { type = 8; return true; }
			else if(equal(id_ReportingPeriodicityCSIR)) { type = 9; return true; }
			else { type = 10; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_ENB1_Measurement_ID);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_ENB2_Measurement_ID);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_Registration_Request);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(id_ReportCharacteristics);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(id_CellToReport);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(id_ReportingPeriodicity);} return false;
			case 7: type = 7; if(v(ref_nested())) { return equal(id_PartialSuccessIndicator);} return false;
			case 8: type = 8; if(v(ref_nested())) { return equal(id_ReportingPeriodicityRSRPMR);} return false;
			case 9: type = 9; if(v(ref_nested())) { return equal(id_ReportingPeriodicityCSIR);} return false;
			case 10: type = 10; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 10; }
		void clear() {type = 0;}
		void select_id_ENB1_Measurement_ID() { set(reject); type=1;}
		void select_id_ENB2_Measurement_ID() { set(ignore); type=2;}
		void select_id_Registration_Request() { set(reject); type=3;}
		void select_id_ReportCharacteristics() { set(reject); type=4;}
		void select_id_CellToReport() { set(ignore); type=5;}
		void select_id_ReportingPeriodicity() { set(ignore); type=6;}
		void select_id_PartialSuccessIndicator() { set(ignore); type=7;}
		void select_id_ReportingPeriodicityRSRPMR() { set(ignore); type=8;}
		void select_id_ReportingPeriodicityCSIR() { set(ignore); type=9;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else if(equal(ignore)) { type = 2; return true; }
			else if(equal(reject)) { type = 3; return true; }
			else if(equal(reject)) { type = 4; return true; }
			else if(equal(ignore)) { type = 5; return true; }
			else if(equal(ignore)) { type = 6; return true; }
			else if(equal(ignore)) { type = 7; return true; }
			else if(equal(ignore)) { type = 8; return true; }
			else if(equal(ignore)) { type = 9; return true; }
			else { type = 10; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(ignore);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(reject);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(reject);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(ignore);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(ignore);} return false;
			case 7: type = 7; if(v(ref_nested())) { return equal(ignore);} return false;
			case 8: type = 8; if(v(ref_nested())) { return equal(ignore);} return false;
			case 9: type = 9; if(v(ref_nested())) { return equal(ignore);} return false;
			case 10: type = 10; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		Measurement_ID& select_id_ENB1_Measurement_ID() { return set<Measurement_ID>(1); }
		Measurement_ID const* get_id_ENB1_Measurement_ID() const { return get<Measurement_ID>(1); }
		Measurement_ID& select_id_ENB2_Measurement_ID() { return set<Measurement_ID>(2); }
		Measurement_ID const* get_id_ENB2_Measurement_ID() const { return get<Measurement_ID>(2); }
		Registration_Request& select_id_Registration_Request() { return set<Registration_Request>(3); }
		Registration_Request const* get_id_Registration_Request() const { return get<Registration_Request>(3); }
		ReportCharacteristics& select_id_ReportCharacteristics() { return set<ReportCharacteristics>(4); }
		ReportCharacteristics const* get_id_ReportCharacteristics() const { return get<ReportCharacteristics>(4); }
		CellToReport_List& select_id_CellToReport() { return set<CellToReport_List>(5); }
		CellToReport_List const* get_id_CellToReport() const { return get<CellToReport_List>(5); }
		ReportingPeriodicity& select_id_ReportingPeriodicity() { return set<ReportingPeriodicity>(6); }
		ReportingPeriodicity const* get_id_ReportingPeriodicity() const { return get<ReportingPeriodicity>(6); }
		PartialSuccessIndicator& select_id_PartialSuccessIndicator() { return set<PartialSuccessIndicator>(7); }
		PartialSuccessIndicator const* get_id_PartialSuccessIndicator() const { return get<PartialSuccessIndicator>(7); }
		ReportingPeriodicityRSRPMR& select_id_ReportingPeriodicityRSRPMR() { return set<ReportingPeriodicityRSRPMR>(8); }
		ReportingPeriodicityRSRPMR const* get_id_ReportingPeriodicityRSRPMR() const { return get<ReportingPeriodicityRSRPMR>(8); }
		ReportingPeriodicityCSIR& select_id_ReportingPeriodicityCSIR() { return set<ReportingPeriodicityCSIR>(9); }
		ReportingPeriodicityCSIR const* get_id_ReportingPeriodicityCSIR() const { return get<ReportingPeriodicityCSIR>(9); }
		bool is_unknown() const { return type == 10; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<Measurement_ID>(); break;
			case 2: var.destroy<Measurement_ID>(); break;
			case 3: var.destroy<Registration_Request>(); break;
			case 4: var.destroy<ReportCharacteristics>(); break;
			case 5: var.destroy<CellToReport_List>(); break;
			case 6: var.destroy<ReportingPeriodicity>(); break;
			case 7: var.destroy<PartialSuccessIndicator>(); break;
			case 8: var.destroy<ReportingPeriodicityRSRPMR>(); break;
			case 9: var.destroy<ReportingPeriodicityCSIR>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<Measurement_ID>(1);
			v.template operator()<Measurement_ID>(2);
			v.template operator()<Registration_Request>(3);
			v.template operator()<ReportCharacteristics>(4);
			v.template operator()<CellToReport_List>(5);
			v.template operator()<ReportingPeriodicity>(6);
			v.template operator()<PartialSuccessIndicator>(7);
			v.template operator()<ReportingPeriodicityRSRPMR>(8);
			v.template operator()<ReportingPeriodicityCSIR>(9);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_ENB1_Measurement_ID()); return true;
			case 2: v(select_id_ENB2_Measurement_ID()); return true;
			case 3: v(select_id_Registration_Request()); return true;
			case 4: v(select_id_ReportCharacteristics()); return true;
			case 5: v(select_id_CellToReport()); return true;
			case 6: v(select_id_ReportingPeriodicity()); return true;
			case 7: v(select_id_PartialSuccessIndicator()); return true;
			case 8: v(select_id_ReportingPeriodicityRSRPMR()); return true;
			case 9: v(select_id_ReportingPeriodicityCSIR()); return true;
			case 10: if(type != 10) {clear(); asn::base::set();} type = 10; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<Measurement_ID>()); return true;
			case 2: v(var.as<Measurement_ID>()); return true;
			case 3: v(var.as<Registration_Request>()); return true;
			case 4: v(var.as<ReportCharacteristics>()); return true;
			case 5: v(var.as<CellToReport_List>()); return true;
			case 6: v(var.as<ReportingPeriodicity>()); return true;
			case 7: v(var.as<PartialSuccessIndicator>()); return true;
			case 8: v(var.as<ReportingPeriodicityRSRPMR>()); return true;
			case 9: v(var.as<ReportingPeriodicityCSIR>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(CellToReport_List)];
			char dummy2[sizeof(Measurement_ID)];
			char dummy3[sizeof(PartialSuccessIndicator)];
			char dummy4[sizeof(Registration_Request)];
			char dummy5[sizeof(ReportCharacteristics)];
			char dummy6[sizeof(ReportingPeriodicity)];
			char dummy7[sizeof(ReportingPeriodicityCSIR)];
			char dummy8[sizeof(ReportingPeriodicityRSRPMR)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 10; }
		void clear() {type = 0;}
		void select_id_ENB1_Measurement_ID() { set(mandatory); type=1;}
		void select_id_ENB2_Measurement_ID() { set(conditional); type=2;}
		void select_id_Registration_Request() { set(mandatory); type=3;}
		void select_id_ReportCharacteristics() { set(optional); type=4;}
		void select_id_CellToReport() { set(mandatory); type=5;}
		void select_id_ReportingPeriodicity() { set(optional); type=6;}
		void select_id_PartialSuccessIndicator() { set(optional); type=7;}
		void select_id_ReportingPeriodicityRSRPMR() { set(optional); type=8;}
		void select_id_ReportingPeriodicityCSIR() { set(optional); type=9;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(conditional)) { type = 2; return true; }
			else if(equal(mandatory)) { type = 3; return true; }
			else if(equal(optional)) { type = 4; return true; }
			else if(equal(mandatory)) { type = 5; return true; }
			else if(equal(optional)) { type = 6; return true; }
			else if(equal(optional)) { type = 7; return true; }
			else if(equal(optional)) { type = 8; return true; }
			else if(equal(optional)) { type = 9; return true; }
			else { type = 10; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(conditional);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(optional);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(optional);} return false;
			case 7: type = 7; if(v(ref_nested())) { return equal(optional);} return false;
			case 8: type = 8; if(v(ref_nested())) { return equal(optional);} return false;
			case 9: type = 9; if(v(ref_nested())) { return equal(optional);} return false;
			case 10: type = 10; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
ResourceStatusRequest ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{ResourceStatusRequest-IEs}},
	...
}
*/

struct ResourceStatusRequest : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "ResourceStatusRequest";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<ResourceStatusRequest_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<ResourceStatusRequest_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
ResourceStatusResponse-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-ENB1-Measurement-ID					CRITICALITY reject	TYPE Measurement-ID							PRESENCE mandatory}|
	{ ID id-ENB2-Measurement-ID					CRITICALITY reject	TYPE Measurement-ID							PRESENCE mandatory}|
	{ ID id-CriticalityDiagnostics				CRITICALITY ignore	TYPE CriticalityDiagnostics					PRESENCE optional}|
	{ ID id-MeasurementInitiationResult-List	CRITICALITY ignore	TYPE MeasurementInitiationResult-List	PRESENCE optional},
	...
}
*/

struct ResourceStatusResponse_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 5; }
		void clear() {type = 0;}
		void select_id_ENB1_Measurement_ID() { set(id_ENB1_Measurement_ID); type=1;}
		void select_id_ENB2_Measurement_ID() { set(id_ENB2_Measurement_ID); type=2;}
		void select_id_CriticalityDiagnostics() { set(id_CriticalityDiagnostics); type=3;}
		void select_id_MeasurementInitiationResult_List() { set(id_MeasurementInitiationResult_List); type=4;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_ENB1_Measurement_ID)) { type = 1; return true; }
			else if(equal(id_ENB2_Measurement_ID)) { type = 2; return true; }
			else if(equal(id_CriticalityDiagnostics)) { type = 3; return true; }
			else if(equal(id_MeasurementInitiationResult_List)) { type = 4; return true; }
			else { type = 5; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_ENB1_Measurement_ID);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_ENB2_Measurement_ID);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_CriticalityDiagnostics);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(id_MeasurementInitiationResult_List);} return false;
			case 5: type = 5; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 5; }
		void clear() {type = 0;}
		void select_id_ENB1_Measurement_ID() { set(reject); type=1;}
		void select_id_ENB2_Measurement_ID() { set(reject); type=2;}
		void select_id_CriticalityDiagnostics() { set(ignore); type=3;}
		void select_id_MeasurementInitiationResult_List() { set(ignore); type=4;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else if(equal(reject)) { type = 2; return true; }
			else if(equal(ignore)) { type = 3; return true; }
			else if(equal(ignore)) { type = 4; return true; }
			else { type = 5; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(reject);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(ignore);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(ignore);} return false;
			case 5: type = 5; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		Measurement_ID& select_id_ENB1_Measurement_ID() { return set<Measurement_ID>(1); }
		Measurement_ID const* get_id_ENB1_Measurement_ID() const { return get<Measurement_ID>(1); }
		Measurement_ID& select_id_ENB2_Measurement_ID() { return set<Measurement_ID>(2); }
		Measurement_ID const* get_id_ENB2_Measurement_ID() const { return get<Measurement_ID>(2); }
		CriticalityDiagnostics& select_id_CriticalityDiagnostics() { return set<CriticalityDiagnostics>(3); }
		CriticalityDiagnostics const* get_id_CriticalityDiagnostics() const { return get<CriticalityDiagnostics>(3); }
		MeasurementInitiationResult_List& select_id_MeasurementInitiationResult_List() { return set<MeasurementInitiationResult_List>(4); }
		MeasurementInitiationResult_List const* get_id_MeasurementInitiationResult_List() const { return get<MeasurementInitiationResult_List>(4); }
		bool is_unknown() const { return type == 5; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<Measurement_ID>(); break;
			case 2: var.destroy<Measurement_ID>(); break;
			case 3: var.destroy<CriticalityDiagnostics>(); break;
			case 4: var.destroy<MeasurementInitiationResult_List>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<Measurement_ID>(1);
			v.template operator()<Measurement_ID>(2);
			v.template operator()<CriticalityDiagnostics>(3);
			v.template operator()<MeasurementInitiationResult_List>(4);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_ENB1_Measurement_ID()); return true;
			case 2: v(select_id_ENB2_Measurement_ID()); return true;
			case 3: v(select_id_CriticalityDiagnostics()); return true;
			case 4: v(select_id_MeasurementInitiationResult_List()); return true;
			case 5: if(type != 5) {clear(); asn::base::set();} type = 5; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<Measurement_ID>()); return true;
			case 2: v(var.as<Measurement_ID>()); return true;
			case 3: v(var.as<CriticalityDiagnostics>()); return true;
			case 4: v(var.as<MeasurementInitiationResult_List>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(CriticalityDiagnostics)];
			char dummy2[sizeof(MeasurementInitiationResult_List)];
			char dummy3[sizeof(Measurement_ID)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 5; }
		void clear() {type = 0;}
		void select_id_ENB1_Measurement_ID() { set(mandatory); type=1;}
		void select_id_ENB2_Measurement_ID() { set(mandatory); type=2;}
		void select_id_CriticalityDiagnostics() { set(optional); type=3;}
		void select_id_MeasurementInitiationResult_List() { set(optional); type=4;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(mandatory)) { type = 2; return true; }
			else if(equal(optional)) { type = 3; return true; }
			else if(equal(optional)) { type = 4; return true; }
			else { type = 5; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(optional);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(optional);} return false;
			case 5: type = 5; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
ResourceStatusResponse ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{ResourceStatusResponse-IEs}},
	...
}
*/

struct ResourceStatusResponse : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "ResourceStatusResponse";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<ResourceStatusResponse_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<ResourceStatusResponse_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
ResourceStatusUpdate-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-ENB1-Measurement-ID		CRITICALITY reject	TYPE Measurement-ID					PRESENCE mandatory}|
	{ ID id-ENB2-Measurement-ID		CRITICALITY reject	TYPE Measurement-ID					PRESENCE mandatory}|
	{ ID id-CellMeasurementResult	CRITICALITY ignore	TYPE CellMeasurementResult-List		PRESENCE mandatory},
	...
}
*/

struct ResourceStatusUpdate_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 4; }
		void clear() {type = 0;}
		void select_id_ENB1_Measurement_ID() { set(id_ENB1_Measurement_ID); type=1;}
		void select_id_ENB2_Measurement_ID() { set(id_ENB2_Measurement_ID); type=2;}
		void select_id_CellMeasurementResult() { set(id_CellMeasurementResult); type=3;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_ENB1_Measurement_ID)) { type = 1; return true; }
			else if(equal(id_ENB2_Measurement_ID)) { type = 2; return true; }
			else if(equal(id_CellMeasurementResult)) { type = 3; return true; }
			else { type = 4; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_ENB1_Measurement_ID);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_ENB2_Measurement_ID);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_CellMeasurementResult);} return false;
			case 4: type = 4; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 4; }
		void clear() {type = 0;}
		void select_id_ENB1_Measurement_ID() { set(reject); type=1;}
		void select_id_ENB2_Measurement_ID() { set(reject); type=2;}
		void select_id_CellMeasurementResult() { set(ignore); type=3;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else if(equal(reject)) { type = 2; return true; }
			else if(equal(ignore)) { type = 3; return true; }
			else { type = 4; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(reject);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(ignore);} return false;
			case 4: type = 4; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		Measurement_ID& select_id_ENB1_Measurement_ID() { return set<Measurement_ID>(1); }
		Measurement_ID const* get_id_ENB1_Measurement_ID() const { return get<Measurement_ID>(1); }
		Measurement_ID& select_id_ENB2_Measurement_ID() { return set<Measurement_ID>(2); }
		Measurement_ID const* get_id_ENB2_Measurement_ID() const { return get<Measurement_ID>(2); }
		CellMeasurementResult_List& select_id_CellMeasurementResult() { return set<CellMeasurementResult_List>(3); }
		CellMeasurementResult_List const* get_id_CellMeasurementResult() const { return get<CellMeasurementResult_List>(3); }
		bool is_unknown() const { return type == 4; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<Measurement_ID>(); break;
			case 2: var.destroy<Measurement_ID>(); break;
			case 3: var.destroy<CellMeasurementResult_List>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<Measurement_ID>(1);
			v.template operator()<Measurement_ID>(2);
			v.template operator()<CellMeasurementResult_List>(3);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_ENB1_Measurement_ID()); return true;
			case 2: v(select_id_ENB2_Measurement_ID()); return true;
			case 3: v(select_id_CellMeasurementResult()); return true;
			case 4: if(type != 4) {clear(); asn::base::set();} type = 4; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<Measurement_ID>()); return true;
			case 2: v(var.as<Measurement_ID>()); return true;
			case 3: v(var.as<CellMeasurementResult_List>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(CellMeasurementResult_List)];
			char dummy2[sizeof(Measurement_ID)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 4; }
		void clear() {type = 0;}
		void select_id_ENB1_Measurement_ID() { set(mandatory); type=1;}
		void select_id_ENB2_Measurement_ID() { set(mandatory); type=2;}
		void select_id_CellMeasurementResult() { set(mandatory); type=3;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(mandatory)) { type = 2; return true; }
			else if(equal(mandatory)) { type = 3; return true; }
			else { type = 4; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 4: type = 4; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
ResourceStatusUpdate ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{ResourceStatusUpdate-IEs}},
	...
}
*/

struct ResourceStatusUpdate : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "ResourceStatusUpdate";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<ResourceStatusUpdate_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<ResourceStatusUpdate_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
ResponseInformationSeNBReconfComp-SuccessItemExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct ResponseInformationSeNBReconfComp_SuccessItemExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
ResponseInformationSeNBReconfComp-SuccessItem ::= SEQUENCE {
	meNBtoSeNBContainer				MeNBtoSeNBContainer OPTIONAL,
	iE-Extensions					ProtocolExtensionContainer { {ResponseInformationSeNBReconfComp-SuccessItemExtIEs} }	OPTIONAL,
	...
}
*/

struct ResponseInformationSeNBReconfComp_SuccessItem : asn::sequence<2, 0, true, 2>
{
	static constexpr const char* name() {return "ResponseInformationSeNBReconfComp-SuccessItem";}
	using parent_t = asn::sequence<2, 0, true, 2>;
	struct meNBtoSeNBContainer_t : MeNBtoSeNBContainer
	{
		static constexpr const char* name() {return "meNBtoSeNBContainer_t";}
		using parent_t = MeNBtoSeNBContainer;
		static constexpr bool optional = true;

	};
	meNBtoSeNBContainer_t& set_meNBtoSeNBContainer() { meNBtoSeNBContainer.setpresent(true); return meNBtoSeNBContainer;}
	meNBtoSeNBContainer_t const* get_meNBtoSeNBContainer() const {return meNBtoSeNBContainer.is_valid() ? &meNBtoSeNBContainer : nullptr;}
	struct iE_Extensions_t : ProtocolExtensionContainer<ResponseInformationSeNBReconfComp_SuccessItemExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<ResponseInformationSeNBReconfComp_SuccessItemExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(meNBtoSeNBContainer);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(meNBtoSeNBContainer);
		v(iE_Extensions);

	};
	void clear()
	{
		meNBtoSeNBContainer.clear();
		iE_Extensions.clear();

	};
	private:
	meNBtoSeNBContainer_t	meNBtoSeNBContainer;
	iE_Extensions_t	iE_Extensions;

};
/*
ResponseInformationSeNBReconfComp-RejectByMeNBItemExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct ResponseInformationSeNBReconfComp_RejectByMeNBItemExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
ResponseInformationSeNBReconfComp-RejectByMeNBItem ::= SEQUENCE {
	cause							Cause,
	meNBtoSeNBContainer				MeNBtoSeNBContainer																						OPTIONAL,
	iE-Extensions					ProtocolExtensionContainer { {ResponseInformationSeNBReconfComp-RejectByMeNBItemExtIEs} }	OPTIONAL,
	...
}
*/

struct ResponseInformationSeNBReconfComp_RejectByMeNBItem : asn::sequence<3, 0, true, 2>
{
	static constexpr const char* name() {return "ResponseInformationSeNBReconfComp-RejectByMeNBItem";}
	using parent_t = asn::sequence<3, 0, true, 2>;
	struct cause_t : Cause
	{
		static constexpr const char* name() {return "cause_t";}
		using parent_t = Cause;

	};
	cause_t& ref_cause() {return cause;}
	cause_t const& ref_cause() const {return cause;}
	struct meNBtoSeNBContainer_t : MeNBtoSeNBContainer
	{
		static constexpr const char* name() {return "meNBtoSeNBContainer_t";}
		using parent_t = MeNBtoSeNBContainer;
		static constexpr bool optional = true;

	};
	meNBtoSeNBContainer_t& set_meNBtoSeNBContainer() { meNBtoSeNBContainer.setpresent(true); return meNBtoSeNBContainer;}
	meNBtoSeNBContainer_t const* get_meNBtoSeNBContainer() const {return meNBtoSeNBContainer.is_valid() ? &meNBtoSeNBContainer : nullptr;}
	struct iE_Extensions_t : ProtocolExtensionContainer<ResponseInformationSeNBReconfComp_RejectByMeNBItemExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<ResponseInformationSeNBReconfComp_RejectByMeNBItemExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(cause);
		v(meNBtoSeNBContainer);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(cause);
		v(meNBtoSeNBContainer);
		v(iE_Extensions);

	};
	void clear()
	{
		cause.clear();
		meNBtoSeNBContainer.clear();
		iE_Extensions.clear();

	};
	private:
	cause_t	cause;
	meNBtoSeNBContainer_t	meNBtoSeNBContainer;
	iE_Extensions_t	iE_Extensions;

};
/*
ResponseInformationSeNBReconfComp ::= CHOICE {
	success				ResponseInformationSeNBReconfComp-SuccessItem,
	reject-by-MeNB		ResponseInformationSeNBReconfComp-RejectByMeNBItem,
	...
}
*/

struct ResponseInformationSeNBReconfComp : asn::choice<2, 0, true>
{
	static constexpr const char* name() {return "ResponseInformationSeNBReconfComp";}
	using parent_t = asn::choice<2, 0, true>;
	index_type get_index() const {return index;}
	bool is_unknown() const {return index == 3;}
	void set_unknown() { set_index(3);  }
	~ResponseInformationSeNBReconfComp() {clear();}
	struct success_t : ResponseInformationSeNBReconfComp_SuccessItem
	{
		static constexpr const char* name() {return "success_t";}
		using parent_t = ResponseInformationSeNBReconfComp_SuccessItem;

	};
	struct reject_by_MeNB_t : ResponseInformationSeNBReconfComp_RejectByMeNBItem
	{
		static constexpr const char* name() {return "reject_by_MeNB_t";}
		using parent_t = ResponseInformationSeNBReconfComp_RejectByMeNBItem;

	};
	void clear()
	{
		switch(get_index())
		{
		case 1: var.destroy<success_t>(); break;
		case 2: var.destroy<reject_by_MeNB_t>(); break;
		}
		index = 0;
		base::clear();
	}
	template<typename V> bool decode(size_t idx, V& v)
	{
		clear();
		switch(idx)
		{
		case 1: set_index(1); return v(var.build<success_t>());
		case 2: set_index(2); return v(var.build<reject_by_MeNB_t>());
		}
		return false;

	}
	template<typename V> bool encode(V& v) const
	{
		switch(get_index())
		{
		case 1: return v(var.as<success_t>());
		case 2: return v(var.as<reject_by_MeNB_t>());
		}
		return false;
	}
	template<typename V> static inline void enumerate(V& v)
	{
		v.template operator()<success_t>(1);
		v.template operator()<reject_by_MeNB_t>(2);

	}
	success_t& select_success() { if(get_index() != 1) { clear(); set_index(1); return var.build<success_t>();} return var.as<success_t>();}
	success_t const* get_success() const { if(get_index() == 1) { return &var.as<success_t>();} return nullptr; }
	reject_by_MeNB_t& select_reject_by_MeNB() { if(get_index() != 2) { clear(); set_index(2); return var.build<reject_by_MeNB_t>();} return var.as<reject_by_MeNB_t>();}
	reject_by_MeNB_t const* get_reject_by_MeNB() const { if(get_index() == 2) { return &var.as<reject_by_MeNB_t>();} return nullptr; }
	private:
	void set_index(index_type i) {index = i; base::set();}
	union union_type
	{
		char dummy1[sizeof(success_t)];
		char dummy2[sizeof(reject_by_MeNB_t)];

	};
	asn::variant<sizeof(union_type)>	var;
	index_type	index {0};
};
/*
ResponseInformationSgNBReconfComp-SuccessItemExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct ResponseInformationSgNBReconfComp_SuccessItemExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
ResponseInformationSgNBReconfComp-SuccessItem ::= SEQUENCE {
	meNBtoSgNBContainer				MeNBtoSgNBContainer					OPTIONAL,
	iE-Extensions					ProtocolExtensionContainer { {ResponseInformationSgNBReconfComp-SuccessItemExtIEs} }	OPTIONAL,
	...
}
*/

struct ResponseInformationSgNBReconfComp_SuccessItem : asn::sequence<2, 0, true, 2>
{
	static constexpr const char* name() {return "ResponseInformationSgNBReconfComp-SuccessItem";}
	using parent_t = asn::sequence<2, 0, true, 2>;
	struct meNBtoSgNBContainer_t : MeNBtoSgNBContainer
	{
		static constexpr const char* name() {return "meNBtoSgNBContainer_t";}
		using parent_t = MeNBtoSgNBContainer;
		static constexpr bool optional = true;

	};
	meNBtoSgNBContainer_t& set_meNBtoSgNBContainer() { meNBtoSgNBContainer.setpresent(true); return meNBtoSgNBContainer;}
	meNBtoSgNBContainer_t const* get_meNBtoSgNBContainer() const {return meNBtoSgNBContainer.is_valid() ? &meNBtoSgNBContainer : nullptr;}
	struct iE_Extensions_t : ProtocolExtensionContainer<ResponseInformationSgNBReconfComp_SuccessItemExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<ResponseInformationSgNBReconfComp_SuccessItemExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(meNBtoSgNBContainer);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(meNBtoSgNBContainer);
		v(iE_Extensions);

	};
	void clear()
	{
		meNBtoSgNBContainer.clear();
		iE_Extensions.clear();

	};
	private:
	meNBtoSgNBContainer_t	meNBtoSgNBContainer;
	iE_Extensions_t	iE_Extensions;

};
/*
ResponseInformationSgNBReconfComp-RejectByMeNBItemExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct ResponseInformationSgNBReconfComp_RejectByMeNBItemExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
ResponseInformationSgNBReconfComp-RejectByMeNBItem ::= SEQUENCE {
	cause							Cause,
	iE-Extensions					ProtocolExtensionContainer { {ResponseInformationSgNBReconfComp-RejectByMeNBItemExtIEs} }		OPTIONAL,
	...
}
*/

struct ResponseInformationSgNBReconfComp_RejectByMeNBItem : asn::sequence<2, 0, true, 1>
{
	static constexpr const char* name() {return "ResponseInformationSgNBReconfComp-RejectByMeNBItem";}
	using parent_t = asn::sequence<2, 0, true, 1>;
	struct cause_t : Cause
	{
		static constexpr const char* name() {return "cause_t";}
		using parent_t = Cause;

	};
	cause_t& ref_cause() {return cause;}
	cause_t const& ref_cause() const {return cause;}
	struct iE_Extensions_t : ProtocolExtensionContainer<ResponseInformationSgNBReconfComp_RejectByMeNBItemExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<ResponseInformationSgNBReconfComp_RejectByMeNBItemExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(cause);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(cause);
		v(iE_Extensions);

	};
	void clear()
	{
		cause.clear();
		iE_Extensions.clear();

	};
	private:
	cause_t	cause;
	iE_Extensions_t	iE_Extensions;

};
/*
ResponseInformationSgNBReconfComp ::= CHOICE {
	success-SgNBReconfComp				ResponseInformationSgNBReconfComp-SuccessItem,
	reject-by-MeNB-SgNBReconfComp		ResponseInformationSgNBReconfComp-RejectByMeNBItem,
	...
}
*/

struct ResponseInformationSgNBReconfComp : asn::choice<2, 0, true>
{
	static constexpr const char* name() {return "ResponseInformationSgNBReconfComp";}
	using parent_t = asn::choice<2, 0, true>;
	index_type get_index() const {return index;}
	bool is_unknown() const {return index == 3;}
	void set_unknown() { set_index(3);  }
	~ResponseInformationSgNBReconfComp() {clear();}
	struct success_SgNBReconfComp_t : ResponseInformationSgNBReconfComp_SuccessItem
	{
		static constexpr const char* name() {return "success_SgNBReconfComp_t";}
		using parent_t = ResponseInformationSgNBReconfComp_SuccessItem;

	};
	struct reject_by_MeNB_SgNBReconfComp_t : ResponseInformationSgNBReconfComp_RejectByMeNBItem
	{
		static constexpr const char* name() {return "reject_by_MeNB_SgNBReconfComp_t";}
		using parent_t = ResponseInformationSgNBReconfComp_RejectByMeNBItem;

	};
	void clear()
	{
		switch(get_index())
		{
		case 1: var.destroy<success_SgNBReconfComp_t>(); break;
		case 2: var.destroy<reject_by_MeNB_SgNBReconfComp_t>(); break;
		}
		index = 0;
		base::clear();
	}
	template<typename V> bool decode(size_t idx, V& v)
	{
		clear();
		switch(idx)
		{
		case 1: set_index(1); return v(var.build<success_SgNBReconfComp_t>());
		case 2: set_index(2); return v(var.build<reject_by_MeNB_SgNBReconfComp_t>());
		}
		return false;

	}
	template<typename V> bool encode(V& v) const
	{
		switch(get_index())
		{
		case 1: return v(var.as<success_SgNBReconfComp_t>());
		case 2: return v(var.as<reject_by_MeNB_SgNBReconfComp_t>());
		}
		return false;
	}
	template<typename V> static inline void enumerate(V& v)
	{
		v.template operator()<success_SgNBReconfComp_t>(1);
		v.template operator()<reject_by_MeNB_SgNBReconfComp_t>(2);

	}
	success_SgNBReconfComp_t& select_success_SgNBReconfComp() { if(get_index() != 1) { clear(); set_index(1); return var.build<success_SgNBReconfComp_t>();} return var.as<success_SgNBReconfComp_t>();}
	success_SgNBReconfComp_t const* get_success_SgNBReconfComp() const { if(get_index() == 1) { return &var.as<success_SgNBReconfComp_t>();} return nullptr; }
	reject_by_MeNB_SgNBReconfComp_t& select_reject_by_MeNB_SgNBReconfComp() { if(get_index() != 2) { clear(); set_index(2); return var.build<reject_by_MeNB_SgNBReconfComp_t>();} return var.as<reject_by_MeNB_SgNBReconfComp_t>();}
	reject_by_MeNB_SgNBReconfComp_t const* get_reject_by_MeNB_SgNBReconfComp() const { if(get_index() == 2) { return &var.as<reject_by_MeNB_SgNBReconfComp_t>();} return nullptr; }
	private:
	void set_index(index_type i) {index = i; base::set();}
	union union_type
	{
		char dummy1[sizeof(success_SgNBReconfComp_t)];
		char dummy2[sizeof(reject_by_MeNB_SgNBReconfComp_t)];

	};
	asn::variant<sizeof(union_type)>	var;
	index_type	index {0};
};
/*
RetrieveUEContextFailure-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-New-eNB-UE-X2AP-ID				CRITICALITY ignore	TYPE UE-X2AP-ID					PRESENCE mandatory}|
	{ ID id-New-eNB-UE-X2AP-ID-Extension	CRITICALITY ignore	TYPE UE-X2AP-ID-Extension		PRESENCE optional}|
	{ ID id-Cause							CRITICALITY ignore	TYPE Cause						PRESENCE mandatory}|
	{ ID id-CriticalityDiagnostics			CRITICALITY ignore	TYPE CriticalityDiagnostics		PRESENCE optional},
	...
}
*/

struct RetrieveUEContextFailure_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 5; }
		void clear() {type = 0;}
		void select_id_New_eNB_UE_X2AP_ID() { set(id_New_eNB_UE_X2AP_ID); type=1;}
		void select_id_New_eNB_UE_X2AP_ID_Extension() { set(id_New_eNB_UE_X2AP_ID_Extension); type=2;}
		void select_id_Cause() { set(id_Cause); type=3;}
		void select_id_CriticalityDiagnostics() { set(id_CriticalityDiagnostics); type=4;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_New_eNB_UE_X2AP_ID)) { type = 1; return true; }
			else if(equal(id_New_eNB_UE_X2AP_ID_Extension)) { type = 2; return true; }
			else if(equal(id_Cause)) { type = 3; return true; }
			else if(equal(id_CriticalityDiagnostics)) { type = 4; return true; }
			else { type = 5; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_New_eNB_UE_X2AP_ID);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_New_eNB_UE_X2AP_ID_Extension);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_Cause);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(id_CriticalityDiagnostics);} return false;
			case 5: type = 5; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 5; }
		void clear() {type = 0;}
		void select_id_New_eNB_UE_X2AP_ID() { set(ignore); type=1;}
		void select_id_New_eNB_UE_X2AP_ID_Extension() { set(ignore); type=2;}
		void select_id_Cause() { set(ignore); type=3;}
		void select_id_CriticalityDiagnostics() { set(ignore); type=4;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else if(equal(ignore)) { type = 2; return true; }
			else if(equal(ignore)) { type = 3; return true; }
			else if(equal(ignore)) { type = 4; return true; }
			else { type = 5; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(ignore);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(ignore);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(ignore);} return false;
			case 5: type = 5; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		UE_X2AP_ID& select_id_New_eNB_UE_X2AP_ID() { return set<UE_X2AP_ID>(1); }
		UE_X2AP_ID const* get_id_New_eNB_UE_X2AP_ID() const { return get<UE_X2AP_ID>(1); }
		UE_X2AP_ID_Extension& select_id_New_eNB_UE_X2AP_ID_Extension() { return set<UE_X2AP_ID_Extension>(2); }
		UE_X2AP_ID_Extension const* get_id_New_eNB_UE_X2AP_ID_Extension() const { return get<UE_X2AP_ID_Extension>(2); }
		Cause& select_id_Cause() { return set<Cause>(3); }
		Cause const* get_id_Cause() const { return get<Cause>(3); }
		CriticalityDiagnostics& select_id_CriticalityDiagnostics() { return set<CriticalityDiagnostics>(4); }
		CriticalityDiagnostics const* get_id_CriticalityDiagnostics() const { return get<CriticalityDiagnostics>(4); }
		bool is_unknown() const { return type == 5; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<UE_X2AP_ID>(); break;
			case 2: var.destroy<UE_X2AP_ID_Extension>(); break;
			case 3: var.destroy<Cause>(); break;
			case 4: var.destroy<CriticalityDiagnostics>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<UE_X2AP_ID>(1);
			v.template operator()<UE_X2AP_ID_Extension>(2);
			v.template operator()<Cause>(3);
			v.template operator()<CriticalityDiagnostics>(4);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_New_eNB_UE_X2AP_ID()); return true;
			case 2: v(select_id_New_eNB_UE_X2AP_ID_Extension()); return true;
			case 3: v(select_id_Cause()); return true;
			case 4: v(select_id_CriticalityDiagnostics()); return true;
			case 5: if(type != 5) {clear(); asn::base::set();} type = 5; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<UE_X2AP_ID>()); return true;
			case 2: v(var.as<UE_X2AP_ID_Extension>()); return true;
			case 3: v(var.as<Cause>()); return true;
			case 4: v(var.as<CriticalityDiagnostics>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(Cause)];
			char dummy2[sizeof(CriticalityDiagnostics)];
			char dummy3[sizeof(UE_X2AP_ID)];
			char dummy4[sizeof(UE_X2AP_ID_Extension)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 5; }
		void clear() {type = 0;}
		void select_id_New_eNB_UE_X2AP_ID() { set(mandatory); type=1;}
		void select_id_New_eNB_UE_X2AP_ID_Extension() { set(optional); type=2;}
		void select_id_Cause() { set(mandatory); type=3;}
		void select_id_CriticalityDiagnostics() { set(optional); type=4;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(optional)) { type = 2; return true; }
			else if(equal(mandatory)) { type = 3; return true; }
			else if(equal(optional)) { type = 4; return true; }
			else { type = 5; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(optional);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(optional);} return false;
			case 5: type = 5; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
RetrieveUEContextFailure ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{ RetrieveUEContextFailure-IEs}},
	...
}
*/

struct RetrieveUEContextFailure : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "RetrieveUEContextFailure";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<RetrieveUEContextFailure_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<RetrieveUEContextFailure_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
RetrieveUEContextRequest-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-New-eNB-UE-X2AP-ID					CRITICALITY reject	TYPE UE-X2AP-ID				PRESENCE mandatory}|
	{ ID id-SeNB-UE-X2AP-ID-Extension			CRITICALITY reject	TYPE UE-X2AP-ID-Extension	PRESENCE optional}|
	{ ID id-resumeID							CRITICALITY reject	TYPE ResumeID				PRESENCE mandatory}|
	{ ID id-ShortMAC-I							CRITICALITY reject	TYPE ShortMAC-I				PRESENCE mandatory}|
	{ ID id-NewEUTRANCellIdentifier				CRITICALITY reject	TYPE EUTRANCellIdentifier	PRESENCE mandatory}|
	{ID id-FailureCellCRNTI						CRITICALITY reject	TYPE CRNTI					PRESENCE optional}|
	{ID id-FailureCellPCI						CRITICALITY reject	TYPE PCI					PRESENCE optional},
	...
}
*/

struct RetrieveUEContextRequest_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 8; }
		void clear() {type = 0;}
		void select_id_New_eNB_UE_X2AP_ID() { set(id_New_eNB_UE_X2AP_ID); type=1;}
		void select_id_SeNB_UE_X2AP_ID_Extension() { set(id_SeNB_UE_X2AP_ID_Extension); type=2;}
		void select_id_resumeID() { set(id_resumeID); type=3;}
		void select_id_ShortMAC_I() { set(id_ShortMAC_I); type=4;}
		void select_id_NewEUTRANCellIdentifier() { set(id_NewEUTRANCellIdentifier); type=5;}
		void select_id_FailureCellCRNTI() { set(id_FailureCellCRNTI); type=6;}
		void select_id_FailureCellPCI() { set(id_FailureCellPCI); type=7;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_New_eNB_UE_X2AP_ID)) { type = 1; return true; }
			else if(equal(id_SeNB_UE_X2AP_ID_Extension)) { type = 2; return true; }
			else if(equal(id_resumeID)) { type = 3; return true; }
			else if(equal(id_ShortMAC_I)) { type = 4; return true; }
			else if(equal(id_NewEUTRANCellIdentifier)) { type = 5; return true; }
			else if(equal(id_FailureCellCRNTI)) { type = 6; return true; }
			else if(equal(id_FailureCellPCI)) { type = 7; return true; }
			else { type = 8; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_New_eNB_UE_X2AP_ID);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_SeNB_UE_X2AP_ID_Extension);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_resumeID);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(id_ShortMAC_I);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(id_NewEUTRANCellIdentifier);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(id_FailureCellCRNTI);} return false;
			case 7: type = 7; if(v(ref_nested())) { return equal(id_FailureCellPCI);} return false;
			case 8: type = 8; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 8; }
		void clear() {type = 0;}
		void select_id_New_eNB_UE_X2AP_ID() { set(reject); type=1;}
		void select_id_SeNB_UE_X2AP_ID_Extension() { set(reject); type=2;}
		void select_id_resumeID() { set(reject); type=3;}
		void select_id_ShortMAC_I() { set(reject); type=4;}
		void select_id_NewEUTRANCellIdentifier() { set(reject); type=5;}
		void select_id_FailureCellCRNTI() { set(reject); type=6;}
		void select_id_FailureCellPCI() { set(reject); type=7;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else if(equal(reject)) { type = 2; return true; }
			else if(equal(reject)) { type = 3; return true; }
			else if(equal(reject)) { type = 4; return true; }
			else if(equal(reject)) { type = 5; return true; }
			else if(equal(reject)) { type = 6; return true; }
			else if(equal(reject)) { type = 7; return true; }
			else { type = 8; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(reject);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(reject);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(reject);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(reject);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(reject);} return false;
			case 7: type = 7; if(v(ref_nested())) { return equal(reject);} return false;
			case 8: type = 8; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		UE_X2AP_ID& select_id_New_eNB_UE_X2AP_ID() { return set<UE_X2AP_ID>(1); }
		UE_X2AP_ID const* get_id_New_eNB_UE_X2AP_ID() const { return get<UE_X2AP_ID>(1); }
		UE_X2AP_ID_Extension& select_id_SeNB_UE_X2AP_ID_Extension() { return set<UE_X2AP_ID_Extension>(2); }
		UE_X2AP_ID_Extension const* get_id_SeNB_UE_X2AP_ID_Extension() const { return get<UE_X2AP_ID_Extension>(2); }
		ResumeID& select_id_resumeID() { return set<ResumeID>(3); }
		ResumeID const* get_id_resumeID() const { return get<ResumeID>(3); }
		ShortMAC_I& select_id_ShortMAC_I() { return set<ShortMAC_I>(4); }
		ShortMAC_I const* get_id_ShortMAC_I() const { return get<ShortMAC_I>(4); }
		EUTRANCellIdentifier& select_id_NewEUTRANCellIdentifier() { return set<EUTRANCellIdentifier>(5); }
		EUTRANCellIdentifier const* get_id_NewEUTRANCellIdentifier() const { return get<EUTRANCellIdentifier>(5); }
		CRNTI& select_id_FailureCellCRNTI() { return set<CRNTI>(6); }
		CRNTI const* get_id_FailureCellCRNTI() const { return get<CRNTI>(6); }
		PCI& select_id_FailureCellPCI() { return set<PCI>(7); }
		PCI const* get_id_FailureCellPCI() const { return get<PCI>(7); }
		bool is_unknown() const { return type == 8; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<UE_X2AP_ID>(); break;
			case 2: var.destroy<UE_X2AP_ID_Extension>(); break;
			case 3: var.destroy<ResumeID>(); break;
			case 4: var.destroy<ShortMAC_I>(); break;
			case 5: var.destroy<EUTRANCellIdentifier>(); break;
			case 6: var.destroy<CRNTI>(); break;
			case 7: var.destroy<PCI>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<UE_X2AP_ID>(1);
			v.template operator()<UE_X2AP_ID_Extension>(2);
			v.template operator()<ResumeID>(3);
			v.template operator()<ShortMAC_I>(4);
			v.template operator()<EUTRANCellIdentifier>(5);
			v.template operator()<CRNTI>(6);
			v.template operator()<PCI>(7);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_New_eNB_UE_X2AP_ID()); return true;
			case 2: v(select_id_SeNB_UE_X2AP_ID_Extension()); return true;
			case 3: v(select_id_resumeID()); return true;
			case 4: v(select_id_ShortMAC_I()); return true;
			case 5: v(select_id_NewEUTRANCellIdentifier()); return true;
			case 6: v(select_id_FailureCellCRNTI()); return true;
			case 7: v(select_id_FailureCellPCI()); return true;
			case 8: if(type != 8) {clear(); asn::base::set();} type = 8; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<UE_X2AP_ID>()); return true;
			case 2: v(var.as<UE_X2AP_ID_Extension>()); return true;
			case 3: v(var.as<ResumeID>()); return true;
			case 4: v(var.as<ShortMAC_I>()); return true;
			case 5: v(var.as<EUTRANCellIdentifier>()); return true;
			case 6: v(var.as<CRNTI>()); return true;
			case 7: v(var.as<PCI>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(CRNTI)];
			char dummy2[sizeof(EUTRANCellIdentifier)];
			char dummy3[sizeof(PCI)];
			char dummy4[sizeof(ResumeID)];
			char dummy5[sizeof(ShortMAC_I)];
			char dummy6[sizeof(UE_X2AP_ID)];
			char dummy7[sizeof(UE_X2AP_ID_Extension)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 8; }
		void clear() {type = 0;}
		void select_id_New_eNB_UE_X2AP_ID() { set(mandatory); type=1;}
		void select_id_SeNB_UE_X2AP_ID_Extension() { set(optional); type=2;}
		void select_id_resumeID() { set(mandatory); type=3;}
		void select_id_ShortMAC_I() { set(mandatory); type=4;}
		void select_id_NewEUTRANCellIdentifier() { set(mandatory); type=5;}
		void select_id_FailureCellCRNTI() { set(optional); type=6;}
		void select_id_FailureCellPCI() { set(optional); type=7;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(optional)) { type = 2; return true; }
			else if(equal(mandatory)) { type = 3; return true; }
			else if(equal(mandatory)) { type = 4; return true; }
			else if(equal(mandatory)) { type = 5; return true; }
			else if(equal(optional)) { type = 6; return true; }
			else if(equal(optional)) { type = 7; return true; }
			else { type = 8; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(optional);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(optional);} return false;
			case 7: type = 7; if(v(ref_nested())) { return equal(optional);} return false;
			case 8: type = 8; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
RetrieveUEContextRequest ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{ RetrieveUEContextRequest-IEs}},
	...
}
*/

struct RetrieveUEContextRequest : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "RetrieveUEContextRequest";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<RetrieveUEContextRequest_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<RetrieveUEContextRequest_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
UE-ContextInformationRetrieve-ExtIEs X2AP-PROTOCOL-EXTENSION ::= {
{ ID id-UESidelinkAggregateMaximumBitRate	CRITICALITY ignore	EXTENSION UESidelinkAggregateMaximumBitRate		PRESENCE optional},
	...
}
*/

struct UE_ContextInformationRetrieve_ExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_UESidelinkAggregateMaximumBitRate() { set(id_UESidelinkAggregateMaximumBitRate); type=1;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_UESidelinkAggregateMaximumBitRate)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_UESidelinkAggregateMaximumBitRate);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_UESidelinkAggregateMaximumBitRate() { set(ignore); type=1;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		UESidelinkAggregateMaximumBitRate& select_id_UESidelinkAggregateMaximumBitRate() { return set<UESidelinkAggregateMaximumBitRate>(1); }
		UESidelinkAggregateMaximumBitRate const* get_id_UESidelinkAggregateMaximumBitRate() const { return get<UESidelinkAggregateMaximumBitRate>(1); }
		bool is_unknown() const { return type == 2; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<UESidelinkAggregateMaximumBitRate>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<UESidelinkAggregateMaximumBitRate>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_UESidelinkAggregateMaximumBitRate()); return true;
			case 2: if(type != 2) {clear(); asn::base::set();} type = 2; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<UESidelinkAggregateMaximumBitRate>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(UESidelinkAggregateMaximumBitRate)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_UESidelinkAggregateMaximumBitRate() { set(optional); type=1;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(optional)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(optional);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
UE-ContextInformationRetrieve ::= SEQUENCE {
	mME-UE-S1AP-ID						UE-S1AP-ID,
	uESecurityCapabilities				UESecurityCapabilities,
	aS-SecurityInformation				AS-SecurityInformation,
	uEaggregateMaximumBitRate			UEAggregateMaximumBitRate,
	subscriberProfileIDforRFP			SubscriberProfileIDforRFP		OPTIONAL,
	e-RABs-ToBeSetup-ListRetrieve		E-RABs-ToBeSetup-ListRetrieve,
	rRC-Context							RRC-Context,
	handoverRestrictionList				HandoverRestrictionList			OPTIONAL,
	locationReportingInformation		LocationReportingInformation	OPTIONAL,
	managBasedMDTallowed				ManagementBasedMDTallowed		OPTIONAL,
	managBasedMDTPLMNList				MDTPLMNList						OPTIONAL,
	iE-Extensions						ProtocolExtensionContainer { {UE-ContextInformationRetrieve-ExtIEs} } OPTIONAL,
	...
}
*/

struct UE_ContextInformationRetrieve : asn::sequence<12, 0, true, 6>
{
	static constexpr const char* name() {return "UE-ContextInformationRetrieve";}
	using parent_t = asn::sequence<12, 0, true, 6>;
	struct mME_UE_S1AP_ID_t : UE_S1AP_ID
	{
		static constexpr const char* name() {return "mME_UE_S1AP_ID_t";}
		using parent_t = UE_S1AP_ID;

	};
	mME_UE_S1AP_ID_t& ref_mME_UE_S1AP_ID() {return mME_UE_S1AP_ID;}
	mME_UE_S1AP_ID_t const& ref_mME_UE_S1AP_ID() const {return mME_UE_S1AP_ID;}
	struct uESecurityCapabilities_t : UESecurityCapabilities
	{
		static constexpr const char* name() {return "uESecurityCapabilities_t";}
		using parent_t = UESecurityCapabilities;

	};
	uESecurityCapabilities_t& ref_uESecurityCapabilities() {return uESecurityCapabilities;}
	uESecurityCapabilities_t const& ref_uESecurityCapabilities() const {return uESecurityCapabilities;}
	struct aS_SecurityInformation_t : AS_SecurityInformation
	{
		static constexpr const char* name() {return "aS_SecurityInformation_t";}
		using parent_t = AS_SecurityInformation;

	};
	aS_SecurityInformation_t& ref_aS_SecurityInformation() {return aS_SecurityInformation;}
	aS_SecurityInformation_t const& ref_aS_SecurityInformation() const {return aS_SecurityInformation;}
	struct uEaggregateMaximumBitRate_t : UEAggregateMaximumBitRate
	{
		static constexpr const char* name() {return "uEaggregateMaximumBitRate_t";}
		using parent_t = UEAggregateMaximumBitRate;

	};
	uEaggregateMaximumBitRate_t& ref_uEaggregateMaximumBitRate() {return uEaggregateMaximumBitRate;}
	uEaggregateMaximumBitRate_t const& ref_uEaggregateMaximumBitRate() const {return uEaggregateMaximumBitRate;}
	struct subscriberProfileIDforRFP_t : SubscriberProfileIDforRFP
	{
		static constexpr const char* name() {return "subscriberProfileIDforRFP_t";}
		using parent_t = SubscriberProfileIDforRFP;
		static constexpr bool optional = true;

	};
	subscriberProfileIDforRFP_t& set_subscriberProfileIDforRFP() { subscriberProfileIDforRFP.setpresent(true); return subscriberProfileIDforRFP;}
	subscriberProfileIDforRFP_t const* get_subscriberProfileIDforRFP() const {return subscriberProfileIDforRFP.is_valid() ? &subscriberProfileIDforRFP : nullptr;}
	struct e_RABs_ToBeSetup_ListRetrieve_t : E_RABs_ToBeSetup_ListRetrieve
	{
		static constexpr const char* name() {return "e_RABs_ToBeSetup_ListRetrieve_t";}
		using parent_t = E_RABs_ToBeSetup_ListRetrieve;

	};
	e_RABs_ToBeSetup_ListRetrieve_t& ref_e_RABs_ToBeSetup_ListRetrieve() {return e_RABs_ToBeSetup_ListRetrieve;}
	e_RABs_ToBeSetup_ListRetrieve_t const& ref_e_RABs_ToBeSetup_ListRetrieve() const {return e_RABs_ToBeSetup_ListRetrieve;}
	struct rRC_Context_t : RRC_Context
	{
		static constexpr const char* name() {return "rRC_Context_t";}
		using parent_t = RRC_Context;

	};
	rRC_Context_t& ref_rRC_Context() {return rRC_Context;}
	rRC_Context_t const& ref_rRC_Context() const {return rRC_Context;}
	struct handoverRestrictionList_t : HandoverRestrictionList
	{
		static constexpr const char* name() {return "handoverRestrictionList_t";}
		using parent_t = HandoverRestrictionList;
		static constexpr bool optional = true;

	};
	handoverRestrictionList_t& set_handoverRestrictionList() { handoverRestrictionList.setpresent(true); return handoverRestrictionList;}
	handoverRestrictionList_t const* get_handoverRestrictionList() const {return handoverRestrictionList.is_valid() ? &handoverRestrictionList : nullptr;}
	struct locationReportingInformation_t : LocationReportingInformation
	{
		static constexpr const char* name() {return "locationReportingInformation_t";}
		using parent_t = LocationReportingInformation;
		static constexpr bool optional = true;

	};
	locationReportingInformation_t& set_locationReportingInformation() { locationReportingInformation.setpresent(true); return locationReportingInformation;}
	locationReportingInformation_t const* get_locationReportingInformation() const {return locationReportingInformation.is_valid() ? &locationReportingInformation : nullptr;}
	struct managBasedMDTallowed_t : ManagementBasedMDTallowed
	{
		static constexpr const char* name() {return "managBasedMDTallowed_t";}
		using parent_t = ManagementBasedMDTallowed;
		static constexpr bool optional = true;

	};
	managBasedMDTallowed_t& set_managBasedMDTallowed() { managBasedMDTallowed.setpresent(true); return managBasedMDTallowed;}
	managBasedMDTallowed_t const* get_managBasedMDTallowed() const {return managBasedMDTallowed.is_valid() ? &managBasedMDTallowed : nullptr;}
	struct managBasedMDTPLMNList_t : MDTPLMNList
	{
		static constexpr const char* name() {return "managBasedMDTPLMNList_t";}
		using parent_t = MDTPLMNList;
		static constexpr bool optional = true;

	};
	managBasedMDTPLMNList_t& set_managBasedMDTPLMNList() { managBasedMDTPLMNList.setpresent(true); return managBasedMDTPLMNList;}
	managBasedMDTPLMNList_t const* get_managBasedMDTPLMNList() const {return managBasedMDTPLMNList.is_valid() ? &managBasedMDTPLMNList : nullptr;}
	struct iE_Extensions_t : ProtocolExtensionContainer<UE_ContextInformationRetrieve_ExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<UE_ContextInformationRetrieve_ExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(mME_UE_S1AP_ID);
		v(uESecurityCapabilities);
		v(aS_SecurityInformation);
		v(uEaggregateMaximumBitRate);
		v(subscriberProfileIDforRFP);
		v(e_RABs_ToBeSetup_ListRetrieve);
		v(rRC_Context);
		v(handoverRestrictionList);
		v(locationReportingInformation);
		v(managBasedMDTallowed);
		v(managBasedMDTPLMNList);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(mME_UE_S1AP_ID);
		v(uESecurityCapabilities);
		v(aS_SecurityInformation);
		v(uEaggregateMaximumBitRate);
		v(subscriberProfileIDforRFP);
		v(e_RABs_ToBeSetup_ListRetrieve);
		v(rRC_Context);
		v(handoverRestrictionList);
		v(locationReportingInformation);
		v(managBasedMDTallowed);
		v(managBasedMDTPLMNList);
		v(iE_Extensions);

	};
	void clear()
	{
		mME_UE_S1AP_ID.clear();
		uESecurityCapabilities.clear();
		aS_SecurityInformation.clear();
		uEaggregateMaximumBitRate.clear();
		subscriberProfileIDforRFP.clear();
		e_RABs_ToBeSetup_ListRetrieve.clear();
		rRC_Context.clear();
		handoverRestrictionList.clear();
		locationReportingInformation.clear();
		managBasedMDTallowed.clear();
		managBasedMDTPLMNList.clear();
		iE_Extensions.clear();

	};
	private:
	mME_UE_S1AP_ID_t	mME_UE_S1AP_ID;
	uESecurityCapabilities_t	uESecurityCapabilities;
	aS_SecurityInformation_t	aS_SecurityInformation;
	uEaggregateMaximumBitRate_t	uEaggregateMaximumBitRate;
	subscriberProfileIDforRFP_t	subscriberProfileIDforRFP;
	e_RABs_ToBeSetup_ListRetrieve_t	e_RABs_ToBeSetup_ListRetrieve;
	rRC_Context_t	rRC_Context;
	handoverRestrictionList_t	handoverRestrictionList;
	locationReportingInformation_t	locationReportingInformation;
	managBasedMDTallowed_t	managBasedMDTallowed;
	managBasedMDTPLMNList_t	managBasedMDTPLMNList;
	iE_Extensions_t	iE_Extensions;

};
/*
RetrieveUEContextResponse-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-New-eNB-UE-X2AP-ID				CRITICALITY ignore	TYPE UE-X2AP-ID							PRESENCE mandatory}|
	{ ID id-New-eNB-UE-X2AP-ID-Extension	CRITICALITY ignore	TYPE UE-X2AP-ID-Extension				PRESENCE optional}|
	{ ID id-Old-eNB-UE-X2AP-ID				CRITICALITY ignore	TYPE UE-X2AP-ID							PRESENCE mandatory}|
	{ ID id-Old-eNB-UE-X2AP-ID-Extension	CRITICALITY ignore	TYPE UE-X2AP-ID-Extension				PRESENCE optional}|
	{ ID id-GUMMEI-ID						CRITICALITY reject	TYPE GUMMEI								PRESENCE mandatory}|
	{ ID id-UE-ContextInformationRetrieve	CRITICALITY reject	TYPE UE-ContextInformationRetrieve	PRESENCE mandatory}|
	{ ID id-TraceActivation					CRITICALITY ignore	TYPE TraceActivation					PRESENCE optional}|
	{ ID id-SRVCCOperationPossible			CRITICALITY ignore	TYPE SRVCCOperationPossible				PRESENCE optional}|
	{ ID id-Masked-IMEISV					CRITICALITY ignore	TYPE Masked-IMEISV						PRESENCE optional}|
	{ ID id-ExpectedUEBehaviour				CRITICALITY ignore	TYPE ExpectedUEBehaviour				PRESENCE optional}|
	{ ID id-ProSeAuthorized					CRITICALITY ignore	TYPE ProSeAuthorized					PRESENCE optional}|
	{ ID id-CriticalityDiagnostics			CRITICALITY ignore	TYPE CriticalityDiagnostics				PRESENCE optional}|
	{ ID id-V2XServicesAuthorized			CRITICALITY ignore	TYPE V2XServicesAuthorized				PRESENCE optional}|
	{ ID id-AerialUEsubscriptionInformation	CRITICALITY ignore	TYPE AerialUEsubscriptionInformation	PRESENCE optional}|
	{ ID id-Subscription-Based-UE-DifferentiationInfo			CRITICALITY ignore	TYPE Subscription-Based-UE-DifferentiationInfo				PRESENCE optional},
	...
}
*/

struct RetrieveUEContextResponse_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 16; }
		void clear() {type = 0;}
		void select_id_New_eNB_UE_X2AP_ID() { set(id_New_eNB_UE_X2AP_ID); type=1;}
		void select_id_New_eNB_UE_X2AP_ID_Extension() { set(id_New_eNB_UE_X2AP_ID_Extension); type=2;}
		void select_id_Old_eNB_UE_X2AP_ID() { set(id_Old_eNB_UE_X2AP_ID); type=3;}
		void select_id_Old_eNB_UE_X2AP_ID_Extension() { set(id_Old_eNB_UE_X2AP_ID_Extension); type=4;}
		void select_id_GUMMEI_ID() { set(id_GUMMEI_ID); type=5;}
		void select_id_UE_ContextInformationRetrieve() { set(id_UE_ContextInformationRetrieve); type=6;}
		void select_id_TraceActivation() { set(id_TraceActivation); type=7;}
		void select_id_SRVCCOperationPossible() { set(id_SRVCCOperationPossible); type=8;}
		void select_id_Masked_IMEISV() { set(id_Masked_IMEISV); type=9;}
		void select_id_ExpectedUEBehaviour() { set(id_ExpectedUEBehaviour); type=10;}
		void select_id_ProSeAuthorized() { set(id_ProSeAuthorized); type=11;}
		void select_id_CriticalityDiagnostics() { set(id_CriticalityDiagnostics); type=12;}
		void select_id_V2XServicesAuthorized() { set(id_V2XServicesAuthorized); type=13;}
		void select_id_AerialUEsubscriptionInformation() { set(id_AerialUEsubscriptionInformation); type=14;}
		void select_id_Subscription_Based_UE_DifferentiationInfo() { set(id_Subscription_Based_UE_DifferentiationInfo); type=15;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_New_eNB_UE_X2AP_ID)) { type = 1; return true; }
			else if(equal(id_New_eNB_UE_X2AP_ID_Extension)) { type = 2; return true; }
			else if(equal(id_Old_eNB_UE_X2AP_ID)) { type = 3; return true; }
			else if(equal(id_Old_eNB_UE_X2AP_ID_Extension)) { type = 4; return true; }
			else if(equal(id_GUMMEI_ID)) { type = 5; return true; }
			else if(equal(id_UE_ContextInformationRetrieve)) { type = 6; return true; }
			else if(equal(id_TraceActivation)) { type = 7; return true; }
			else if(equal(id_SRVCCOperationPossible)) { type = 8; return true; }
			else if(equal(id_Masked_IMEISV)) { type = 9; return true; }
			else if(equal(id_ExpectedUEBehaviour)) { type = 10; return true; }
			else if(equal(id_ProSeAuthorized)) { type = 11; return true; }
			else if(equal(id_CriticalityDiagnostics)) { type = 12; return true; }
			else if(equal(id_V2XServicesAuthorized)) { type = 13; return true; }
			else if(equal(id_AerialUEsubscriptionInformation)) { type = 14; return true; }
			else if(equal(id_Subscription_Based_UE_DifferentiationInfo)) { type = 15; return true; }
			else { type = 16; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_New_eNB_UE_X2AP_ID);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_New_eNB_UE_X2AP_ID_Extension);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_Old_eNB_UE_X2AP_ID);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(id_Old_eNB_UE_X2AP_ID_Extension);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(id_GUMMEI_ID);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(id_UE_ContextInformationRetrieve);} return false;
			case 7: type = 7; if(v(ref_nested())) { return equal(id_TraceActivation);} return false;
			case 8: type = 8; if(v(ref_nested())) { return equal(id_SRVCCOperationPossible);} return false;
			case 9: type = 9; if(v(ref_nested())) { return equal(id_Masked_IMEISV);} return false;
			case 10: type = 10; if(v(ref_nested())) { return equal(id_ExpectedUEBehaviour);} return false;
			case 11: type = 11; if(v(ref_nested())) { return equal(id_ProSeAuthorized);} return false;
			case 12: type = 12; if(v(ref_nested())) { return equal(id_CriticalityDiagnostics);} return false;
			case 13: type = 13; if(v(ref_nested())) { return equal(id_V2XServicesAuthorized);} return false;
			case 14: type = 14; if(v(ref_nested())) { return equal(id_AerialUEsubscriptionInformation);} return false;
			case 15: type = 15; if(v(ref_nested())) { return equal(id_Subscription_Based_UE_DifferentiationInfo);} return false;
			case 16: type = 16; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 16; }
		void clear() {type = 0;}
		void select_id_New_eNB_UE_X2AP_ID() { set(ignore); type=1;}
		void select_id_New_eNB_UE_X2AP_ID_Extension() { set(ignore); type=2;}
		void select_id_Old_eNB_UE_X2AP_ID() { set(ignore); type=3;}
		void select_id_Old_eNB_UE_X2AP_ID_Extension() { set(ignore); type=4;}
		void select_id_GUMMEI_ID() { set(reject); type=5;}
		void select_id_UE_ContextInformationRetrieve() { set(reject); type=6;}
		void select_id_TraceActivation() { set(ignore); type=7;}
		void select_id_SRVCCOperationPossible() { set(ignore); type=8;}
		void select_id_Masked_IMEISV() { set(ignore); type=9;}
		void select_id_ExpectedUEBehaviour() { set(ignore); type=10;}
		void select_id_ProSeAuthorized() { set(ignore); type=11;}
		void select_id_CriticalityDiagnostics() { set(ignore); type=12;}
		void select_id_V2XServicesAuthorized() { set(ignore); type=13;}
		void select_id_AerialUEsubscriptionInformation() { set(ignore); type=14;}
		void select_id_Subscription_Based_UE_DifferentiationInfo() { set(ignore); type=15;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else if(equal(ignore)) { type = 2; return true; }
			else if(equal(ignore)) { type = 3; return true; }
			else if(equal(ignore)) { type = 4; return true; }
			else if(equal(reject)) { type = 5; return true; }
			else if(equal(reject)) { type = 6; return true; }
			else if(equal(ignore)) { type = 7; return true; }
			else if(equal(ignore)) { type = 8; return true; }
			else if(equal(ignore)) { type = 9; return true; }
			else if(equal(ignore)) { type = 10; return true; }
			else if(equal(ignore)) { type = 11; return true; }
			else if(equal(ignore)) { type = 12; return true; }
			else if(equal(ignore)) { type = 13; return true; }
			else if(equal(ignore)) { type = 14; return true; }
			else if(equal(ignore)) { type = 15; return true; }
			else { type = 16; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(ignore);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(ignore);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(ignore);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(reject);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(reject);} return false;
			case 7: type = 7; if(v(ref_nested())) { return equal(ignore);} return false;
			case 8: type = 8; if(v(ref_nested())) { return equal(ignore);} return false;
			case 9: type = 9; if(v(ref_nested())) { return equal(ignore);} return false;
			case 10: type = 10; if(v(ref_nested())) { return equal(ignore);} return false;
			case 11: type = 11; if(v(ref_nested())) { return equal(ignore);} return false;
			case 12: type = 12; if(v(ref_nested())) { return equal(ignore);} return false;
			case 13: type = 13; if(v(ref_nested())) { return equal(ignore);} return false;
			case 14: type = 14; if(v(ref_nested())) { return equal(ignore);} return false;
			case 15: type = 15; if(v(ref_nested())) { return equal(ignore);} return false;
			case 16: type = 16; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		UE_X2AP_ID& select_id_New_eNB_UE_X2AP_ID() { return set<UE_X2AP_ID>(1); }
		UE_X2AP_ID const* get_id_New_eNB_UE_X2AP_ID() const { return get<UE_X2AP_ID>(1); }
		UE_X2AP_ID_Extension& select_id_New_eNB_UE_X2AP_ID_Extension() { return set<UE_X2AP_ID_Extension>(2); }
		UE_X2AP_ID_Extension const* get_id_New_eNB_UE_X2AP_ID_Extension() const { return get<UE_X2AP_ID_Extension>(2); }
		UE_X2AP_ID& select_id_Old_eNB_UE_X2AP_ID() { return set<UE_X2AP_ID>(3); }
		UE_X2AP_ID const* get_id_Old_eNB_UE_X2AP_ID() const { return get<UE_X2AP_ID>(3); }
		UE_X2AP_ID_Extension& select_id_Old_eNB_UE_X2AP_ID_Extension() { return set<UE_X2AP_ID_Extension>(4); }
		UE_X2AP_ID_Extension const* get_id_Old_eNB_UE_X2AP_ID_Extension() const { return get<UE_X2AP_ID_Extension>(4); }
		GUMMEI& select_id_GUMMEI_ID() { return set<GUMMEI>(5); }
		GUMMEI const* get_id_GUMMEI_ID() const { return get<GUMMEI>(5); }
		UE_ContextInformationRetrieve& select_id_UE_ContextInformationRetrieve() { return set<UE_ContextInformationRetrieve>(6); }
		UE_ContextInformationRetrieve const* get_id_UE_ContextInformationRetrieve() const { return get<UE_ContextInformationRetrieve>(6); }
		TraceActivation& select_id_TraceActivation() { return set<TraceActivation>(7); }
		TraceActivation const* get_id_TraceActivation() const { return get<TraceActivation>(7); }
		SRVCCOperationPossible& select_id_SRVCCOperationPossible() { return set<SRVCCOperationPossible>(8); }
		SRVCCOperationPossible const* get_id_SRVCCOperationPossible() const { return get<SRVCCOperationPossible>(8); }
		Masked_IMEISV& select_id_Masked_IMEISV() { return set<Masked_IMEISV>(9); }
		Masked_IMEISV const* get_id_Masked_IMEISV() const { return get<Masked_IMEISV>(9); }
		ExpectedUEBehaviour& select_id_ExpectedUEBehaviour() { return set<ExpectedUEBehaviour>(10); }
		ExpectedUEBehaviour const* get_id_ExpectedUEBehaviour() const { return get<ExpectedUEBehaviour>(10); }
		ProSeAuthorized& select_id_ProSeAuthorized() { return set<ProSeAuthorized>(11); }
		ProSeAuthorized const* get_id_ProSeAuthorized() const { return get<ProSeAuthorized>(11); }
		CriticalityDiagnostics& select_id_CriticalityDiagnostics() { return set<CriticalityDiagnostics>(12); }
		CriticalityDiagnostics const* get_id_CriticalityDiagnostics() const { return get<CriticalityDiagnostics>(12); }
		V2XServicesAuthorized& select_id_V2XServicesAuthorized() { return set<V2XServicesAuthorized>(13); }
		V2XServicesAuthorized const* get_id_V2XServicesAuthorized() const { return get<V2XServicesAuthorized>(13); }
		AerialUEsubscriptionInformation& select_id_AerialUEsubscriptionInformation() { return set<AerialUEsubscriptionInformation>(14); }
		AerialUEsubscriptionInformation const* get_id_AerialUEsubscriptionInformation() const { return get<AerialUEsubscriptionInformation>(14); }
		Subscription_Based_UE_DifferentiationInfo& select_id_Subscription_Based_UE_DifferentiationInfo() { return set<Subscription_Based_UE_DifferentiationInfo>(15); }
		Subscription_Based_UE_DifferentiationInfo const* get_id_Subscription_Based_UE_DifferentiationInfo() const { return get<Subscription_Based_UE_DifferentiationInfo>(15); }
		bool is_unknown() const { return type == 16; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<UE_X2AP_ID>(); break;
			case 2: var.destroy<UE_X2AP_ID_Extension>(); break;
			case 3: var.destroy<UE_X2AP_ID>(); break;
			case 4: var.destroy<UE_X2AP_ID_Extension>(); break;
			case 5: var.destroy<GUMMEI>(); break;
			case 6: var.destroy<UE_ContextInformationRetrieve>(); break;
			case 7: var.destroy<TraceActivation>(); break;
			case 8: var.destroy<SRVCCOperationPossible>(); break;
			case 9: var.destroy<Masked_IMEISV>(); break;
			case 10: var.destroy<ExpectedUEBehaviour>(); break;
			case 11: var.destroy<ProSeAuthorized>(); break;
			case 12: var.destroy<CriticalityDiagnostics>(); break;
			case 13: var.destroy<V2XServicesAuthorized>(); break;
			case 14: var.destroy<AerialUEsubscriptionInformation>(); break;
			case 15: var.destroy<Subscription_Based_UE_DifferentiationInfo>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<UE_X2AP_ID>(1);
			v.template operator()<UE_X2AP_ID_Extension>(2);
			v.template operator()<UE_X2AP_ID>(3);
			v.template operator()<UE_X2AP_ID_Extension>(4);
			v.template operator()<GUMMEI>(5);
			v.template operator()<UE_ContextInformationRetrieve>(6);
			v.template operator()<TraceActivation>(7);
			v.template operator()<SRVCCOperationPossible>(8);
			v.template operator()<Masked_IMEISV>(9);
			v.template operator()<ExpectedUEBehaviour>(10);
			v.template operator()<ProSeAuthorized>(11);
			v.template operator()<CriticalityDiagnostics>(12);
			v.template operator()<V2XServicesAuthorized>(13);
			v.template operator()<AerialUEsubscriptionInformation>(14);
			v.template operator()<Subscription_Based_UE_DifferentiationInfo>(15);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_New_eNB_UE_X2AP_ID()); return true;
			case 2: v(select_id_New_eNB_UE_X2AP_ID_Extension()); return true;
			case 3: v(select_id_Old_eNB_UE_X2AP_ID()); return true;
			case 4: v(select_id_Old_eNB_UE_X2AP_ID_Extension()); return true;
			case 5: v(select_id_GUMMEI_ID()); return true;
			case 6: v(select_id_UE_ContextInformationRetrieve()); return true;
			case 7: v(select_id_TraceActivation()); return true;
			case 8: v(select_id_SRVCCOperationPossible()); return true;
			case 9: v(select_id_Masked_IMEISV()); return true;
			case 10: v(select_id_ExpectedUEBehaviour()); return true;
			case 11: v(select_id_ProSeAuthorized()); return true;
			case 12: v(select_id_CriticalityDiagnostics()); return true;
			case 13: v(select_id_V2XServicesAuthorized()); return true;
			case 14: v(select_id_AerialUEsubscriptionInformation()); return true;
			case 15: v(select_id_Subscription_Based_UE_DifferentiationInfo()); return true;
			case 16: if(type != 16) {clear(); asn::base::set();} type = 16; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<UE_X2AP_ID>()); return true;
			case 2: v(var.as<UE_X2AP_ID_Extension>()); return true;
			case 3: v(var.as<UE_X2AP_ID>()); return true;
			case 4: v(var.as<UE_X2AP_ID_Extension>()); return true;
			case 5: v(var.as<GUMMEI>()); return true;
			case 6: v(var.as<UE_ContextInformationRetrieve>()); return true;
			case 7: v(var.as<TraceActivation>()); return true;
			case 8: v(var.as<SRVCCOperationPossible>()); return true;
			case 9: v(var.as<Masked_IMEISV>()); return true;
			case 10: v(var.as<ExpectedUEBehaviour>()); return true;
			case 11: v(var.as<ProSeAuthorized>()); return true;
			case 12: v(var.as<CriticalityDiagnostics>()); return true;
			case 13: v(var.as<V2XServicesAuthorized>()); return true;
			case 14: v(var.as<AerialUEsubscriptionInformation>()); return true;
			case 15: v(var.as<Subscription_Based_UE_DifferentiationInfo>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(AerialUEsubscriptionInformation)];
			char dummy2[sizeof(CriticalityDiagnostics)];
			char dummy3[sizeof(ExpectedUEBehaviour)];
			char dummy4[sizeof(GUMMEI)];
			char dummy5[sizeof(Masked_IMEISV)];
			char dummy6[sizeof(ProSeAuthorized)];
			char dummy7[sizeof(SRVCCOperationPossible)];
			char dummy8[sizeof(Subscription_Based_UE_DifferentiationInfo)];
			char dummy9[sizeof(TraceActivation)];
			char dummy10[sizeof(UE_ContextInformationRetrieve)];
			char dummy11[sizeof(UE_X2AP_ID)];
			char dummy12[sizeof(UE_X2AP_ID_Extension)];
			char dummy13[sizeof(V2XServicesAuthorized)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 16; }
		void clear() {type = 0;}
		void select_id_New_eNB_UE_X2AP_ID() { set(mandatory); type=1;}
		void select_id_New_eNB_UE_X2AP_ID_Extension() { set(optional); type=2;}
		void select_id_Old_eNB_UE_X2AP_ID() { set(mandatory); type=3;}
		void select_id_Old_eNB_UE_X2AP_ID_Extension() { set(optional); type=4;}
		void select_id_GUMMEI_ID() { set(mandatory); type=5;}
		void select_id_UE_ContextInformationRetrieve() { set(mandatory); type=6;}
		void select_id_TraceActivation() { set(optional); type=7;}
		void select_id_SRVCCOperationPossible() { set(optional); type=8;}
		void select_id_Masked_IMEISV() { set(optional); type=9;}
		void select_id_ExpectedUEBehaviour() { set(optional); type=10;}
		void select_id_ProSeAuthorized() { set(optional); type=11;}
		void select_id_CriticalityDiagnostics() { set(optional); type=12;}
		void select_id_V2XServicesAuthorized() { set(optional); type=13;}
		void select_id_AerialUEsubscriptionInformation() { set(optional); type=14;}
		void select_id_Subscription_Based_UE_DifferentiationInfo() { set(optional); type=15;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(optional)) { type = 2; return true; }
			else if(equal(mandatory)) { type = 3; return true; }
			else if(equal(optional)) { type = 4; return true; }
			else if(equal(mandatory)) { type = 5; return true; }
			else if(equal(mandatory)) { type = 6; return true; }
			else if(equal(optional)) { type = 7; return true; }
			else if(equal(optional)) { type = 8; return true; }
			else if(equal(optional)) { type = 9; return true; }
			else if(equal(optional)) { type = 10; return true; }
			else if(equal(optional)) { type = 11; return true; }
			else if(equal(optional)) { type = 12; return true; }
			else if(equal(optional)) { type = 13; return true; }
			else if(equal(optional)) { type = 14; return true; }
			else if(equal(optional)) { type = 15; return true; }
			else { type = 16; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(optional);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(optional);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 7: type = 7; if(v(ref_nested())) { return equal(optional);} return false;
			case 8: type = 8; if(v(ref_nested())) { return equal(optional);} return false;
			case 9: type = 9; if(v(ref_nested())) { return equal(optional);} return false;
			case 10: type = 10; if(v(ref_nested())) { return equal(optional);} return false;
			case 11: type = 11; if(v(ref_nested())) { return equal(optional);} return false;
			case 12: type = 12; if(v(ref_nested())) { return equal(optional);} return false;
			case 13: type = 13; if(v(ref_nested())) { return equal(optional);} return false;
			case 14: type = 14; if(v(ref_nested())) { return equal(optional);} return false;
			case 15: type = 15; if(v(ref_nested())) { return equal(optional);} return false;
			case 16: type = 16; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
RetrieveUEContextResponse ::= SEQUENCE {
	protocolIEs			ProtocolIE-Container	{{ RetrieveUEContextResponse-IEs}},
	...
}
*/

struct RetrieveUEContextResponse : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "RetrieveUEContextResponse";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<RetrieveUEContextResponse_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<RetrieveUEContextResponse_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
SNStatusTransfer-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-Old-eNB-UE-X2AP-ID						CRITICALITY reject	TYPE UE-X2AP-ID										PRESENCE mandatory}|
	{ ID id-New-eNB-UE-X2AP-ID						CRITICALITY reject	TYPE UE-X2AP-ID										PRESENCE mandatory}|
	{ ID id-E-RABs-SubjectToStatusTransfer-List		CRITICALITY ignore	TYPE E-RABs-SubjectToStatusTransfer-List		PRESENCE mandatory}|
	{ ID id-Old-eNB-UE-X2AP-ID-Extension			CRITICALITY reject	TYPE UE-X2AP-ID-Extension							PRESENCE optional}|
	{ ID id-New-eNB-UE-X2AP-ID-Extension			CRITICALITY reject	TYPE UE-X2AP-ID-Extension							PRESENCE optional}|
	{ ID id-SgNB-UE-X2AP-ID							CRITICALITY ignore	TYPE SgNB-UE-X2AP-ID									PRESENCE optional},
	...
}
*/

struct SNStatusTransfer_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 7; }
		void clear() {type = 0;}
		void select_id_Old_eNB_UE_X2AP_ID() { set(id_Old_eNB_UE_X2AP_ID); type=1;}
		void select_id_New_eNB_UE_X2AP_ID() { set(id_New_eNB_UE_X2AP_ID); type=2;}
		void select_id_E_RABs_SubjectToStatusTransfer_List() { set(id_E_RABs_SubjectToStatusTransfer_List); type=3;}
		void select_id_Old_eNB_UE_X2AP_ID_Extension() { set(id_Old_eNB_UE_X2AP_ID_Extension); type=4;}
		void select_id_New_eNB_UE_X2AP_ID_Extension() { set(id_New_eNB_UE_X2AP_ID_Extension); type=5;}
		void select_id_SgNB_UE_X2AP_ID() { set(id_SgNB_UE_X2AP_ID); type=6;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_Old_eNB_UE_X2AP_ID)) { type = 1; return true; }
			else if(equal(id_New_eNB_UE_X2AP_ID)) { type = 2; return true; }
			else if(equal(id_E_RABs_SubjectToStatusTransfer_List)) { type = 3; return true; }
			else if(equal(id_Old_eNB_UE_X2AP_ID_Extension)) { type = 4; return true; }
			else if(equal(id_New_eNB_UE_X2AP_ID_Extension)) { type = 5; return true; }
			else if(equal(id_SgNB_UE_X2AP_ID)) { type = 6; return true; }
			else { type = 7; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_Old_eNB_UE_X2AP_ID);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_New_eNB_UE_X2AP_ID);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_E_RABs_SubjectToStatusTransfer_List);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(id_Old_eNB_UE_X2AP_ID_Extension);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(id_New_eNB_UE_X2AP_ID_Extension);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(id_SgNB_UE_X2AP_ID);} return false;
			case 7: type = 7; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 7; }
		void clear() {type = 0;}
		void select_id_Old_eNB_UE_X2AP_ID() { set(reject); type=1;}
		void select_id_New_eNB_UE_X2AP_ID() { set(reject); type=2;}
		void select_id_E_RABs_SubjectToStatusTransfer_List() { set(ignore); type=3;}
		void select_id_Old_eNB_UE_X2AP_ID_Extension() { set(reject); type=4;}
		void select_id_New_eNB_UE_X2AP_ID_Extension() { set(reject); type=5;}
		void select_id_SgNB_UE_X2AP_ID() { set(ignore); type=6;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else if(equal(reject)) { type = 2; return true; }
			else if(equal(ignore)) { type = 3; return true; }
			else if(equal(reject)) { type = 4; return true; }
			else if(equal(reject)) { type = 5; return true; }
			else if(equal(ignore)) { type = 6; return true; }
			else { type = 7; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(reject);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(ignore);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(reject);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(reject);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(ignore);} return false;
			case 7: type = 7; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		UE_X2AP_ID& select_id_Old_eNB_UE_X2AP_ID() { return set<UE_X2AP_ID>(1); }
		UE_X2AP_ID const* get_id_Old_eNB_UE_X2AP_ID() const { return get<UE_X2AP_ID>(1); }
		UE_X2AP_ID& select_id_New_eNB_UE_X2AP_ID() { return set<UE_X2AP_ID>(2); }
		UE_X2AP_ID const* get_id_New_eNB_UE_X2AP_ID() const { return get<UE_X2AP_ID>(2); }
		E_RABs_SubjectToStatusTransfer_List& select_id_E_RABs_SubjectToStatusTransfer_List() { return set<E_RABs_SubjectToStatusTransfer_List>(3); }
		E_RABs_SubjectToStatusTransfer_List const* get_id_E_RABs_SubjectToStatusTransfer_List() const { return get<E_RABs_SubjectToStatusTransfer_List>(3); }
		UE_X2AP_ID_Extension& select_id_Old_eNB_UE_X2AP_ID_Extension() { return set<UE_X2AP_ID_Extension>(4); }
		UE_X2AP_ID_Extension const* get_id_Old_eNB_UE_X2AP_ID_Extension() const { return get<UE_X2AP_ID_Extension>(4); }
		UE_X2AP_ID_Extension& select_id_New_eNB_UE_X2AP_ID_Extension() { return set<UE_X2AP_ID_Extension>(5); }
		UE_X2AP_ID_Extension const* get_id_New_eNB_UE_X2AP_ID_Extension() const { return get<UE_X2AP_ID_Extension>(5); }
		SgNB_UE_X2AP_ID& select_id_SgNB_UE_X2AP_ID() { return set<SgNB_UE_X2AP_ID>(6); }
		SgNB_UE_X2AP_ID const* get_id_SgNB_UE_X2AP_ID() const { return get<SgNB_UE_X2AP_ID>(6); }
		bool is_unknown() const { return type == 7; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<UE_X2AP_ID>(); break;
			case 2: var.destroy<UE_X2AP_ID>(); break;
			case 3: var.destroy<E_RABs_SubjectToStatusTransfer_List>(); break;
			case 4: var.destroy<UE_X2AP_ID_Extension>(); break;
			case 5: var.destroy<UE_X2AP_ID_Extension>(); break;
			case 6: var.destroy<SgNB_UE_X2AP_ID>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<UE_X2AP_ID>(1);
			v.template operator()<UE_X2AP_ID>(2);
			v.template operator()<E_RABs_SubjectToStatusTransfer_List>(3);
			v.template operator()<UE_X2AP_ID_Extension>(4);
			v.template operator()<UE_X2AP_ID_Extension>(5);
			v.template operator()<SgNB_UE_X2AP_ID>(6);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_Old_eNB_UE_X2AP_ID()); return true;
			case 2: v(select_id_New_eNB_UE_X2AP_ID()); return true;
			case 3: v(select_id_E_RABs_SubjectToStatusTransfer_List()); return true;
			case 4: v(select_id_Old_eNB_UE_X2AP_ID_Extension()); return true;
			case 5: v(select_id_New_eNB_UE_X2AP_ID_Extension()); return true;
			case 6: v(select_id_SgNB_UE_X2AP_ID()); return true;
			case 7: if(type != 7) {clear(); asn::base::set();} type = 7; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<UE_X2AP_ID>()); return true;
			case 2: v(var.as<UE_X2AP_ID>()); return true;
			case 3: v(var.as<E_RABs_SubjectToStatusTransfer_List>()); return true;
			case 4: v(var.as<UE_X2AP_ID_Extension>()); return true;
			case 5: v(var.as<UE_X2AP_ID_Extension>()); return true;
			case 6: v(var.as<SgNB_UE_X2AP_ID>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(E_RABs_SubjectToStatusTransfer_List)];
			char dummy2[sizeof(SgNB_UE_X2AP_ID)];
			char dummy3[sizeof(UE_X2AP_ID)];
			char dummy4[sizeof(UE_X2AP_ID_Extension)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 7; }
		void clear() {type = 0;}
		void select_id_Old_eNB_UE_X2AP_ID() { set(mandatory); type=1;}
		void select_id_New_eNB_UE_X2AP_ID() { set(mandatory); type=2;}
		void select_id_E_RABs_SubjectToStatusTransfer_List() { set(mandatory); type=3;}
		void select_id_Old_eNB_UE_X2AP_ID_Extension() { set(optional); type=4;}
		void select_id_New_eNB_UE_X2AP_ID_Extension() { set(optional); type=5;}
		void select_id_SgNB_UE_X2AP_ID() { set(optional); type=6;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(mandatory)) { type = 2; return true; }
			else if(equal(mandatory)) { type = 3; return true; }
			else if(equal(optional)) { type = 4; return true; }
			else if(equal(optional)) { type = 5; return true; }
			else if(equal(optional)) { type = 6; return true; }
			else { type = 7; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(optional);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(optional);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(optional);} return false;
			case 7: type = 7; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
SNStatusTransfer ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{SNStatusTransfer-IEs}},
	...
}
*/

struct SNStatusTransfer : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "SNStatusTransfer";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<SNStatusTransfer_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<SNStatusTransfer_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
SeNBAdditionRequest-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-MeNB-UE-X2AP-ID					CRITICALITY reject	TYPE UE-X2AP-ID							PRESENCE mandatory}|
	{ ID id-UE-SecurityCapabilities			CRITICALITY reject	TYPE UESecurityCapabilities				PRESENCE conditional}|
	-- This IE shall be present if the Bearer Option IE is set to the value SCG bearer --
	{ ID id-SeNBSecurityKey					CRITICALITY reject	TYPE SeNBSecurityKey					PRESENCE conditional}|
	-- This IE shall be present if the Bearer Option IE is set to the value SCG bearer --
	{ ID id-SeNBUEAggregateMaximumBitRate	CRITICALITY reject	TYPE UEAggregateMaximumBitRate			PRESENCE mandatory}|
	{ ID id-ServingPLMN						CRITICALITY ignore	TYPE PLMN-Identity						PRESENCE optional}|
	{ ID id-E-RABs-ToBeAdded-List			CRITICALITY reject	TYPE E-RABs-ToBeAdded-List				PRESENCE mandatory}|
	{ ID id-MeNBtoSeNBContainer				CRITICALITY reject	TYPE MeNBtoSeNBContainer				PRESENCE mandatory}|
	{ ID id-CSGMembershipStatus				CRITICALITY reject	TYPE CSGMembershipStatus				PRESENCE optional}|
	{ ID id-SeNB-UE-X2AP-ID					CRITICALITY reject	TYPE UE-X2AP-ID							PRESENCE optional}|
	{ ID id-SeNB-UE-X2AP-ID-Extension		CRITICALITY reject	TYPE UE-X2AP-ID-Extension				PRESENCE optional}|
	{ ID id-ExpectedUEBehaviour				CRITICALITY ignore	TYPE ExpectedUEBehaviour				PRESENCE optional}|
	{ ID id-MeNB-UE-X2AP-ID-Extension		CRITICALITY reject	TYPE UE-X2AP-ID-Extension				PRESENCE optional},
	...
}
*/

struct SeNBAdditionRequest_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 13; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(id_MeNB_UE_X2AP_ID); type=1;}
		void select_id_UE_SecurityCapabilities() { set(id_UE_SecurityCapabilities); type=2;}
		void select_id_SeNBSecurityKey() { set(id_SeNBSecurityKey); type=3;}
		void select_id_SeNBUEAggregateMaximumBitRate() { set(id_SeNBUEAggregateMaximumBitRate); type=4;}
		void select_id_ServingPLMN() { set(id_ServingPLMN); type=5;}
		void select_id_E_RABs_ToBeAdded_List() { set(id_E_RABs_ToBeAdded_List); type=6;}
		void select_id_MeNBtoSeNBContainer() { set(id_MeNBtoSeNBContainer); type=7;}
		void select_id_CSGMembershipStatus() { set(id_CSGMembershipStatus); type=8;}
		void select_id_SeNB_UE_X2AP_ID() { set(id_SeNB_UE_X2AP_ID); type=9;}
		void select_id_SeNB_UE_X2AP_ID_Extension() { set(id_SeNB_UE_X2AP_ID_Extension); type=10;}
		void select_id_ExpectedUEBehaviour() { set(id_ExpectedUEBehaviour); type=11;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(id_MeNB_UE_X2AP_ID_Extension); type=12;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_MeNB_UE_X2AP_ID)) { type = 1; return true; }
			else if(equal(id_UE_SecurityCapabilities)) { type = 2; return true; }
			else if(equal(id_SeNBSecurityKey)) { type = 3; return true; }
			else if(equal(id_SeNBUEAggregateMaximumBitRate)) { type = 4; return true; }
			else if(equal(id_ServingPLMN)) { type = 5; return true; }
			else if(equal(id_E_RABs_ToBeAdded_List)) { type = 6; return true; }
			else if(equal(id_MeNBtoSeNBContainer)) { type = 7; return true; }
			else if(equal(id_CSGMembershipStatus)) { type = 8; return true; }
			else if(equal(id_SeNB_UE_X2AP_ID)) { type = 9; return true; }
			else if(equal(id_SeNB_UE_X2AP_ID_Extension)) { type = 10; return true; }
			else if(equal(id_ExpectedUEBehaviour)) { type = 11; return true; }
			else if(equal(id_MeNB_UE_X2AP_ID_Extension)) { type = 12; return true; }
			else { type = 13; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_UE_SecurityCapabilities);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_SeNBSecurityKey);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(id_SeNBUEAggregateMaximumBitRate);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(id_ServingPLMN);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(id_E_RABs_ToBeAdded_List);} return false;
			case 7: type = 7; if(v(ref_nested())) { return equal(id_MeNBtoSeNBContainer);} return false;
			case 8: type = 8; if(v(ref_nested())) { return equal(id_CSGMembershipStatus);} return false;
			case 9: type = 9; if(v(ref_nested())) { return equal(id_SeNB_UE_X2AP_ID);} return false;
			case 10: type = 10; if(v(ref_nested())) { return equal(id_SeNB_UE_X2AP_ID_Extension);} return false;
			case 11: type = 11; if(v(ref_nested())) { return equal(id_ExpectedUEBehaviour);} return false;
			case 12: type = 12; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID_Extension);} return false;
			case 13: type = 13; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 13; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(reject); type=1;}
		void select_id_UE_SecurityCapabilities() { set(reject); type=2;}
		void select_id_SeNBSecurityKey() { set(reject); type=3;}
		void select_id_SeNBUEAggregateMaximumBitRate() { set(reject); type=4;}
		void select_id_ServingPLMN() { set(ignore); type=5;}
		void select_id_E_RABs_ToBeAdded_List() { set(reject); type=6;}
		void select_id_MeNBtoSeNBContainer() { set(reject); type=7;}
		void select_id_CSGMembershipStatus() { set(reject); type=8;}
		void select_id_SeNB_UE_X2AP_ID() { set(reject); type=9;}
		void select_id_SeNB_UE_X2AP_ID_Extension() { set(reject); type=10;}
		void select_id_ExpectedUEBehaviour() { set(ignore); type=11;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(reject); type=12;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else if(equal(reject)) { type = 2; return true; }
			else if(equal(reject)) { type = 3; return true; }
			else if(equal(reject)) { type = 4; return true; }
			else if(equal(ignore)) { type = 5; return true; }
			else if(equal(reject)) { type = 6; return true; }
			else if(equal(reject)) { type = 7; return true; }
			else if(equal(reject)) { type = 8; return true; }
			else if(equal(reject)) { type = 9; return true; }
			else if(equal(reject)) { type = 10; return true; }
			else if(equal(ignore)) { type = 11; return true; }
			else if(equal(reject)) { type = 12; return true; }
			else { type = 13; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(reject);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(reject);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(reject);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(ignore);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(reject);} return false;
			case 7: type = 7; if(v(ref_nested())) { return equal(reject);} return false;
			case 8: type = 8; if(v(ref_nested())) { return equal(reject);} return false;
			case 9: type = 9; if(v(ref_nested())) { return equal(reject);} return false;
			case 10: type = 10; if(v(ref_nested())) { return equal(reject);} return false;
			case 11: type = 11; if(v(ref_nested())) { return equal(ignore);} return false;
			case 12: type = 12; if(v(ref_nested())) { return equal(reject);} return false;
			case 13: type = 13; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		UE_X2AP_ID& select_id_MeNB_UE_X2AP_ID() { return set<UE_X2AP_ID>(1); }
		UE_X2AP_ID const* get_id_MeNB_UE_X2AP_ID() const { return get<UE_X2AP_ID>(1); }
		UESecurityCapabilities& select_id_UE_SecurityCapabilities() { return set<UESecurityCapabilities>(2); }
		UESecurityCapabilities const* get_id_UE_SecurityCapabilities() const { return get<UESecurityCapabilities>(2); }
		SeNBSecurityKey& select_id_SeNBSecurityKey() { return set<SeNBSecurityKey>(3); }
		SeNBSecurityKey const* get_id_SeNBSecurityKey() const { return get<SeNBSecurityKey>(3); }
		UEAggregateMaximumBitRate& select_id_SeNBUEAggregateMaximumBitRate() { return set<UEAggregateMaximumBitRate>(4); }
		UEAggregateMaximumBitRate const* get_id_SeNBUEAggregateMaximumBitRate() const { return get<UEAggregateMaximumBitRate>(4); }
		PLMN_Identity& select_id_ServingPLMN() { return set<PLMN_Identity>(5); }
		PLMN_Identity const* get_id_ServingPLMN() const { return get<PLMN_Identity>(5); }
		E_RABs_ToBeAdded_List& select_id_E_RABs_ToBeAdded_List() { return set<E_RABs_ToBeAdded_List>(6); }
		E_RABs_ToBeAdded_List const* get_id_E_RABs_ToBeAdded_List() const { return get<E_RABs_ToBeAdded_List>(6); }
		MeNBtoSeNBContainer& select_id_MeNBtoSeNBContainer() { return set<MeNBtoSeNBContainer>(7); }
		MeNBtoSeNBContainer const* get_id_MeNBtoSeNBContainer() const { return get<MeNBtoSeNBContainer>(7); }
		CSGMembershipStatus& select_id_CSGMembershipStatus() { return set<CSGMembershipStatus>(8); }
		CSGMembershipStatus const* get_id_CSGMembershipStatus() const { return get<CSGMembershipStatus>(8); }
		UE_X2AP_ID& select_id_SeNB_UE_X2AP_ID() { return set<UE_X2AP_ID>(9); }
		UE_X2AP_ID const* get_id_SeNB_UE_X2AP_ID() const { return get<UE_X2AP_ID>(9); }
		UE_X2AP_ID_Extension& select_id_SeNB_UE_X2AP_ID_Extension() { return set<UE_X2AP_ID_Extension>(10); }
		UE_X2AP_ID_Extension const* get_id_SeNB_UE_X2AP_ID_Extension() const { return get<UE_X2AP_ID_Extension>(10); }
		ExpectedUEBehaviour& select_id_ExpectedUEBehaviour() { return set<ExpectedUEBehaviour>(11); }
		ExpectedUEBehaviour const* get_id_ExpectedUEBehaviour() const { return get<ExpectedUEBehaviour>(11); }
		UE_X2AP_ID_Extension& select_id_MeNB_UE_X2AP_ID_Extension() { return set<UE_X2AP_ID_Extension>(12); }
		UE_X2AP_ID_Extension const* get_id_MeNB_UE_X2AP_ID_Extension() const { return get<UE_X2AP_ID_Extension>(12); }
		bool is_unknown() const { return type == 13; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<UE_X2AP_ID>(); break;
			case 2: var.destroy<UESecurityCapabilities>(); break;
			case 3: var.destroy<SeNBSecurityKey>(); break;
			case 4: var.destroy<UEAggregateMaximumBitRate>(); break;
			case 5: var.destroy<PLMN_Identity>(); break;
			case 6: var.destroy<E_RABs_ToBeAdded_List>(); break;
			case 7: var.destroy<MeNBtoSeNBContainer>(); break;
			case 8: var.destroy<CSGMembershipStatus>(); break;
			case 9: var.destroy<UE_X2AP_ID>(); break;
			case 10: var.destroy<UE_X2AP_ID_Extension>(); break;
			case 11: var.destroy<ExpectedUEBehaviour>(); break;
			case 12: var.destroy<UE_X2AP_ID_Extension>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<UE_X2AP_ID>(1);
			v.template operator()<UESecurityCapabilities>(2);
			v.template operator()<SeNBSecurityKey>(3);
			v.template operator()<UEAggregateMaximumBitRate>(4);
			v.template operator()<PLMN_Identity>(5);
			v.template operator()<E_RABs_ToBeAdded_List>(6);
			v.template operator()<MeNBtoSeNBContainer>(7);
			v.template operator()<CSGMembershipStatus>(8);
			v.template operator()<UE_X2AP_ID>(9);
			v.template operator()<UE_X2AP_ID_Extension>(10);
			v.template operator()<ExpectedUEBehaviour>(11);
			v.template operator()<UE_X2AP_ID_Extension>(12);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_MeNB_UE_X2AP_ID()); return true;
			case 2: v(select_id_UE_SecurityCapabilities()); return true;
			case 3: v(select_id_SeNBSecurityKey()); return true;
			case 4: v(select_id_SeNBUEAggregateMaximumBitRate()); return true;
			case 5: v(select_id_ServingPLMN()); return true;
			case 6: v(select_id_E_RABs_ToBeAdded_List()); return true;
			case 7: v(select_id_MeNBtoSeNBContainer()); return true;
			case 8: v(select_id_CSGMembershipStatus()); return true;
			case 9: v(select_id_SeNB_UE_X2AP_ID()); return true;
			case 10: v(select_id_SeNB_UE_X2AP_ID_Extension()); return true;
			case 11: v(select_id_ExpectedUEBehaviour()); return true;
			case 12: v(select_id_MeNB_UE_X2AP_ID_Extension()); return true;
			case 13: if(type != 13) {clear(); asn::base::set();} type = 13; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<UE_X2AP_ID>()); return true;
			case 2: v(var.as<UESecurityCapabilities>()); return true;
			case 3: v(var.as<SeNBSecurityKey>()); return true;
			case 4: v(var.as<UEAggregateMaximumBitRate>()); return true;
			case 5: v(var.as<PLMN_Identity>()); return true;
			case 6: v(var.as<E_RABs_ToBeAdded_List>()); return true;
			case 7: v(var.as<MeNBtoSeNBContainer>()); return true;
			case 8: v(var.as<CSGMembershipStatus>()); return true;
			case 9: v(var.as<UE_X2AP_ID>()); return true;
			case 10: v(var.as<UE_X2AP_ID_Extension>()); return true;
			case 11: v(var.as<ExpectedUEBehaviour>()); return true;
			case 12: v(var.as<UE_X2AP_ID_Extension>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(CSGMembershipStatus)];
			char dummy2[sizeof(E_RABs_ToBeAdded_List)];
			char dummy3[sizeof(ExpectedUEBehaviour)];
			char dummy4[sizeof(MeNBtoSeNBContainer)];
			char dummy5[sizeof(PLMN_Identity)];
			char dummy6[sizeof(SeNBSecurityKey)];
			char dummy7[sizeof(UEAggregateMaximumBitRate)];
			char dummy8[sizeof(UESecurityCapabilities)];
			char dummy9[sizeof(UE_X2AP_ID)];
			char dummy10[sizeof(UE_X2AP_ID_Extension)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 13; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(mandatory); type=1;}
		void select_id_UE_SecurityCapabilities() { set(conditional); type=2;}
		void select_id_SeNBSecurityKey() { set(conditional); type=3;}
		void select_id_SeNBUEAggregateMaximumBitRate() { set(mandatory); type=4;}
		void select_id_ServingPLMN() { set(optional); type=5;}
		void select_id_E_RABs_ToBeAdded_List() { set(mandatory); type=6;}
		void select_id_MeNBtoSeNBContainer() { set(mandatory); type=7;}
		void select_id_CSGMembershipStatus() { set(optional); type=8;}
		void select_id_SeNB_UE_X2AP_ID() { set(optional); type=9;}
		void select_id_SeNB_UE_X2AP_ID_Extension() { set(optional); type=10;}
		void select_id_ExpectedUEBehaviour() { set(optional); type=11;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(optional); type=12;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(conditional)) { type = 2; return true; }
			else if(equal(conditional)) { type = 3; return true; }
			else if(equal(mandatory)) { type = 4; return true; }
			else if(equal(optional)) { type = 5; return true; }
			else if(equal(mandatory)) { type = 6; return true; }
			else if(equal(mandatory)) { type = 7; return true; }
			else if(equal(optional)) { type = 8; return true; }
			else if(equal(optional)) { type = 9; return true; }
			else if(equal(optional)) { type = 10; return true; }
			else if(equal(optional)) { type = 11; return true; }
			else if(equal(optional)) { type = 12; return true; }
			else { type = 13; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(conditional);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(conditional);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(optional);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 7: type = 7; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 8: type = 8; if(v(ref_nested())) { return equal(optional);} return false;
			case 9: type = 9; if(v(ref_nested())) { return equal(optional);} return false;
			case 10: type = 10; if(v(ref_nested())) { return equal(optional);} return false;
			case 11: type = 11; if(v(ref_nested())) { return equal(optional);} return false;
			case 12: type = 12; if(v(ref_nested())) { return equal(optional);} return false;
			case 13: type = 13; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
SeNBAdditionRequest ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{SeNBAdditionRequest-IEs}},
	...
}
*/

struct SeNBAdditionRequest : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "SeNBAdditionRequest";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<SeNBAdditionRequest_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<SeNBAdditionRequest_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
SeNBAdditionRequestAcknowledge-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-MeNB-UE-X2AP-ID						CRITICALITY reject	TYPE UE-X2AP-ID							PRESENCE mandatory}|
	{ ID id-SeNB-UE-X2AP-ID						CRITICALITY reject	TYPE UE-X2AP-ID							PRESENCE mandatory}|
	{ ID id-E-RABs-Admitted-ToBeAdded-List		CRITICALITY ignore	TYPE E-RABs-Admitted-ToBeAdded-List	PRESENCE mandatory}|
	{ ID id-E-RABs-NotAdmitted-List				CRITICALITY ignore	TYPE E-RAB-List							PRESENCE optional}|
	{ ID id-SeNBtoMeNBContainer					CRITICALITY reject	TYPE SeNBtoMeNBContainer				PRESENCE mandatory}|
	{ ID id-CriticalityDiagnostics				CRITICALITY ignore	TYPE CriticalityDiagnostics				PRESENCE optional}|
	{ ID id-GW-TransportLayerAddress			CRITICALITY ignore	TYPE TransportLayerAddress				PRESENCE optional}|
	{ ID id-SIPTO-L-GW-TransportLayerAddress	CRITICALITY ignore	TYPE TransportLayerAddress				PRESENCE optional}|
	{ ID id-MeNB-UE-X2AP-ID-Extension			CRITICALITY reject	TYPE UE-X2AP-ID-Extension				PRESENCE optional}|
	{ ID id-SeNB-UE-X2AP-ID-Extension			CRITICALITY reject	TYPE UE-X2AP-ID-Extension				PRESENCE optional}|
	{ ID id-Tunnel-Information-for-BBF			CRITICALITY ignore	TYPE TunnelInformation					PRESENCE optional},
	...
}
*/

struct SeNBAdditionRequestAcknowledge_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 12; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(id_MeNB_UE_X2AP_ID); type=1;}
		void select_id_SeNB_UE_X2AP_ID() { set(id_SeNB_UE_X2AP_ID); type=2;}
		void select_id_E_RABs_Admitted_ToBeAdded_List() { set(id_E_RABs_Admitted_ToBeAdded_List); type=3;}
		void select_id_E_RABs_NotAdmitted_List() { set(id_E_RABs_NotAdmitted_List); type=4;}
		void select_id_SeNBtoMeNBContainer() { set(id_SeNBtoMeNBContainer); type=5;}
		void select_id_CriticalityDiagnostics() { set(id_CriticalityDiagnostics); type=6;}
		void select_id_GW_TransportLayerAddress() { set(id_GW_TransportLayerAddress); type=7;}
		void select_id_SIPTO_L_GW_TransportLayerAddress() { set(id_SIPTO_L_GW_TransportLayerAddress); type=8;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(id_MeNB_UE_X2AP_ID_Extension); type=9;}
		void select_id_SeNB_UE_X2AP_ID_Extension() { set(id_SeNB_UE_X2AP_ID_Extension); type=10;}
		void select_id_Tunnel_Information_for_BBF() { set(id_Tunnel_Information_for_BBF); type=11;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_MeNB_UE_X2AP_ID)) { type = 1; return true; }
			else if(equal(id_SeNB_UE_X2AP_ID)) { type = 2; return true; }
			else if(equal(id_E_RABs_Admitted_ToBeAdded_List)) { type = 3; return true; }
			else if(equal(id_E_RABs_NotAdmitted_List)) { type = 4; return true; }
			else if(equal(id_SeNBtoMeNBContainer)) { type = 5; return true; }
			else if(equal(id_CriticalityDiagnostics)) { type = 6; return true; }
			else if(equal(id_GW_TransportLayerAddress)) { type = 7; return true; }
			else if(equal(id_SIPTO_L_GW_TransportLayerAddress)) { type = 8; return true; }
			else if(equal(id_MeNB_UE_X2AP_ID_Extension)) { type = 9; return true; }
			else if(equal(id_SeNB_UE_X2AP_ID_Extension)) { type = 10; return true; }
			else if(equal(id_Tunnel_Information_for_BBF)) { type = 11; return true; }
			else { type = 12; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_SeNB_UE_X2AP_ID);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_E_RABs_Admitted_ToBeAdded_List);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(id_E_RABs_NotAdmitted_List);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(id_SeNBtoMeNBContainer);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(id_CriticalityDiagnostics);} return false;
			case 7: type = 7; if(v(ref_nested())) { return equal(id_GW_TransportLayerAddress);} return false;
			case 8: type = 8; if(v(ref_nested())) { return equal(id_SIPTO_L_GW_TransportLayerAddress);} return false;
			case 9: type = 9; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID_Extension);} return false;
			case 10: type = 10; if(v(ref_nested())) { return equal(id_SeNB_UE_X2AP_ID_Extension);} return false;
			case 11: type = 11; if(v(ref_nested())) { return equal(id_Tunnel_Information_for_BBF);} return false;
			case 12: type = 12; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 12; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(reject); type=1;}
		void select_id_SeNB_UE_X2AP_ID() { set(reject); type=2;}
		void select_id_E_RABs_Admitted_ToBeAdded_List() { set(ignore); type=3;}
		void select_id_E_RABs_NotAdmitted_List() { set(ignore); type=4;}
		void select_id_SeNBtoMeNBContainer() { set(reject); type=5;}
		void select_id_CriticalityDiagnostics() { set(ignore); type=6;}
		void select_id_GW_TransportLayerAddress() { set(ignore); type=7;}
		void select_id_SIPTO_L_GW_TransportLayerAddress() { set(ignore); type=8;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(reject); type=9;}
		void select_id_SeNB_UE_X2AP_ID_Extension() { set(reject); type=10;}
		void select_id_Tunnel_Information_for_BBF() { set(ignore); type=11;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else if(equal(reject)) { type = 2; return true; }
			else if(equal(ignore)) { type = 3; return true; }
			else if(equal(ignore)) { type = 4; return true; }
			else if(equal(reject)) { type = 5; return true; }
			else if(equal(ignore)) { type = 6; return true; }
			else if(equal(ignore)) { type = 7; return true; }
			else if(equal(ignore)) { type = 8; return true; }
			else if(equal(reject)) { type = 9; return true; }
			else if(equal(reject)) { type = 10; return true; }
			else if(equal(ignore)) { type = 11; return true; }
			else { type = 12; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(reject);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(ignore);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(ignore);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(reject);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(ignore);} return false;
			case 7: type = 7; if(v(ref_nested())) { return equal(ignore);} return false;
			case 8: type = 8; if(v(ref_nested())) { return equal(ignore);} return false;
			case 9: type = 9; if(v(ref_nested())) { return equal(reject);} return false;
			case 10: type = 10; if(v(ref_nested())) { return equal(reject);} return false;
			case 11: type = 11; if(v(ref_nested())) { return equal(ignore);} return false;
			case 12: type = 12; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		UE_X2AP_ID& select_id_MeNB_UE_X2AP_ID() { return set<UE_X2AP_ID>(1); }
		UE_X2AP_ID const* get_id_MeNB_UE_X2AP_ID() const { return get<UE_X2AP_ID>(1); }
		UE_X2AP_ID& select_id_SeNB_UE_X2AP_ID() { return set<UE_X2AP_ID>(2); }
		UE_X2AP_ID const* get_id_SeNB_UE_X2AP_ID() const { return get<UE_X2AP_ID>(2); }
		E_RABs_Admitted_ToBeAdded_List& select_id_E_RABs_Admitted_ToBeAdded_List() { return set<E_RABs_Admitted_ToBeAdded_List>(3); }
		E_RABs_Admitted_ToBeAdded_List const* get_id_E_RABs_Admitted_ToBeAdded_List() const { return get<E_RABs_Admitted_ToBeAdded_List>(3); }
		E_RAB_List& select_id_E_RABs_NotAdmitted_List() { return set<E_RAB_List>(4); }
		E_RAB_List const* get_id_E_RABs_NotAdmitted_List() const { return get<E_RAB_List>(4); }
		SeNBtoMeNBContainer& select_id_SeNBtoMeNBContainer() { return set<SeNBtoMeNBContainer>(5); }
		SeNBtoMeNBContainer const* get_id_SeNBtoMeNBContainer() const { return get<SeNBtoMeNBContainer>(5); }
		CriticalityDiagnostics& select_id_CriticalityDiagnostics() { return set<CriticalityDiagnostics>(6); }
		CriticalityDiagnostics const* get_id_CriticalityDiagnostics() const { return get<CriticalityDiagnostics>(6); }
		TransportLayerAddress& select_id_GW_TransportLayerAddress() { return set<TransportLayerAddress>(7); }
		TransportLayerAddress const* get_id_GW_TransportLayerAddress() const { return get<TransportLayerAddress>(7); }
		TransportLayerAddress& select_id_SIPTO_L_GW_TransportLayerAddress() { return set<TransportLayerAddress>(8); }
		TransportLayerAddress const* get_id_SIPTO_L_GW_TransportLayerAddress() const { return get<TransportLayerAddress>(8); }
		UE_X2AP_ID_Extension& select_id_MeNB_UE_X2AP_ID_Extension() { return set<UE_X2AP_ID_Extension>(9); }
		UE_X2AP_ID_Extension const* get_id_MeNB_UE_X2AP_ID_Extension() const { return get<UE_X2AP_ID_Extension>(9); }
		UE_X2AP_ID_Extension& select_id_SeNB_UE_X2AP_ID_Extension() { return set<UE_X2AP_ID_Extension>(10); }
		UE_X2AP_ID_Extension const* get_id_SeNB_UE_X2AP_ID_Extension() const { return get<UE_X2AP_ID_Extension>(10); }
		TunnelInformation& select_id_Tunnel_Information_for_BBF() { return set<TunnelInformation>(11); }
		TunnelInformation const* get_id_Tunnel_Information_for_BBF() const { return get<TunnelInformation>(11); }
		bool is_unknown() const { return type == 12; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<UE_X2AP_ID>(); break;
			case 2: var.destroy<UE_X2AP_ID>(); break;
			case 3: var.destroy<E_RABs_Admitted_ToBeAdded_List>(); break;
			case 4: var.destroy<E_RAB_List>(); break;
			case 5: var.destroy<SeNBtoMeNBContainer>(); break;
			case 6: var.destroy<CriticalityDiagnostics>(); break;
			case 7: var.destroy<TransportLayerAddress>(); break;
			case 8: var.destroy<TransportLayerAddress>(); break;
			case 9: var.destroy<UE_X2AP_ID_Extension>(); break;
			case 10: var.destroy<UE_X2AP_ID_Extension>(); break;
			case 11: var.destroy<TunnelInformation>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<UE_X2AP_ID>(1);
			v.template operator()<UE_X2AP_ID>(2);
			v.template operator()<E_RABs_Admitted_ToBeAdded_List>(3);
			v.template operator()<E_RAB_List>(4);
			v.template operator()<SeNBtoMeNBContainer>(5);
			v.template operator()<CriticalityDiagnostics>(6);
			v.template operator()<TransportLayerAddress>(7);
			v.template operator()<TransportLayerAddress>(8);
			v.template operator()<UE_X2AP_ID_Extension>(9);
			v.template operator()<UE_X2AP_ID_Extension>(10);
			v.template operator()<TunnelInformation>(11);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_MeNB_UE_X2AP_ID()); return true;
			case 2: v(select_id_SeNB_UE_X2AP_ID()); return true;
			case 3: v(select_id_E_RABs_Admitted_ToBeAdded_List()); return true;
			case 4: v(select_id_E_RABs_NotAdmitted_List()); return true;
			case 5: v(select_id_SeNBtoMeNBContainer()); return true;
			case 6: v(select_id_CriticalityDiagnostics()); return true;
			case 7: v(select_id_GW_TransportLayerAddress()); return true;
			case 8: v(select_id_SIPTO_L_GW_TransportLayerAddress()); return true;
			case 9: v(select_id_MeNB_UE_X2AP_ID_Extension()); return true;
			case 10: v(select_id_SeNB_UE_X2AP_ID_Extension()); return true;
			case 11: v(select_id_Tunnel_Information_for_BBF()); return true;
			case 12: if(type != 12) {clear(); asn::base::set();} type = 12; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<UE_X2AP_ID>()); return true;
			case 2: v(var.as<UE_X2AP_ID>()); return true;
			case 3: v(var.as<E_RABs_Admitted_ToBeAdded_List>()); return true;
			case 4: v(var.as<E_RAB_List>()); return true;
			case 5: v(var.as<SeNBtoMeNBContainer>()); return true;
			case 6: v(var.as<CriticalityDiagnostics>()); return true;
			case 7: v(var.as<TransportLayerAddress>()); return true;
			case 8: v(var.as<TransportLayerAddress>()); return true;
			case 9: v(var.as<UE_X2AP_ID_Extension>()); return true;
			case 10: v(var.as<UE_X2AP_ID_Extension>()); return true;
			case 11: v(var.as<TunnelInformation>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(CriticalityDiagnostics)];
			char dummy2[sizeof(E_RAB_List)];
			char dummy3[sizeof(E_RABs_Admitted_ToBeAdded_List)];
			char dummy4[sizeof(SeNBtoMeNBContainer)];
			char dummy5[sizeof(TransportLayerAddress)];
			char dummy6[sizeof(TunnelInformation)];
			char dummy7[sizeof(UE_X2AP_ID)];
			char dummy8[sizeof(UE_X2AP_ID_Extension)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 12; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(mandatory); type=1;}
		void select_id_SeNB_UE_X2AP_ID() { set(mandatory); type=2;}
		void select_id_E_RABs_Admitted_ToBeAdded_List() { set(mandatory); type=3;}
		void select_id_E_RABs_NotAdmitted_List() { set(optional); type=4;}
		void select_id_SeNBtoMeNBContainer() { set(mandatory); type=5;}
		void select_id_CriticalityDiagnostics() { set(optional); type=6;}
		void select_id_GW_TransportLayerAddress() { set(optional); type=7;}
		void select_id_SIPTO_L_GW_TransportLayerAddress() { set(optional); type=8;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(optional); type=9;}
		void select_id_SeNB_UE_X2AP_ID_Extension() { set(optional); type=10;}
		void select_id_Tunnel_Information_for_BBF() { set(optional); type=11;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(mandatory)) { type = 2; return true; }
			else if(equal(mandatory)) { type = 3; return true; }
			else if(equal(optional)) { type = 4; return true; }
			else if(equal(mandatory)) { type = 5; return true; }
			else if(equal(optional)) { type = 6; return true; }
			else if(equal(optional)) { type = 7; return true; }
			else if(equal(optional)) { type = 8; return true; }
			else if(equal(optional)) { type = 9; return true; }
			else if(equal(optional)) { type = 10; return true; }
			else if(equal(optional)) { type = 11; return true; }
			else { type = 12; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(optional);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(optional);} return false;
			case 7: type = 7; if(v(ref_nested())) { return equal(optional);} return false;
			case 8: type = 8; if(v(ref_nested())) { return equal(optional);} return false;
			case 9: type = 9; if(v(ref_nested())) { return equal(optional);} return false;
			case 10: type = 10; if(v(ref_nested())) { return equal(optional);} return false;
			case 11: type = 11; if(v(ref_nested())) { return equal(optional);} return false;
			case 12: type = 12; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
SeNBAdditionRequestAcknowledge ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{SeNBAdditionRequestAcknowledge-IEs}},
	...
}
*/

struct SeNBAdditionRequestAcknowledge : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "SeNBAdditionRequestAcknowledge";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<SeNBAdditionRequestAcknowledge_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<SeNBAdditionRequestAcknowledge_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
SeNBAdditionRequestReject-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-MeNB-UE-X2AP-ID					CRITICALITY reject	TYPE UE-X2AP-ID					PRESENCE mandatory}|
	{ ID id-SeNB-UE-X2AP-ID					CRITICALITY reject	TYPE UE-X2AP-ID					PRESENCE mandatory}|
	{ ID id-Cause							CRITICALITY ignore	TYPE Cause						PRESENCE mandatory}|
	{ ID id-CriticalityDiagnostics			CRITICALITY ignore	TYPE CriticalityDiagnostics		PRESENCE optional}|
	{ ID id-MeNB-UE-X2AP-ID-Extension		CRITICALITY reject	TYPE UE-X2AP-ID-Extension		PRESENCE optional}|
	{ ID id-SeNB-UE-X2AP-ID-Extension		CRITICALITY reject	TYPE UE-X2AP-ID-Extension		PRESENCE optional},
	...
}
*/

struct SeNBAdditionRequestReject_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 7; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(id_MeNB_UE_X2AP_ID); type=1;}
		void select_id_SeNB_UE_X2AP_ID() { set(id_SeNB_UE_X2AP_ID); type=2;}
		void select_id_Cause() { set(id_Cause); type=3;}
		void select_id_CriticalityDiagnostics() { set(id_CriticalityDiagnostics); type=4;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(id_MeNB_UE_X2AP_ID_Extension); type=5;}
		void select_id_SeNB_UE_X2AP_ID_Extension() { set(id_SeNB_UE_X2AP_ID_Extension); type=6;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_MeNB_UE_X2AP_ID)) { type = 1; return true; }
			else if(equal(id_SeNB_UE_X2AP_ID)) { type = 2; return true; }
			else if(equal(id_Cause)) { type = 3; return true; }
			else if(equal(id_CriticalityDiagnostics)) { type = 4; return true; }
			else if(equal(id_MeNB_UE_X2AP_ID_Extension)) { type = 5; return true; }
			else if(equal(id_SeNB_UE_X2AP_ID_Extension)) { type = 6; return true; }
			else { type = 7; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_SeNB_UE_X2AP_ID);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_Cause);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(id_CriticalityDiagnostics);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID_Extension);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(id_SeNB_UE_X2AP_ID_Extension);} return false;
			case 7: type = 7; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 7; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(reject); type=1;}
		void select_id_SeNB_UE_X2AP_ID() { set(reject); type=2;}
		void select_id_Cause() { set(ignore); type=3;}
		void select_id_CriticalityDiagnostics() { set(ignore); type=4;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(reject); type=5;}
		void select_id_SeNB_UE_X2AP_ID_Extension() { set(reject); type=6;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else if(equal(reject)) { type = 2; return true; }
			else if(equal(ignore)) { type = 3; return true; }
			else if(equal(ignore)) { type = 4; return true; }
			else if(equal(reject)) { type = 5; return true; }
			else if(equal(reject)) { type = 6; return true; }
			else { type = 7; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(reject);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(ignore);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(ignore);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(reject);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(reject);} return false;
			case 7: type = 7; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		UE_X2AP_ID& select_id_MeNB_UE_X2AP_ID() { return set<UE_X2AP_ID>(1); }
		UE_X2AP_ID const* get_id_MeNB_UE_X2AP_ID() const { return get<UE_X2AP_ID>(1); }
		UE_X2AP_ID& select_id_SeNB_UE_X2AP_ID() { return set<UE_X2AP_ID>(2); }
		UE_X2AP_ID const* get_id_SeNB_UE_X2AP_ID() const { return get<UE_X2AP_ID>(2); }
		Cause& select_id_Cause() { return set<Cause>(3); }
		Cause const* get_id_Cause() const { return get<Cause>(3); }
		CriticalityDiagnostics& select_id_CriticalityDiagnostics() { return set<CriticalityDiagnostics>(4); }
		CriticalityDiagnostics const* get_id_CriticalityDiagnostics() const { return get<CriticalityDiagnostics>(4); }
		UE_X2AP_ID_Extension& select_id_MeNB_UE_X2AP_ID_Extension() { return set<UE_X2AP_ID_Extension>(5); }
		UE_X2AP_ID_Extension const* get_id_MeNB_UE_X2AP_ID_Extension() const { return get<UE_X2AP_ID_Extension>(5); }
		UE_X2AP_ID_Extension& select_id_SeNB_UE_X2AP_ID_Extension() { return set<UE_X2AP_ID_Extension>(6); }
		UE_X2AP_ID_Extension const* get_id_SeNB_UE_X2AP_ID_Extension() const { return get<UE_X2AP_ID_Extension>(6); }
		bool is_unknown() const { return type == 7; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<UE_X2AP_ID>(); break;
			case 2: var.destroy<UE_X2AP_ID>(); break;
			case 3: var.destroy<Cause>(); break;
			case 4: var.destroy<CriticalityDiagnostics>(); break;
			case 5: var.destroy<UE_X2AP_ID_Extension>(); break;
			case 6: var.destroy<UE_X2AP_ID_Extension>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<UE_X2AP_ID>(1);
			v.template operator()<UE_X2AP_ID>(2);
			v.template operator()<Cause>(3);
			v.template operator()<CriticalityDiagnostics>(4);
			v.template operator()<UE_X2AP_ID_Extension>(5);
			v.template operator()<UE_X2AP_ID_Extension>(6);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_MeNB_UE_X2AP_ID()); return true;
			case 2: v(select_id_SeNB_UE_X2AP_ID()); return true;
			case 3: v(select_id_Cause()); return true;
			case 4: v(select_id_CriticalityDiagnostics()); return true;
			case 5: v(select_id_MeNB_UE_X2AP_ID_Extension()); return true;
			case 6: v(select_id_SeNB_UE_X2AP_ID_Extension()); return true;
			case 7: if(type != 7) {clear(); asn::base::set();} type = 7; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<UE_X2AP_ID>()); return true;
			case 2: v(var.as<UE_X2AP_ID>()); return true;
			case 3: v(var.as<Cause>()); return true;
			case 4: v(var.as<CriticalityDiagnostics>()); return true;
			case 5: v(var.as<UE_X2AP_ID_Extension>()); return true;
			case 6: v(var.as<UE_X2AP_ID_Extension>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(Cause)];
			char dummy2[sizeof(CriticalityDiagnostics)];
			char dummy3[sizeof(UE_X2AP_ID)];
			char dummy4[sizeof(UE_X2AP_ID_Extension)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 7; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(mandatory); type=1;}
		void select_id_SeNB_UE_X2AP_ID() { set(mandatory); type=2;}
		void select_id_Cause() { set(mandatory); type=3;}
		void select_id_CriticalityDiagnostics() { set(optional); type=4;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(optional); type=5;}
		void select_id_SeNB_UE_X2AP_ID_Extension() { set(optional); type=6;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(mandatory)) { type = 2; return true; }
			else if(equal(mandatory)) { type = 3; return true; }
			else if(equal(optional)) { type = 4; return true; }
			else if(equal(optional)) { type = 5; return true; }
			else if(equal(optional)) { type = 6; return true; }
			else { type = 7; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(optional);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(optional);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(optional);} return false;
			case 7: type = 7; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
SeNBAdditionRequestReject ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{SeNBAdditionRequestReject-IEs}},
	...
}
*/

struct SeNBAdditionRequestReject : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "SeNBAdditionRequestReject";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<SeNBAdditionRequestReject_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<SeNBAdditionRequestReject_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
SeNBCounterCheckRequest-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-MeNB-UE-X2AP-ID						CRITICALITY reject	TYPE UE-X2AP-ID									PRESENCE mandatory}|
	{ ID id-SeNB-UE-X2AP-ID						CRITICALITY reject	TYPE UE-X2AP-ID									PRESENCE mandatory}|
	{ ID id-E-RABs-SubjectToCounterCheck-List	CRITICALITY ignore	TYPE E-RABs-SubjectToCounterCheck-List		PRESENCE mandatory}|
	{ ID id-MeNB-UE-X2AP-ID-Extension			CRITICALITY ignore	TYPE UE-X2AP-ID-Extension						PRESENCE optional}|
	{ ID id-SeNB-UE-X2AP-ID-Extension			CRITICALITY ignore	TYPE UE-X2AP-ID-Extension						PRESENCE optional},
	...
}
*/

struct SeNBCounterCheckRequest_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 6; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(id_MeNB_UE_X2AP_ID); type=1;}
		void select_id_SeNB_UE_X2AP_ID() { set(id_SeNB_UE_X2AP_ID); type=2;}
		void select_id_E_RABs_SubjectToCounterCheck_List() { set(id_E_RABs_SubjectToCounterCheck_List); type=3;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(id_MeNB_UE_X2AP_ID_Extension); type=4;}
		void select_id_SeNB_UE_X2AP_ID_Extension() { set(id_SeNB_UE_X2AP_ID_Extension); type=5;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_MeNB_UE_X2AP_ID)) { type = 1; return true; }
			else if(equal(id_SeNB_UE_X2AP_ID)) { type = 2; return true; }
			else if(equal(id_E_RABs_SubjectToCounterCheck_List)) { type = 3; return true; }
			else if(equal(id_MeNB_UE_X2AP_ID_Extension)) { type = 4; return true; }
			else if(equal(id_SeNB_UE_X2AP_ID_Extension)) { type = 5; return true; }
			else { type = 6; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_SeNB_UE_X2AP_ID);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_E_RABs_SubjectToCounterCheck_List);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID_Extension);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(id_SeNB_UE_X2AP_ID_Extension);} return false;
			case 6: type = 6; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 6; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(reject); type=1;}
		void select_id_SeNB_UE_X2AP_ID() { set(reject); type=2;}
		void select_id_E_RABs_SubjectToCounterCheck_List() { set(ignore); type=3;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(ignore); type=4;}
		void select_id_SeNB_UE_X2AP_ID_Extension() { set(ignore); type=5;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else if(equal(reject)) { type = 2; return true; }
			else if(equal(ignore)) { type = 3; return true; }
			else if(equal(ignore)) { type = 4; return true; }
			else if(equal(ignore)) { type = 5; return true; }
			else { type = 6; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(reject);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(ignore);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(ignore);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(ignore);} return false;
			case 6: type = 6; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		UE_X2AP_ID& select_id_MeNB_UE_X2AP_ID() { return set<UE_X2AP_ID>(1); }
		UE_X2AP_ID const* get_id_MeNB_UE_X2AP_ID() const { return get<UE_X2AP_ID>(1); }
		UE_X2AP_ID& select_id_SeNB_UE_X2AP_ID() { return set<UE_X2AP_ID>(2); }
		UE_X2AP_ID const* get_id_SeNB_UE_X2AP_ID() const { return get<UE_X2AP_ID>(2); }
		E_RABs_SubjectToCounterCheck_List& select_id_E_RABs_SubjectToCounterCheck_List() { return set<E_RABs_SubjectToCounterCheck_List>(3); }
		E_RABs_SubjectToCounterCheck_List const* get_id_E_RABs_SubjectToCounterCheck_List() const { return get<E_RABs_SubjectToCounterCheck_List>(3); }
		UE_X2AP_ID_Extension& select_id_MeNB_UE_X2AP_ID_Extension() { return set<UE_X2AP_ID_Extension>(4); }
		UE_X2AP_ID_Extension const* get_id_MeNB_UE_X2AP_ID_Extension() const { return get<UE_X2AP_ID_Extension>(4); }
		UE_X2AP_ID_Extension& select_id_SeNB_UE_X2AP_ID_Extension() { return set<UE_X2AP_ID_Extension>(5); }
		UE_X2AP_ID_Extension const* get_id_SeNB_UE_X2AP_ID_Extension() const { return get<UE_X2AP_ID_Extension>(5); }
		bool is_unknown() const { return type == 6; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<UE_X2AP_ID>(); break;
			case 2: var.destroy<UE_X2AP_ID>(); break;
			case 3: var.destroy<E_RABs_SubjectToCounterCheck_List>(); break;
			case 4: var.destroy<UE_X2AP_ID_Extension>(); break;
			case 5: var.destroy<UE_X2AP_ID_Extension>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<UE_X2AP_ID>(1);
			v.template operator()<UE_X2AP_ID>(2);
			v.template operator()<E_RABs_SubjectToCounterCheck_List>(3);
			v.template operator()<UE_X2AP_ID_Extension>(4);
			v.template operator()<UE_X2AP_ID_Extension>(5);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_MeNB_UE_X2AP_ID()); return true;
			case 2: v(select_id_SeNB_UE_X2AP_ID()); return true;
			case 3: v(select_id_E_RABs_SubjectToCounterCheck_List()); return true;
			case 4: v(select_id_MeNB_UE_X2AP_ID_Extension()); return true;
			case 5: v(select_id_SeNB_UE_X2AP_ID_Extension()); return true;
			case 6: if(type != 6) {clear(); asn::base::set();} type = 6; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<UE_X2AP_ID>()); return true;
			case 2: v(var.as<UE_X2AP_ID>()); return true;
			case 3: v(var.as<E_RABs_SubjectToCounterCheck_List>()); return true;
			case 4: v(var.as<UE_X2AP_ID_Extension>()); return true;
			case 5: v(var.as<UE_X2AP_ID_Extension>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(E_RABs_SubjectToCounterCheck_List)];
			char dummy2[sizeof(UE_X2AP_ID)];
			char dummy3[sizeof(UE_X2AP_ID_Extension)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 6; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(mandatory); type=1;}
		void select_id_SeNB_UE_X2AP_ID() { set(mandatory); type=2;}
		void select_id_E_RABs_SubjectToCounterCheck_List() { set(mandatory); type=3;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(optional); type=4;}
		void select_id_SeNB_UE_X2AP_ID_Extension() { set(optional); type=5;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(mandatory)) { type = 2; return true; }
			else if(equal(mandatory)) { type = 3; return true; }
			else if(equal(optional)) { type = 4; return true; }
			else if(equal(optional)) { type = 5; return true; }
			else { type = 6; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(optional);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(optional);} return false;
			case 6: type = 6; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
SeNBCounterCheckRequest ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{SeNBCounterCheckRequest-IEs}},
	...
}
*/

struct SeNBCounterCheckRequest : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "SeNBCounterCheckRequest";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<SeNBCounterCheckRequest_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<SeNBCounterCheckRequest_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
SeNBModificationConfirm-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-MeNB-UE-X2AP-ID						CRITICALITY ignore	TYPE UE-X2AP-ID						PRESENCE mandatory}|
	{ ID id-SeNB-UE-X2AP-ID						CRITICALITY ignore	TYPE UE-X2AP-ID						PRESENCE mandatory}|
	{ ID id-MeNBtoSeNBContainer					CRITICALITY ignore	TYPE MeNBtoSeNBContainer			PRESENCE optional}|
	{ ID id-CriticalityDiagnostics				CRITICALITY ignore	TYPE CriticalityDiagnostics			PRESENCE optional}|
	{ ID id-MeNB-UE-X2AP-ID-Extension			CRITICALITY ignore	TYPE UE-X2AP-ID-Extension			PRESENCE optional}|
	{ ID id-SeNB-UE-X2AP-ID-Extension			CRITICALITY ignore	TYPE UE-X2AP-ID-Extension			PRESENCE optional},
	...
}
*/

struct SeNBModificationConfirm_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 7; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(id_MeNB_UE_X2AP_ID); type=1;}
		void select_id_SeNB_UE_X2AP_ID() { set(id_SeNB_UE_X2AP_ID); type=2;}
		void select_id_MeNBtoSeNBContainer() { set(id_MeNBtoSeNBContainer); type=3;}
		void select_id_CriticalityDiagnostics() { set(id_CriticalityDiagnostics); type=4;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(id_MeNB_UE_X2AP_ID_Extension); type=5;}
		void select_id_SeNB_UE_X2AP_ID_Extension() { set(id_SeNB_UE_X2AP_ID_Extension); type=6;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_MeNB_UE_X2AP_ID)) { type = 1; return true; }
			else if(equal(id_SeNB_UE_X2AP_ID)) { type = 2; return true; }
			else if(equal(id_MeNBtoSeNBContainer)) { type = 3; return true; }
			else if(equal(id_CriticalityDiagnostics)) { type = 4; return true; }
			else if(equal(id_MeNB_UE_X2AP_ID_Extension)) { type = 5; return true; }
			else if(equal(id_SeNB_UE_X2AP_ID_Extension)) { type = 6; return true; }
			else { type = 7; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_SeNB_UE_X2AP_ID);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_MeNBtoSeNBContainer);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(id_CriticalityDiagnostics);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID_Extension);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(id_SeNB_UE_X2AP_ID_Extension);} return false;
			case 7: type = 7; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 7; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(ignore); type=1;}
		void select_id_SeNB_UE_X2AP_ID() { set(ignore); type=2;}
		void select_id_MeNBtoSeNBContainer() { set(ignore); type=3;}
		void select_id_CriticalityDiagnostics() { set(ignore); type=4;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(ignore); type=5;}
		void select_id_SeNB_UE_X2AP_ID_Extension() { set(ignore); type=6;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else if(equal(ignore)) { type = 2; return true; }
			else if(equal(ignore)) { type = 3; return true; }
			else if(equal(ignore)) { type = 4; return true; }
			else if(equal(ignore)) { type = 5; return true; }
			else if(equal(ignore)) { type = 6; return true; }
			else { type = 7; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(ignore);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(ignore);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(ignore);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(ignore);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(ignore);} return false;
			case 7: type = 7; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		UE_X2AP_ID& select_id_MeNB_UE_X2AP_ID() { return set<UE_X2AP_ID>(1); }
		UE_X2AP_ID const* get_id_MeNB_UE_X2AP_ID() const { return get<UE_X2AP_ID>(1); }
		UE_X2AP_ID& select_id_SeNB_UE_X2AP_ID() { return set<UE_X2AP_ID>(2); }
		UE_X2AP_ID const* get_id_SeNB_UE_X2AP_ID() const { return get<UE_X2AP_ID>(2); }
		MeNBtoSeNBContainer& select_id_MeNBtoSeNBContainer() { return set<MeNBtoSeNBContainer>(3); }
		MeNBtoSeNBContainer const* get_id_MeNBtoSeNBContainer() const { return get<MeNBtoSeNBContainer>(3); }
		CriticalityDiagnostics& select_id_CriticalityDiagnostics() { return set<CriticalityDiagnostics>(4); }
		CriticalityDiagnostics const* get_id_CriticalityDiagnostics() const { return get<CriticalityDiagnostics>(4); }
		UE_X2AP_ID_Extension& select_id_MeNB_UE_X2AP_ID_Extension() { return set<UE_X2AP_ID_Extension>(5); }
		UE_X2AP_ID_Extension const* get_id_MeNB_UE_X2AP_ID_Extension() const { return get<UE_X2AP_ID_Extension>(5); }
		UE_X2AP_ID_Extension& select_id_SeNB_UE_X2AP_ID_Extension() { return set<UE_X2AP_ID_Extension>(6); }
		UE_X2AP_ID_Extension const* get_id_SeNB_UE_X2AP_ID_Extension() const { return get<UE_X2AP_ID_Extension>(6); }
		bool is_unknown() const { return type == 7; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<UE_X2AP_ID>(); break;
			case 2: var.destroy<UE_X2AP_ID>(); break;
			case 3: var.destroy<MeNBtoSeNBContainer>(); break;
			case 4: var.destroy<CriticalityDiagnostics>(); break;
			case 5: var.destroy<UE_X2AP_ID_Extension>(); break;
			case 6: var.destroy<UE_X2AP_ID_Extension>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<UE_X2AP_ID>(1);
			v.template operator()<UE_X2AP_ID>(2);
			v.template operator()<MeNBtoSeNBContainer>(3);
			v.template operator()<CriticalityDiagnostics>(4);
			v.template operator()<UE_X2AP_ID_Extension>(5);
			v.template operator()<UE_X2AP_ID_Extension>(6);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_MeNB_UE_X2AP_ID()); return true;
			case 2: v(select_id_SeNB_UE_X2AP_ID()); return true;
			case 3: v(select_id_MeNBtoSeNBContainer()); return true;
			case 4: v(select_id_CriticalityDiagnostics()); return true;
			case 5: v(select_id_MeNB_UE_X2AP_ID_Extension()); return true;
			case 6: v(select_id_SeNB_UE_X2AP_ID_Extension()); return true;
			case 7: if(type != 7) {clear(); asn::base::set();} type = 7; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<UE_X2AP_ID>()); return true;
			case 2: v(var.as<UE_X2AP_ID>()); return true;
			case 3: v(var.as<MeNBtoSeNBContainer>()); return true;
			case 4: v(var.as<CriticalityDiagnostics>()); return true;
			case 5: v(var.as<UE_X2AP_ID_Extension>()); return true;
			case 6: v(var.as<UE_X2AP_ID_Extension>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(CriticalityDiagnostics)];
			char dummy2[sizeof(MeNBtoSeNBContainer)];
			char dummy3[sizeof(UE_X2AP_ID)];
			char dummy4[sizeof(UE_X2AP_ID_Extension)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 7; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(mandatory); type=1;}
		void select_id_SeNB_UE_X2AP_ID() { set(mandatory); type=2;}
		void select_id_MeNBtoSeNBContainer() { set(optional); type=3;}
		void select_id_CriticalityDiagnostics() { set(optional); type=4;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(optional); type=5;}
		void select_id_SeNB_UE_X2AP_ID_Extension() { set(optional); type=6;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(mandatory)) { type = 2; return true; }
			else if(equal(optional)) { type = 3; return true; }
			else if(equal(optional)) { type = 4; return true; }
			else if(equal(optional)) { type = 5; return true; }
			else if(equal(optional)) { type = 6; return true; }
			else { type = 7; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(optional);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(optional);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(optional);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(optional);} return false;
			case 7: type = 7; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
SeNBModificationConfirm ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{SeNBModificationConfirm-IEs}},
	...
}
*/

struct SeNBModificationConfirm : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "SeNBModificationConfirm";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<SeNBModificationConfirm_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<SeNBModificationConfirm_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
SeNBModificationRefuse-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-MeNB-UE-X2AP-ID						CRITICALITY ignore	TYPE UE-X2AP-ID					PRESENCE mandatory}|
	{ ID id-SeNB-UE-X2AP-ID						CRITICALITY ignore	TYPE UE-X2AP-ID					PRESENCE mandatory}|
	{ ID id-Cause								CRITICALITY ignore	TYPE Cause						PRESENCE mandatory}|
	{ ID id-MeNBtoSeNBContainer					CRITICALITY ignore	TYPE MeNBtoSeNBContainer		PRESENCE optional}|
	{ ID id-CriticalityDiagnostics				CRITICALITY ignore	TYPE CriticalityDiagnostics		PRESENCE optional}|
	{ ID id-MeNB-UE-X2AP-ID-Extension			CRITICALITY ignore	TYPE UE-X2AP-ID-Extension		PRESENCE optional}|
	{ ID id-SeNB-UE-X2AP-ID-Extension			CRITICALITY ignore	TYPE UE-X2AP-ID-Extension		PRESENCE optional},
	...
}
*/

struct SeNBModificationRefuse_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 8; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(id_MeNB_UE_X2AP_ID); type=1;}
		void select_id_SeNB_UE_X2AP_ID() { set(id_SeNB_UE_X2AP_ID); type=2;}
		void select_id_Cause() { set(id_Cause); type=3;}
		void select_id_MeNBtoSeNBContainer() { set(id_MeNBtoSeNBContainer); type=4;}
		void select_id_CriticalityDiagnostics() { set(id_CriticalityDiagnostics); type=5;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(id_MeNB_UE_X2AP_ID_Extension); type=6;}
		void select_id_SeNB_UE_X2AP_ID_Extension() { set(id_SeNB_UE_X2AP_ID_Extension); type=7;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_MeNB_UE_X2AP_ID)) { type = 1; return true; }
			else if(equal(id_SeNB_UE_X2AP_ID)) { type = 2; return true; }
			else if(equal(id_Cause)) { type = 3; return true; }
			else if(equal(id_MeNBtoSeNBContainer)) { type = 4; return true; }
			else if(equal(id_CriticalityDiagnostics)) { type = 5; return true; }
			else if(equal(id_MeNB_UE_X2AP_ID_Extension)) { type = 6; return true; }
			else if(equal(id_SeNB_UE_X2AP_ID_Extension)) { type = 7; return true; }
			else { type = 8; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_SeNB_UE_X2AP_ID);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_Cause);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(id_MeNBtoSeNBContainer);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(id_CriticalityDiagnostics);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID_Extension);} return false;
			case 7: type = 7; if(v(ref_nested())) { return equal(id_SeNB_UE_X2AP_ID_Extension);} return false;
			case 8: type = 8; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 8; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(ignore); type=1;}
		void select_id_SeNB_UE_X2AP_ID() { set(ignore); type=2;}
		void select_id_Cause() { set(ignore); type=3;}
		void select_id_MeNBtoSeNBContainer() { set(ignore); type=4;}
		void select_id_CriticalityDiagnostics() { set(ignore); type=5;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(ignore); type=6;}
		void select_id_SeNB_UE_X2AP_ID_Extension() { set(ignore); type=7;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else if(equal(ignore)) { type = 2; return true; }
			else if(equal(ignore)) { type = 3; return true; }
			else if(equal(ignore)) { type = 4; return true; }
			else if(equal(ignore)) { type = 5; return true; }
			else if(equal(ignore)) { type = 6; return true; }
			else if(equal(ignore)) { type = 7; return true; }
			else { type = 8; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(ignore);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(ignore);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(ignore);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(ignore);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(ignore);} return false;
			case 7: type = 7; if(v(ref_nested())) { return equal(ignore);} return false;
			case 8: type = 8; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		UE_X2AP_ID& select_id_MeNB_UE_X2AP_ID() { return set<UE_X2AP_ID>(1); }
		UE_X2AP_ID const* get_id_MeNB_UE_X2AP_ID() const { return get<UE_X2AP_ID>(1); }
		UE_X2AP_ID& select_id_SeNB_UE_X2AP_ID() { return set<UE_X2AP_ID>(2); }
		UE_X2AP_ID const* get_id_SeNB_UE_X2AP_ID() const { return get<UE_X2AP_ID>(2); }
		Cause& select_id_Cause() { return set<Cause>(3); }
		Cause const* get_id_Cause() const { return get<Cause>(3); }
		MeNBtoSeNBContainer& select_id_MeNBtoSeNBContainer() { return set<MeNBtoSeNBContainer>(4); }
		MeNBtoSeNBContainer const* get_id_MeNBtoSeNBContainer() const { return get<MeNBtoSeNBContainer>(4); }
		CriticalityDiagnostics& select_id_CriticalityDiagnostics() { return set<CriticalityDiagnostics>(5); }
		CriticalityDiagnostics const* get_id_CriticalityDiagnostics() const { return get<CriticalityDiagnostics>(5); }
		UE_X2AP_ID_Extension& select_id_MeNB_UE_X2AP_ID_Extension() { return set<UE_X2AP_ID_Extension>(6); }
		UE_X2AP_ID_Extension const* get_id_MeNB_UE_X2AP_ID_Extension() const { return get<UE_X2AP_ID_Extension>(6); }
		UE_X2AP_ID_Extension& select_id_SeNB_UE_X2AP_ID_Extension() { return set<UE_X2AP_ID_Extension>(7); }
		UE_X2AP_ID_Extension const* get_id_SeNB_UE_X2AP_ID_Extension() const { return get<UE_X2AP_ID_Extension>(7); }
		bool is_unknown() const { return type == 8; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<UE_X2AP_ID>(); break;
			case 2: var.destroy<UE_X2AP_ID>(); break;
			case 3: var.destroy<Cause>(); break;
			case 4: var.destroy<MeNBtoSeNBContainer>(); break;
			case 5: var.destroy<CriticalityDiagnostics>(); break;
			case 6: var.destroy<UE_X2AP_ID_Extension>(); break;
			case 7: var.destroy<UE_X2AP_ID_Extension>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<UE_X2AP_ID>(1);
			v.template operator()<UE_X2AP_ID>(2);
			v.template operator()<Cause>(3);
			v.template operator()<MeNBtoSeNBContainer>(4);
			v.template operator()<CriticalityDiagnostics>(5);
			v.template operator()<UE_X2AP_ID_Extension>(6);
			v.template operator()<UE_X2AP_ID_Extension>(7);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_MeNB_UE_X2AP_ID()); return true;
			case 2: v(select_id_SeNB_UE_X2AP_ID()); return true;
			case 3: v(select_id_Cause()); return true;
			case 4: v(select_id_MeNBtoSeNBContainer()); return true;
			case 5: v(select_id_CriticalityDiagnostics()); return true;
			case 6: v(select_id_MeNB_UE_X2AP_ID_Extension()); return true;
			case 7: v(select_id_SeNB_UE_X2AP_ID_Extension()); return true;
			case 8: if(type != 8) {clear(); asn::base::set();} type = 8; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<UE_X2AP_ID>()); return true;
			case 2: v(var.as<UE_X2AP_ID>()); return true;
			case 3: v(var.as<Cause>()); return true;
			case 4: v(var.as<MeNBtoSeNBContainer>()); return true;
			case 5: v(var.as<CriticalityDiagnostics>()); return true;
			case 6: v(var.as<UE_X2AP_ID_Extension>()); return true;
			case 7: v(var.as<UE_X2AP_ID_Extension>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(Cause)];
			char dummy2[sizeof(CriticalityDiagnostics)];
			char dummy3[sizeof(MeNBtoSeNBContainer)];
			char dummy4[sizeof(UE_X2AP_ID)];
			char dummy5[sizeof(UE_X2AP_ID_Extension)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 8; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(mandatory); type=1;}
		void select_id_SeNB_UE_X2AP_ID() { set(mandatory); type=2;}
		void select_id_Cause() { set(mandatory); type=3;}
		void select_id_MeNBtoSeNBContainer() { set(optional); type=4;}
		void select_id_CriticalityDiagnostics() { set(optional); type=5;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(optional); type=6;}
		void select_id_SeNB_UE_X2AP_ID_Extension() { set(optional); type=7;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(mandatory)) { type = 2; return true; }
			else if(equal(mandatory)) { type = 3; return true; }
			else if(equal(optional)) { type = 4; return true; }
			else if(equal(optional)) { type = 5; return true; }
			else if(equal(optional)) { type = 6; return true; }
			else if(equal(optional)) { type = 7; return true; }
			else { type = 8; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(optional);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(optional);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(optional);} return false;
			case 7: type = 7; if(v(ref_nested())) { return equal(optional);} return false;
			case 8: type = 8; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
SeNBModificationRefuse ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container		{{SeNBModificationRefuse-IEs}},
	...
}
*/

struct SeNBModificationRefuse : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "SeNBModificationRefuse";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<SeNBModificationRefuse_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<SeNBModificationRefuse_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
UE-ContextInformationSeNBModReqExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	...
}
*/

struct UE_ContextInformationSeNBModReqExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear()
		{
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: if(type != 1) {clear(); asn::base::set();} type = 1; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			return false;

		}
		private:
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 1; }
		void clear() {type = 0;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			{ type = 1; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
UE-ContextInformationSeNBModReq ::= SEQUENCE {
	uE-SecurityCapabilities			UESecurityCapabilities															OPTIONAL,
	seNB-SecurityKey				SeNBSecurityKey 																OPTIONAL,
	seNBUEAggregateMaximumBitRate	UEAggregateMaximumBitRate														OPTIONAL,
	e-RABs-ToBeAdded				E-RABs-ToBeAdded-List-ModReq													OPTIONAL,
	e-RABs-ToBeModified				E-RABs-ToBeModified-List-ModReq													OPTIONAL,
	e-RABs-ToBeReleased				E-RABs-ToBeReleased-List-ModReq													OPTIONAL,
	iE-Extensions					ProtocolExtensionContainer { {UE-ContextInformationSeNBModReqExtIEs} }	OPTIONAL,
	...
}
*/

struct UE_ContextInformationSeNBModReq : asn::sequence<7, 0, true, 7>
{
	static constexpr const char* name() {return "UE-ContextInformationSeNBModReq";}
	using parent_t = asn::sequence<7, 0, true, 7>;
	struct uE_SecurityCapabilities_t : UESecurityCapabilities
	{
		static constexpr const char* name() {return "uE_SecurityCapabilities_t";}
		using parent_t = UESecurityCapabilities;
		static constexpr bool optional = true;

	};
	uE_SecurityCapabilities_t& set_uE_SecurityCapabilities() { uE_SecurityCapabilities.setpresent(true); return uE_SecurityCapabilities;}
	uE_SecurityCapabilities_t const* get_uE_SecurityCapabilities() const {return uE_SecurityCapabilities.is_valid() ? &uE_SecurityCapabilities : nullptr;}
	struct seNB_SecurityKey_t : SeNBSecurityKey
	{
		static constexpr const char* name() {return "seNB_SecurityKey_t";}
		using parent_t = SeNBSecurityKey;
		static constexpr bool optional = true;

	};
	seNB_SecurityKey_t& set_seNB_SecurityKey() { seNB_SecurityKey.setpresent(true); return seNB_SecurityKey;}
	seNB_SecurityKey_t const* get_seNB_SecurityKey() const {return seNB_SecurityKey.is_valid() ? &seNB_SecurityKey : nullptr;}
	struct seNBUEAggregateMaximumBitRate_t : UEAggregateMaximumBitRate
	{
		static constexpr const char* name() {return "seNBUEAggregateMaximumBitRate_t";}
		using parent_t = UEAggregateMaximumBitRate;
		static constexpr bool optional = true;

	};
	seNBUEAggregateMaximumBitRate_t& set_seNBUEAggregateMaximumBitRate() { seNBUEAggregateMaximumBitRate.setpresent(true); return seNBUEAggregateMaximumBitRate;}
	seNBUEAggregateMaximumBitRate_t const* get_seNBUEAggregateMaximumBitRate() const {return seNBUEAggregateMaximumBitRate.is_valid() ? &seNBUEAggregateMaximumBitRate : nullptr;}
	struct e_RABs_ToBeAdded_t : E_RABs_ToBeAdded_List_ModReq
	{
		static constexpr const char* name() {return "e_RABs_ToBeAdded_t";}
		using parent_t = E_RABs_ToBeAdded_List_ModReq;
		static constexpr bool optional = true;

	};
	e_RABs_ToBeAdded_t& set_e_RABs_ToBeAdded() { e_RABs_ToBeAdded.setpresent(true); return e_RABs_ToBeAdded;}
	e_RABs_ToBeAdded_t const* get_e_RABs_ToBeAdded() const {return e_RABs_ToBeAdded.is_valid() ? &e_RABs_ToBeAdded : nullptr;}
	struct e_RABs_ToBeModified_t : E_RABs_ToBeModified_List_ModReq
	{
		static constexpr const char* name() {return "e_RABs_ToBeModified_t";}
		using parent_t = E_RABs_ToBeModified_List_ModReq;
		static constexpr bool optional = true;

	};
	e_RABs_ToBeModified_t& set_e_RABs_ToBeModified() { e_RABs_ToBeModified.setpresent(true); return e_RABs_ToBeModified;}
	e_RABs_ToBeModified_t const* get_e_RABs_ToBeModified() const {return e_RABs_ToBeModified.is_valid() ? &e_RABs_ToBeModified : nullptr;}
	struct e_RABs_ToBeReleased_t : E_RABs_ToBeReleased_List_ModReq
	{
		static constexpr const char* name() {return "e_RABs_ToBeReleased_t";}
		using parent_t = E_RABs_ToBeReleased_List_ModReq;
		static constexpr bool optional = true;

	};
	e_RABs_ToBeReleased_t& set_e_RABs_ToBeReleased() { e_RABs_ToBeReleased.setpresent(true); return e_RABs_ToBeReleased;}
	e_RABs_ToBeReleased_t const* get_e_RABs_ToBeReleased() const {return e_RABs_ToBeReleased.is_valid() ? &e_RABs_ToBeReleased : nullptr;}
	struct iE_Extensions_t : ProtocolExtensionContainer<UE_ContextInformationSeNBModReqExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<UE_ContextInformationSeNBModReqExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(uE_SecurityCapabilities);
		v(seNB_SecurityKey);
		v(seNBUEAggregateMaximumBitRate);
		v(e_RABs_ToBeAdded);
		v(e_RABs_ToBeModified);
		v(e_RABs_ToBeReleased);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(uE_SecurityCapabilities);
		v(seNB_SecurityKey);
		v(seNBUEAggregateMaximumBitRate);
		v(e_RABs_ToBeAdded);
		v(e_RABs_ToBeModified);
		v(e_RABs_ToBeReleased);
		v(iE_Extensions);

	};
	void clear()
	{
		uE_SecurityCapabilities.clear();
		seNB_SecurityKey.clear();
		seNBUEAggregateMaximumBitRate.clear();
		e_RABs_ToBeAdded.clear();
		e_RABs_ToBeModified.clear();
		e_RABs_ToBeReleased.clear();
		iE_Extensions.clear();

	};
	private:
	uE_SecurityCapabilities_t	uE_SecurityCapabilities;
	seNB_SecurityKey_t	seNB_SecurityKey;
	seNBUEAggregateMaximumBitRate_t	seNBUEAggregateMaximumBitRate;
	e_RABs_ToBeAdded_t	e_RABs_ToBeAdded;
	e_RABs_ToBeModified_t	e_RABs_ToBeModified;
	e_RABs_ToBeReleased_t	e_RABs_ToBeReleased;
	iE_Extensions_t	iE_Extensions;

};
/*
SeNBModificationRequest-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-MeNB-UE-X2AP-ID						CRITICALITY reject	TYPE UE-X2AP-ID								PRESENCE mandatory}|
	{ ID id-SeNB-UE-X2AP-ID						CRITICALITY reject	TYPE UE-X2AP-ID								PRESENCE mandatory}|
	{ ID id-Cause								CRITICALITY ignore	TYPE Cause									PRESENCE mandatory}|
	{ ID id-SCGChangeIndication					CRITICALITY ignore	TYPE SCGChangeIndication					PRESENCE optional}|
	{ ID id-ServingPLMN							CRITICALITY ignore	TYPE PLMN-Identity							PRESENCE optional}|
	{ ID id-UE-ContextInformationSeNBModReq		CRITICALITY reject	TYPE UE-ContextInformationSeNBModReq	PRESENCE optional}|
	{ ID id-MeNBtoSeNBContainer					CRITICALITY ignore	TYPE MeNBtoSeNBContainer					PRESENCE optional}|
	{ ID id-CSGMembershipStatus					CRITICALITY reject	TYPE CSGMembershipStatus					PRESENCE optional}|
	{ ID id-MeNB-UE-X2AP-ID-Extension			CRITICALITY reject	TYPE UE-X2AP-ID-Extension					PRESENCE optional}|
	{ ID id-SeNB-UE-X2AP-ID-Extension			CRITICALITY reject	TYPE UE-X2AP-ID-Extension					PRESENCE optional},
	...
}
*/

struct SeNBModificationRequest_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 11; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(id_MeNB_UE_X2AP_ID); type=1;}
		void select_id_SeNB_UE_X2AP_ID() { set(id_SeNB_UE_X2AP_ID); type=2;}
		void select_id_Cause() { set(id_Cause); type=3;}
		void select_id_SCGChangeIndication() { set(id_SCGChangeIndication); type=4;}
		void select_id_ServingPLMN() { set(id_ServingPLMN); type=5;}
		void select_id_UE_ContextInformationSeNBModReq() { set(id_UE_ContextInformationSeNBModReq); type=6;}
		void select_id_MeNBtoSeNBContainer() { set(id_MeNBtoSeNBContainer); type=7;}
		void select_id_CSGMembershipStatus() { set(id_CSGMembershipStatus); type=8;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(id_MeNB_UE_X2AP_ID_Extension); type=9;}
		void select_id_SeNB_UE_X2AP_ID_Extension() { set(id_SeNB_UE_X2AP_ID_Extension); type=10;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_MeNB_UE_X2AP_ID)) { type = 1; return true; }
			else if(equal(id_SeNB_UE_X2AP_ID)) { type = 2; return true; }
			else if(equal(id_Cause)) { type = 3; return true; }
			else if(equal(id_SCGChangeIndication)) { type = 4; return true; }
			else if(equal(id_ServingPLMN)) { type = 5; return true; }
			else if(equal(id_UE_ContextInformationSeNBModReq)) { type = 6; return true; }
			else if(equal(id_MeNBtoSeNBContainer)) { type = 7; return true; }
			else if(equal(id_CSGMembershipStatus)) { type = 8; return true; }
			else if(equal(id_MeNB_UE_X2AP_ID_Extension)) { type = 9; return true; }
			else if(equal(id_SeNB_UE_X2AP_ID_Extension)) { type = 10; return true; }
			else { type = 11; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_SeNB_UE_X2AP_ID);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_Cause);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(id_SCGChangeIndication);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(id_ServingPLMN);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(id_UE_ContextInformationSeNBModReq);} return false;
			case 7: type = 7; if(v(ref_nested())) { return equal(id_MeNBtoSeNBContainer);} return false;
			case 8: type = 8; if(v(ref_nested())) { return equal(id_CSGMembershipStatus);} return false;
			case 9: type = 9; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID_Extension);} return false;
			case 10: type = 10; if(v(ref_nested())) { return equal(id_SeNB_UE_X2AP_ID_Extension);} return false;
			case 11: type = 11; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 11; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(reject); type=1;}
		void select_id_SeNB_UE_X2AP_ID() { set(reject); type=2;}
		void select_id_Cause() { set(ignore); type=3;}
		void select_id_SCGChangeIndication() { set(ignore); type=4;}
		void select_id_ServingPLMN() { set(ignore); type=5;}
		void select_id_UE_ContextInformationSeNBModReq() { set(reject); type=6;}
		void select_id_MeNBtoSeNBContainer() { set(ignore); type=7;}
		void select_id_CSGMembershipStatus() { set(reject); type=8;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(reject); type=9;}
		void select_id_SeNB_UE_X2AP_ID_Extension() { set(reject); type=10;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else if(equal(reject)) { type = 2; return true; }
			else if(equal(ignore)) { type = 3; return true; }
			else if(equal(ignore)) { type = 4; return true; }
			else if(equal(ignore)) { type = 5; return true; }
			else if(equal(reject)) { type = 6; return true; }
			else if(equal(ignore)) { type = 7; return true; }
			else if(equal(reject)) { type = 8; return true; }
			else if(equal(reject)) { type = 9; return true; }
			else if(equal(reject)) { type = 10; return true; }
			else { type = 11; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(reject);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(ignore);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(ignore);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(ignore);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(reject);} return false;
			case 7: type = 7; if(v(ref_nested())) { return equal(ignore);} return false;
			case 8: type = 8; if(v(ref_nested())) { return equal(reject);} return false;
			case 9: type = 9; if(v(ref_nested())) { return equal(reject);} return false;
			case 10: type = 10; if(v(ref_nested())) { return equal(reject);} return false;
			case 11: type = 11; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		UE_X2AP_ID& select_id_MeNB_UE_X2AP_ID() { return set<UE_X2AP_ID>(1); }
		UE_X2AP_ID const* get_id_MeNB_UE_X2AP_ID() const { return get<UE_X2AP_ID>(1); }
		UE_X2AP_ID& select_id_SeNB_UE_X2AP_ID() { return set<UE_X2AP_ID>(2); }
		UE_X2AP_ID const* get_id_SeNB_UE_X2AP_ID() const { return get<UE_X2AP_ID>(2); }
		Cause& select_id_Cause() { return set<Cause>(3); }
		Cause const* get_id_Cause() const { return get<Cause>(3); }
		SCGChangeIndication& select_id_SCGChangeIndication() { return set<SCGChangeIndication>(4); }
		SCGChangeIndication const* get_id_SCGChangeIndication() const { return get<SCGChangeIndication>(4); }
		PLMN_Identity& select_id_ServingPLMN() { return set<PLMN_Identity>(5); }
		PLMN_Identity const* get_id_ServingPLMN() const { return get<PLMN_Identity>(5); }
		UE_ContextInformationSeNBModReq& select_id_UE_ContextInformationSeNBModReq() { return set<UE_ContextInformationSeNBModReq>(6); }
		UE_ContextInformationSeNBModReq const* get_id_UE_ContextInformationSeNBModReq() const { return get<UE_ContextInformationSeNBModReq>(6); }
		MeNBtoSeNBContainer& select_id_MeNBtoSeNBContainer() { return set<MeNBtoSeNBContainer>(7); }
		MeNBtoSeNBContainer const* get_id_MeNBtoSeNBContainer() const { return get<MeNBtoSeNBContainer>(7); }
		CSGMembershipStatus& select_id_CSGMembershipStatus() { return set<CSGMembershipStatus>(8); }
		CSGMembershipStatus const* get_id_CSGMembershipStatus() const { return get<CSGMembershipStatus>(8); }
		UE_X2AP_ID_Extension& select_id_MeNB_UE_X2AP_ID_Extension() { return set<UE_X2AP_ID_Extension>(9); }
		UE_X2AP_ID_Extension const* get_id_MeNB_UE_X2AP_ID_Extension() const { return get<UE_X2AP_ID_Extension>(9); }
		UE_X2AP_ID_Extension& select_id_SeNB_UE_X2AP_ID_Extension() { return set<UE_X2AP_ID_Extension>(10); }
		UE_X2AP_ID_Extension const* get_id_SeNB_UE_X2AP_ID_Extension() const { return get<UE_X2AP_ID_Extension>(10); }
		bool is_unknown() const { return type == 11; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<UE_X2AP_ID>(); break;
			case 2: var.destroy<UE_X2AP_ID>(); break;
			case 3: var.destroy<Cause>(); break;
			case 4: var.destroy<SCGChangeIndication>(); break;
			case 5: var.destroy<PLMN_Identity>(); break;
			case 6: var.destroy<UE_ContextInformationSeNBModReq>(); break;
			case 7: var.destroy<MeNBtoSeNBContainer>(); break;
			case 8: var.destroy<CSGMembershipStatus>(); break;
			case 9: var.destroy<UE_X2AP_ID_Extension>(); break;
			case 10: var.destroy<UE_X2AP_ID_Extension>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<UE_X2AP_ID>(1);
			v.template operator()<UE_X2AP_ID>(2);
			v.template operator()<Cause>(3);
			v.template operator()<SCGChangeIndication>(4);
			v.template operator()<PLMN_Identity>(5);
			v.template operator()<UE_ContextInformationSeNBModReq>(6);
			v.template operator()<MeNBtoSeNBContainer>(7);
			v.template operator()<CSGMembershipStatus>(8);
			v.template operator()<UE_X2AP_ID_Extension>(9);
			v.template operator()<UE_X2AP_ID_Extension>(10);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_MeNB_UE_X2AP_ID()); return true;
			case 2: v(select_id_SeNB_UE_X2AP_ID()); return true;
			case 3: v(select_id_Cause()); return true;
			case 4: v(select_id_SCGChangeIndication()); return true;
			case 5: v(select_id_ServingPLMN()); return true;
			case 6: v(select_id_UE_ContextInformationSeNBModReq()); return true;
			case 7: v(select_id_MeNBtoSeNBContainer()); return true;
			case 8: v(select_id_CSGMembershipStatus()); return true;
			case 9: v(select_id_MeNB_UE_X2AP_ID_Extension()); return true;
			case 10: v(select_id_SeNB_UE_X2AP_ID_Extension()); return true;
			case 11: if(type != 11) {clear(); asn::base::set();} type = 11; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<UE_X2AP_ID>()); return true;
			case 2: v(var.as<UE_X2AP_ID>()); return true;
			case 3: v(var.as<Cause>()); return true;
			case 4: v(var.as<SCGChangeIndication>()); return true;
			case 5: v(var.as<PLMN_Identity>()); return true;
			case 6: v(var.as<UE_ContextInformationSeNBModReq>()); return true;
			case 7: v(var.as<MeNBtoSeNBContainer>()); return true;
			case 8: v(var.as<CSGMembershipStatus>()); return true;
			case 9: v(var.as<UE_X2AP_ID_Extension>()); return true;
			case 10: v(var.as<UE_X2AP_ID_Extension>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(CSGMembershipStatus)];
			char dummy2[sizeof(Cause)];
			char dummy3[sizeof(MeNBtoSeNBContainer)];
			char dummy4[sizeof(PLMN_Identity)];
			char dummy5[sizeof(SCGChangeIndication)];
			char dummy6[sizeof(UE_ContextInformationSeNBModReq)];
			char dummy7[sizeof(UE_X2AP_ID)];
			char dummy8[sizeof(UE_X2AP_ID_Extension)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 11; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(mandatory); type=1;}
		void select_id_SeNB_UE_X2AP_ID() { set(mandatory); type=2;}
		void select_id_Cause() { set(mandatory); type=3;}
		void select_id_SCGChangeIndication() { set(optional); type=4;}
		void select_id_ServingPLMN() { set(optional); type=5;}
		void select_id_UE_ContextInformationSeNBModReq() { set(optional); type=6;}
		void select_id_MeNBtoSeNBContainer() { set(optional); type=7;}
		void select_id_CSGMembershipStatus() { set(optional); type=8;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(optional); type=9;}
		void select_id_SeNB_UE_X2AP_ID_Extension() { set(optional); type=10;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(mandatory)) { type = 2; return true; }
			else if(equal(mandatory)) { type = 3; return true; }
			else if(equal(optional)) { type = 4; return true; }
			else if(equal(optional)) { type = 5; return true; }
			else if(equal(optional)) { type = 6; return true; }
			else if(equal(optional)) { type = 7; return true; }
			else if(equal(optional)) { type = 8; return true; }
			else if(equal(optional)) { type = 9; return true; }
			else if(equal(optional)) { type = 10; return true; }
			else { type = 11; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(optional);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(optional);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(optional);} return false;
			case 7: type = 7; if(v(ref_nested())) { return equal(optional);} return false;
			case 8: type = 8; if(v(ref_nested())) { return equal(optional);} return false;
			case 9: type = 9; if(v(ref_nested())) { return equal(optional);} return false;
			case 10: type = 10; if(v(ref_nested())) { return equal(optional);} return false;
			case 11: type = 11; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
SeNBModificationRequest ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{ SeNBModificationRequest-IEs}},
	...
}
*/

struct SeNBModificationRequest : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "SeNBModificationRequest";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<SeNBModificationRequest_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<SeNBModificationRequest_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
SeNBModificationRequestAcknowledge-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-MeNB-UE-X2AP-ID								CRITICALITY ignore	TYPE UE-X2AP-ID											PRESENCE mandatory}|
	{ ID id-SeNB-UE-X2AP-ID								CRITICALITY ignore	TYPE UE-X2AP-ID											PRESENCE mandatory}|
	{ ID id-E-RABs-Admitted-ToBeAdded-ModAckList		CRITICALITY ignore	TYPE E-RABs-Admitted-ToBeAdded-ModAckList		PRESENCE optional}|
	{ ID id-E-RABs-Admitted-ToBeModified-ModAckList		CRITICALITY ignore	TYPE E-RABs-Admitted-ToBeModified-ModAckList	PRESENCE optional}|
	{ ID id-E-RABs-Admitted-ToBeReleased-ModAckList		CRITICALITY ignore	TYPE E-RABs-Admitted-ToBeReleased-ModAckList	PRESENCE optional}|
	{ ID id-E-RABs-NotAdmitted-List						CRITICALITY ignore	TYPE E-RAB-List											PRESENCE optional}|
	{ ID id-SeNBtoMeNBContainer							CRITICALITY ignore	TYPE SeNBtoMeNBContainer								PRESENCE optional}|
	{ ID id-CriticalityDiagnostics						CRITICALITY ignore	TYPE CriticalityDiagnostics							PRESENCE optional}|
	{ ID id-MeNB-UE-X2AP-ID-Extension					CRITICALITY ignore	TYPE UE-X2AP-ID-Extension							PRESENCE optional}|
	{ ID id-SeNB-UE-X2AP-ID-Extension					CRITICALITY ignore	TYPE UE-X2AP-ID-Extension							PRESENCE optional},
	...
}
*/

struct SeNBModificationRequestAcknowledge_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 11; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(id_MeNB_UE_X2AP_ID); type=1;}
		void select_id_SeNB_UE_X2AP_ID() { set(id_SeNB_UE_X2AP_ID); type=2;}
		void select_id_E_RABs_Admitted_ToBeAdded_ModAckList() { set(id_E_RABs_Admitted_ToBeAdded_ModAckList); type=3;}
		void select_id_E_RABs_Admitted_ToBeModified_ModAckList() { set(id_E_RABs_Admitted_ToBeModified_ModAckList); type=4;}
		void select_id_E_RABs_Admitted_ToBeReleased_ModAckList() { set(id_E_RABs_Admitted_ToBeReleased_ModAckList); type=5;}
		void select_id_E_RABs_NotAdmitted_List() { set(id_E_RABs_NotAdmitted_List); type=6;}
		void select_id_SeNBtoMeNBContainer() { set(id_SeNBtoMeNBContainer); type=7;}
		void select_id_CriticalityDiagnostics() { set(id_CriticalityDiagnostics); type=8;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(id_MeNB_UE_X2AP_ID_Extension); type=9;}
		void select_id_SeNB_UE_X2AP_ID_Extension() { set(id_SeNB_UE_X2AP_ID_Extension); type=10;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_MeNB_UE_X2AP_ID)) { type = 1; return true; }
			else if(equal(id_SeNB_UE_X2AP_ID)) { type = 2; return true; }
			else if(equal(id_E_RABs_Admitted_ToBeAdded_ModAckList)) { type = 3; return true; }
			else if(equal(id_E_RABs_Admitted_ToBeModified_ModAckList)) { type = 4; return true; }
			else if(equal(id_E_RABs_Admitted_ToBeReleased_ModAckList)) { type = 5; return true; }
			else if(equal(id_E_RABs_NotAdmitted_List)) { type = 6; return true; }
			else if(equal(id_SeNBtoMeNBContainer)) { type = 7; return true; }
			else if(equal(id_CriticalityDiagnostics)) { type = 8; return true; }
			else if(equal(id_MeNB_UE_X2AP_ID_Extension)) { type = 9; return true; }
			else if(equal(id_SeNB_UE_X2AP_ID_Extension)) { type = 10; return true; }
			else { type = 11; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_SeNB_UE_X2AP_ID);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_E_RABs_Admitted_ToBeAdded_ModAckList);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(id_E_RABs_Admitted_ToBeModified_ModAckList);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(id_E_RABs_Admitted_ToBeReleased_ModAckList);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(id_E_RABs_NotAdmitted_List);} return false;
			case 7: type = 7; if(v(ref_nested())) { return equal(id_SeNBtoMeNBContainer);} return false;
			case 8: type = 8; if(v(ref_nested())) { return equal(id_CriticalityDiagnostics);} return false;
			case 9: type = 9; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID_Extension);} return false;
			case 10: type = 10; if(v(ref_nested())) { return equal(id_SeNB_UE_X2AP_ID_Extension);} return false;
			case 11: type = 11; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 11; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(ignore); type=1;}
		void select_id_SeNB_UE_X2AP_ID() { set(ignore); type=2;}
		void select_id_E_RABs_Admitted_ToBeAdded_ModAckList() { set(ignore); type=3;}
		void select_id_E_RABs_Admitted_ToBeModified_ModAckList() { set(ignore); type=4;}
		void select_id_E_RABs_Admitted_ToBeReleased_ModAckList() { set(ignore); type=5;}
		void select_id_E_RABs_NotAdmitted_List() { set(ignore); type=6;}
		void select_id_SeNBtoMeNBContainer() { set(ignore); type=7;}
		void select_id_CriticalityDiagnostics() { set(ignore); type=8;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(ignore); type=9;}
		void select_id_SeNB_UE_X2AP_ID_Extension() { set(ignore); type=10;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else if(equal(ignore)) { type = 2; return true; }
			else if(equal(ignore)) { type = 3; return true; }
			else if(equal(ignore)) { type = 4; return true; }
			else if(equal(ignore)) { type = 5; return true; }
			else if(equal(ignore)) { type = 6; return true; }
			else if(equal(ignore)) { type = 7; return true; }
			else if(equal(ignore)) { type = 8; return true; }
			else if(equal(ignore)) { type = 9; return true; }
			else if(equal(ignore)) { type = 10; return true; }
			else { type = 11; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(ignore);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(ignore);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(ignore);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(ignore);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(ignore);} return false;
			case 7: type = 7; if(v(ref_nested())) { return equal(ignore);} return false;
			case 8: type = 8; if(v(ref_nested())) { return equal(ignore);} return false;
			case 9: type = 9; if(v(ref_nested())) { return equal(ignore);} return false;
			case 10: type = 10; if(v(ref_nested())) { return equal(ignore);} return false;
			case 11: type = 11; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		UE_X2AP_ID& select_id_MeNB_UE_X2AP_ID() { return set<UE_X2AP_ID>(1); }
		UE_X2AP_ID const* get_id_MeNB_UE_X2AP_ID() const { return get<UE_X2AP_ID>(1); }
		UE_X2AP_ID& select_id_SeNB_UE_X2AP_ID() { return set<UE_X2AP_ID>(2); }
		UE_X2AP_ID const* get_id_SeNB_UE_X2AP_ID() const { return get<UE_X2AP_ID>(2); }
		E_RABs_Admitted_ToBeAdded_ModAckList& select_id_E_RABs_Admitted_ToBeAdded_ModAckList() { return set<E_RABs_Admitted_ToBeAdded_ModAckList>(3); }
		E_RABs_Admitted_ToBeAdded_ModAckList const* get_id_E_RABs_Admitted_ToBeAdded_ModAckList() const { return get<E_RABs_Admitted_ToBeAdded_ModAckList>(3); }
		E_RABs_Admitted_ToBeModified_ModAckList& select_id_E_RABs_Admitted_ToBeModified_ModAckList() { return set<E_RABs_Admitted_ToBeModified_ModAckList>(4); }
		E_RABs_Admitted_ToBeModified_ModAckList const* get_id_E_RABs_Admitted_ToBeModified_ModAckList() const { return get<E_RABs_Admitted_ToBeModified_ModAckList>(4); }
		E_RABs_Admitted_ToBeReleased_ModAckList& select_id_E_RABs_Admitted_ToBeReleased_ModAckList() { return set<E_RABs_Admitted_ToBeReleased_ModAckList>(5); }
		E_RABs_Admitted_ToBeReleased_ModAckList const* get_id_E_RABs_Admitted_ToBeReleased_ModAckList() const { return get<E_RABs_Admitted_ToBeReleased_ModAckList>(5); }
		E_RAB_List& select_id_E_RABs_NotAdmitted_List() { return set<E_RAB_List>(6); }
		E_RAB_List const* get_id_E_RABs_NotAdmitted_List() const { return get<E_RAB_List>(6); }
		SeNBtoMeNBContainer& select_id_SeNBtoMeNBContainer() { return set<SeNBtoMeNBContainer>(7); }
		SeNBtoMeNBContainer const* get_id_SeNBtoMeNBContainer() const { return get<SeNBtoMeNBContainer>(7); }
		CriticalityDiagnostics& select_id_CriticalityDiagnostics() { return set<CriticalityDiagnostics>(8); }
		CriticalityDiagnostics const* get_id_CriticalityDiagnostics() const { return get<CriticalityDiagnostics>(8); }
		UE_X2AP_ID_Extension& select_id_MeNB_UE_X2AP_ID_Extension() { return set<UE_X2AP_ID_Extension>(9); }
		UE_X2AP_ID_Extension const* get_id_MeNB_UE_X2AP_ID_Extension() const { return get<UE_X2AP_ID_Extension>(9); }
		UE_X2AP_ID_Extension& select_id_SeNB_UE_X2AP_ID_Extension() { return set<UE_X2AP_ID_Extension>(10); }
		UE_X2AP_ID_Extension const* get_id_SeNB_UE_X2AP_ID_Extension() const { return get<UE_X2AP_ID_Extension>(10); }
		bool is_unknown() const { return type == 11; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<UE_X2AP_ID>(); break;
			case 2: var.destroy<UE_X2AP_ID>(); break;
			case 3: var.destroy<E_RABs_Admitted_ToBeAdded_ModAckList>(); break;
			case 4: var.destroy<E_RABs_Admitted_ToBeModified_ModAckList>(); break;
			case 5: var.destroy<E_RABs_Admitted_ToBeReleased_ModAckList>(); break;
			case 6: var.destroy<E_RAB_List>(); break;
			case 7: var.destroy<SeNBtoMeNBContainer>(); break;
			case 8: var.destroy<CriticalityDiagnostics>(); break;
			case 9: var.destroy<UE_X2AP_ID_Extension>(); break;
			case 10: var.destroy<UE_X2AP_ID_Extension>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<UE_X2AP_ID>(1);
			v.template operator()<UE_X2AP_ID>(2);
			v.template operator()<E_RABs_Admitted_ToBeAdded_ModAckList>(3);
			v.template operator()<E_RABs_Admitted_ToBeModified_ModAckList>(4);
			v.template operator()<E_RABs_Admitted_ToBeReleased_ModAckList>(5);
			v.template operator()<E_RAB_List>(6);
			v.template operator()<SeNBtoMeNBContainer>(7);
			v.template operator()<CriticalityDiagnostics>(8);
			v.template operator()<UE_X2AP_ID_Extension>(9);
			v.template operator()<UE_X2AP_ID_Extension>(10);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_MeNB_UE_X2AP_ID()); return true;
			case 2: v(select_id_SeNB_UE_X2AP_ID()); return true;
			case 3: v(select_id_E_RABs_Admitted_ToBeAdded_ModAckList()); return true;
			case 4: v(select_id_E_RABs_Admitted_ToBeModified_ModAckList()); return true;
			case 5: v(select_id_E_RABs_Admitted_ToBeReleased_ModAckList()); return true;
			case 6: v(select_id_E_RABs_NotAdmitted_List()); return true;
			case 7: v(select_id_SeNBtoMeNBContainer()); return true;
			case 8: v(select_id_CriticalityDiagnostics()); return true;
			case 9: v(select_id_MeNB_UE_X2AP_ID_Extension()); return true;
			case 10: v(select_id_SeNB_UE_X2AP_ID_Extension()); return true;
			case 11: if(type != 11) {clear(); asn::base::set();} type = 11; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<UE_X2AP_ID>()); return true;
			case 2: v(var.as<UE_X2AP_ID>()); return true;
			case 3: v(var.as<E_RABs_Admitted_ToBeAdded_ModAckList>()); return true;
			case 4: v(var.as<E_RABs_Admitted_ToBeModified_ModAckList>()); return true;
			case 5: v(var.as<E_RABs_Admitted_ToBeReleased_ModAckList>()); return true;
			case 6: v(var.as<E_RAB_List>()); return true;
			case 7: v(var.as<SeNBtoMeNBContainer>()); return true;
			case 8: v(var.as<CriticalityDiagnostics>()); return true;
			case 9: v(var.as<UE_X2AP_ID_Extension>()); return true;
			case 10: v(var.as<UE_X2AP_ID_Extension>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(CriticalityDiagnostics)];
			char dummy2[sizeof(E_RAB_List)];
			char dummy3[sizeof(E_RABs_Admitted_ToBeAdded_ModAckList)];
			char dummy4[sizeof(E_RABs_Admitted_ToBeModified_ModAckList)];
			char dummy5[sizeof(E_RABs_Admitted_ToBeReleased_ModAckList)];
			char dummy6[sizeof(SeNBtoMeNBContainer)];
			char dummy7[sizeof(UE_X2AP_ID)];
			char dummy8[sizeof(UE_X2AP_ID_Extension)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 11; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(mandatory); type=1;}
		void select_id_SeNB_UE_X2AP_ID() { set(mandatory); type=2;}
		void select_id_E_RABs_Admitted_ToBeAdded_ModAckList() { set(optional); type=3;}
		void select_id_E_RABs_Admitted_ToBeModified_ModAckList() { set(optional); type=4;}
		void select_id_E_RABs_Admitted_ToBeReleased_ModAckList() { set(optional); type=5;}
		void select_id_E_RABs_NotAdmitted_List() { set(optional); type=6;}
		void select_id_SeNBtoMeNBContainer() { set(optional); type=7;}
		void select_id_CriticalityDiagnostics() { set(optional); type=8;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(optional); type=9;}
		void select_id_SeNB_UE_X2AP_ID_Extension() { set(optional); type=10;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(mandatory)) { type = 2; return true; }
			else if(equal(optional)) { type = 3; return true; }
			else if(equal(optional)) { type = 4; return true; }
			else if(equal(optional)) { type = 5; return true; }
			else if(equal(optional)) { type = 6; return true; }
			else if(equal(optional)) { type = 7; return true; }
			else if(equal(optional)) { type = 8; return true; }
			else if(equal(optional)) { type = 9; return true; }
			else if(equal(optional)) { type = 10; return true; }
			else { type = 11; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(optional);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(optional);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(optional);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(optional);} return false;
			case 7: type = 7; if(v(ref_nested())) { return equal(optional);} return false;
			case 8: type = 8; if(v(ref_nested())) { return equal(optional);} return false;
			case 9: type = 9; if(v(ref_nested())) { return equal(optional);} return false;
			case 10: type = 10; if(v(ref_nested())) { return equal(optional);} return false;
			case 11: type = 11; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
SeNBModificationRequestAcknowledge ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{SeNBModificationRequestAcknowledge-IEs}},
	...
}
*/

struct SeNBModificationRequestAcknowledge : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "SeNBModificationRequestAcknowledge";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<SeNBModificationRequestAcknowledge_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<SeNBModificationRequestAcknowledge_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
SeNBModificationRequestReject-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-MeNB-UE-X2AP-ID						CRITICALITY ignore	TYPE UE-X2AP-ID					PRESENCE mandatory}|
	{ ID id-SeNB-UE-X2AP-ID						CRITICALITY ignore	TYPE UE-X2AP-ID					PRESENCE mandatory}|
	{ ID id-Cause								CRITICALITY ignore	TYPE Cause						PRESENCE mandatory}|
	{ ID id-CriticalityDiagnostics				CRITICALITY ignore	TYPE CriticalityDiagnostics		PRESENCE optional}|
	{ ID id-MeNB-UE-X2AP-ID-Extension			CRITICALITY ignore	TYPE UE-X2AP-ID-Extension		PRESENCE optional}|
	{ ID id-SeNB-UE-X2AP-ID-Extension			CRITICALITY ignore	TYPE UE-X2AP-ID-Extension		PRESENCE optional},
	...
}
*/

struct SeNBModificationRequestReject_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 7; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(id_MeNB_UE_X2AP_ID); type=1;}
		void select_id_SeNB_UE_X2AP_ID() { set(id_SeNB_UE_X2AP_ID); type=2;}
		void select_id_Cause() { set(id_Cause); type=3;}
		void select_id_CriticalityDiagnostics() { set(id_CriticalityDiagnostics); type=4;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(id_MeNB_UE_X2AP_ID_Extension); type=5;}
		void select_id_SeNB_UE_X2AP_ID_Extension() { set(id_SeNB_UE_X2AP_ID_Extension); type=6;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_MeNB_UE_X2AP_ID)) { type = 1; return true; }
			else if(equal(id_SeNB_UE_X2AP_ID)) { type = 2; return true; }
			else if(equal(id_Cause)) { type = 3; return true; }
			else if(equal(id_CriticalityDiagnostics)) { type = 4; return true; }
			else if(equal(id_MeNB_UE_X2AP_ID_Extension)) { type = 5; return true; }
			else if(equal(id_SeNB_UE_X2AP_ID_Extension)) { type = 6; return true; }
			else { type = 7; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_SeNB_UE_X2AP_ID);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_Cause);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(id_CriticalityDiagnostics);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID_Extension);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(id_SeNB_UE_X2AP_ID_Extension);} return false;
			case 7: type = 7; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 7; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(ignore); type=1;}
		void select_id_SeNB_UE_X2AP_ID() { set(ignore); type=2;}
		void select_id_Cause() { set(ignore); type=3;}
		void select_id_CriticalityDiagnostics() { set(ignore); type=4;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(ignore); type=5;}
		void select_id_SeNB_UE_X2AP_ID_Extension() { set(ignore); type=6;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else if(equal(ignore)) { type = 2; return true; }
			else if(equal(ignore)) { type = 3; return true; }
			else if(equal(ignore)) { type = 4; return true; }
			else if(equal(ignore)) { type = 5; return true; }
			else if(equal(ignore)) { type = 6; return true; }
			else { type = 7; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(ignore);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(ignore);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(ignore);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(ignore);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(ignore);} return false;
			case 7: type = 7; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		UE_X2AP_ID& select_id_MeNB_UE_X2AP_ID() { return set<UE_X2AP_ID>(1); }
		UE_X2AP_ID const* get_id_MeNB_UE_X2AP_ID() const { return get<UE_X2AP_ID>(1); }
		UE_X2AP_ID& select_id_SeNB_UE_X2AP_ID() { return set<UE_X2AP_ID>(2); }
		UE_X2AP_ID const* get_id_SeNB_UE_X2AP_ID() const { return get<UE_X2AP_ID>(2); }
		Cause& select_id_Cause() { return set<Cause>(3); }
		Cause const* get_id_Cause() const { return get<Cause>(3); }
		CriticalityDiagnostics& select_id_CriticalityDiagnostics() { return set<CriticalityDiagnostics>(4); }
		CriticalityDiagnostics const* get_id_CriticalityDiagnostics() const { return get<CriticalityDiagnostics>(4); }
		UE_X2AP_ID_Extension& select_id_MeNB_UE_X2AP_ID_Extension() { return set<UE_X2AP_ID_Extension>(5); }
		UE_X2AP_ID_Extension const* get_id_MeNB_UE_X2AP_ID_Extension() const { return get<UE_X2AP_ID_Extension>(5); }
		UE_X2AP_ID_Extension& select_id_SeNB_UE_X2AP_ID_Extension() { return set<UE_X2AP_ID_Extension>(6); }
		UE_X2AP_ID_Extension const* get_id_SeNB_UE_X2AP_ID_Extension() const { return get<UE_X2AP_ID_Extension>(6); }
		bool is_unknown() const { return type == 7; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<UE_X2AP_ID>(); break;
			case 2: var.destroy<UE_X2AP_ID>(); break;
			case 3: var.destroy<Cause>(); break;
			case 4: var.destroy<CriticalityDiagnostics>(); break;
			case 5: var.destroy<UE_X2AP_ID_Extension>(); break;
			case 6: var.destroy<UE_X2AP_ID_Extension>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<UE_X2AP_ID>(1);
			v.template operator()<UE_X2AP_ID>(2);
			v.template operator()<Cause>(3);
			v.template operator()<CriticalityDiagnostics>(4);
			v.template operator()<UE_X2AP_ID_Extension>(5);
			v.template operator()<UE_X2AP_ID_Extension>(6);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_MeNB_UE_X2AP_ID()); return true;
			case 2: v(select_id_SeNB_UE_X2AP_ID()); return true;
			case 3: v(select_id_Cause()); return true;
			case 4: v(select_id_CriticalityDiagnostics()); return true;
			case 5: v(select_id_MeNB_UE_X2AP_ID_Extension()); return true;
			case 6: v(select_id_SeNB_UE_X2AP_ID_Extension()); return true;
			case 7: if(type != 7) {clear(); asn::base::set();} type = 7; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<UE_X2AP_ID>()); return true;
			case 2: v(var.as<UE_X2AP_ID>()); return true;
			case 3: v(var.as<Cause>()); return true;
			case 4: v(var.as<CriticalityDiagnostics>()); return true;
			case 5: v(var.as<UE_X2AP_ID_Extension>()); return true;
			case 6: v(var.as<UE_X2AP_ID_Extension>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(Cause)];
			char dummy2[sizeof(CriticalityDiagnostics)];
			char dummy3[sizeof(UE_X2AP_ID)];
			char dummy4[sizeof(UE_X2AP_ID_Extension)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 7; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(mandatory); type=1;}
		void select_id_SeNB_UE_X2AP_ID() { set(mandatory); type=2;}
		void select_id_Cause() { set(mandatory); type=3;}
		void select_id_CriticalityDiagnostics() { set(optional); type=4;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(optional); type=5;}
		void select_id_SeNB_UE_X2AP_ID_Extension() { set(optional); type=6;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(mandatory)) { type = 2; return true; }
			else if(equal(mandatory)) { type = 3; return true; }
			else if(equal(optional)) { type = 4; return true; }
			else if(equal(optional)) { type = 5; return true; }
			else if(equal(optional)) { type = 6; return true; }
			else { type = 7; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(optional);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(optional);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(optional);} return false;
			case 7: type = 7; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
SeNBModificationRequestReject ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{SeNBModificationRequestReject-IEs}},
	...
}
*/

struct SeNBModificationRequestReject : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "SeNBModificationRequestReject";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<SeNBModificationRequestReject_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<SeNBModificationRequestReject_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
SeNBModificationRequired-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-MeNB-UE-X2AP-ID						CRITICALITY reject	TYPE UE-X2AP-ID							PRESENCE mandatory}|
	{ ID id-SeNB-UE-X2AP-ID						CRITICALITY reject	TYPE UE-X2AP-ID							PRESENCE mandatory}|
	{ ID id-Cause								CRITICALITY ignore	TYPE Cause								PRESENCE mandatory}|
	{ ID id-SCGChangeIndication					CRITICALITY ignore	TYPE SCGChangeIndication				PRESENCE optional}|
	{ ID id-E-RABs-ToBeReleased-ModReqd			CRITICALITY ignore	TYPE E-RABs-ToBeReleased-ModReqd		PRESENCE optional}|
	{ ID id-SeNBtoMeNBContainer					CRITICALITY ignore	TYPE SeNBtoMeNBContainer				PRESENCE optional}|
	{ ID id-MeNB-UE-X2AP-ID-Extension			CRITICALITY reject	TYPE UE-X2AP-ID-Extension				PRESENCE optional}|
	{ ID id-SeNB-UE-X2AP-ID-Extension			CRITICALITY reject	TYPE UE-X2AP-ID-Extension				PRESENCE optional},
	...
}
*/

struct SeNBModificationRequired_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 9; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(id_MeNB_UE_X2AP_ID); type=1;}
		void select_id_SeNB_UE_X2AP_ID() { set(id_SeNB_UE_X2AP_ID); type=2;}
		void select_id_Cause() { set(id_Cause); type=3;}
		void select_id_SCGChangeIndication() { set(id_SCGChangeIndication); type=4;}
		void select_id_E_RABs_ToBeReleased_ModReqd() { set(id_E_RABs_ToBeReleased_ModReqd); type=5;}
		void select_id_SeNBtoMeNBContainer() { set(id_SeNBtoMeNBContainer); type=6;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(id_MeNB_UE_X2AP_ID_Extension); type=7;}
		void select_id_SeNB_UE_X2AP_ID_Extension() { set(id_SeNB_UE_X2AP_ID_Extension); type=8;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_MeNB_UE_X2AP_ID)) { type = 1; return true; }
			else if(equal(id_SeNB_UE_X2AP_ID)) { type = 2; return true; }
			else if(equal(id_Cause)) { type = 3; return true; }
			else if(equal(id_SCGChangeIndication)) { type = 4; return true; }
			else if(equal(id_E_RABs_ToBeReleased_ModReqd)) { type = 5; return true; }
			else if(equal(id_SeNBtoMeNBContainer)) { type = 6; return true; }
			else if(equal(id_MeNB_UE_X2AP_ID_Extension)) { type = 7; return true; }
			else if(equal(id_SeNB_UE_X2AP_ID_Extension)) { type = 8; return true; }
			else { type = 9; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_SeNB_UE_X2AP_ID);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_Cause);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(id_SCGChangeIndication);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(id_E_RABs_ToBeReleased_ModReqd);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(id_SeNBtoMeNBContainer);} return false;
			case 7: type = 7; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID_Extension);} return false;
			case 8: type = 8; if(v(ref_nested())) { return equal(id_SeNB_UE_X2AP_ID_Extension);} return false;
			case 9: type = 9; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 9; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(reject); type=1;}
		void select_id_SeNB_UE_X2AP_ID() { set(reject); type=2;}
		void select_id_Cause() { set(ignore); type=3;}
		void select_id_SCGChangeIndication() { set(ignore); type=4;}
		void select_id_E_RABs_ToBeReleased_ModReqd() { set(ignore); type=5;}
		void select_id_SeNBtoMeNBContainer() { set(ignore); type=6;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(reject); type=7;}
		void select_id_SeNB_UE_X2AP_ID_Extension() { set(reject); type=8;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else if(equal(reject)) { type = 2; return true; }
			else if(equal(ignore)) { type = 3; return true; }
			else if(equal(ignore)) { type = 4; return true; }
			else if(equal(ignore)) { type = 5; return true; }
			else if(equal(ignore)) { type = 6; return true; }
			else if(equal(reject)) { type = 7; return true; }
			else if(equal(reject)) { type = 8; return true; }
			else { type = 9; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(reject);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(ignore);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(ignore);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(ignore);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(ignore);} return false;
			case 7: type = 7; if(v(ref_nested())) { return equal(reject);} return false;
			case 8: type = 8; if(v(ref_nested())) { return equal(reject);} return false;
			case 9: type = 9; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		UE_X2AP_ID& select_id_MeNB_UE_X2AP_ID() { return set<UE_X2AP_ID>(1); }
		UE_X2AP_ID const* get_id_MeNB_UE_X2AP_ID() const { return get<UE_X2AP_ID>(1); }
		UE_X2AP_ID& select_id_SeNB_UE_X2AP_ID() { return set<UE_X2AP_ID>(2); }
		UE_X2AP_ID const* get_id_SeNB_UE_X2AP_ID() const { return get<UE_X2AP_ID>(2); }
		Cause& select_id_Cause() { return set<Cause>(3); }
		Cause const* get_id_Cause() const { return get<Cause>(3); }
		SCGChangeIndication& select_id_SCGChangeIndication() { return set<SCGChangeIndication>(4); }
		SCGChangeIndication const* get_id_SCGChangeIndication() const { return get<SCGChangeIndication>(4); }
		E_RABs_ToBeReleased_ModReqd& select_id_E_RABs_ToBeReleased_ModReqd() { return set<E_RABs_ToBeReleased_ModReqd>(5); }
		E_RABs_ToBeReleased_ModReqd const* get_id_E_RABs_ToBeReleased_ModReqd() const { return get<E_RABs_ToBeReleased_ModReqd>(5); }
		SeNBtoMeNBContainer& select_id_SeNBtoMeNBContainer() { return set<SeNBtoMeNBContainer>(6); }
		SeNBtoMeNBContainer const* get_id_SeNBtoMeNBContainer() const { return get<SeNBtoMeNBContainer>(6); }
		UE_X2AP_ID_Extension& select_id_MeNB_UE_X2AP_ID_Extension() { return set<UE_X2AP_ID_Extension>(7); }
		UE_X2AP_ID_Extension const* get_id_MeNB_UE_X2AP_ID_Extension() const { return get<UE_X2AP_ID_Extension>(7); }
		UE_X2AP_ID_Extension& select_id_SeNB_UE_X2AP_ID_Extension() { return set<UE_X2AP_ID_Extension>(8); }
		UE_X2AP_ID_Extension const* get_id_SeNB_UE_X2AP_ID_Extension() const { return get<UE_X2AP_ID_Extension>(8); }
		bool is_unknown() const { return type == 9; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<UE_X2AP_ID>(); break;
			case 2: var.destroy<UE_X2AP_ID>(); break;
			case 3: var.destroy<Cause>(); break;
			case 4: var.destroy<SCGChangeIndication>(); break;
			case 5: var.destroy<E_RABs_ToBeReleased_ModReqd>(); break;
			case 6: var.destroy<SeNBtoMeNBContainer>(); break;
			case 7: var.destroy<UE_X2AP_ID_Extension>(); break;
			case 8: var.destroy<UE_X2AP_ID_Extension>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<UE_X2AP_ID>(1);
			v.template operator()<UE_X2AP_ID>(2);
			v.template operator()<Cause>(3);
			v.template operator()<SCGChangeIndication>(4);
			v.template operator()<E_RABs_ToBeReleased_ModReqd>(5);
			v.template operator()<SeNBtoMeNBContainer>(6);
			v.template operator()<UE_X2AP_ID_Extension>(7);
			v.template operator()<UE_X2AP_ID_Extension>(8);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_MeNB_UE_X2AP_ID()); return true;
			case 2: v(select_id_SeNB_UE_X2AP_ID()); return true;
			case 3: v(select_id_Cause()); return true;
			case 4: v(select_id_SCGChangeIndication()); return true;
			case 5: v(select_id_E_RABs_ToBeReleased_ModReqd()); return true;
			case 6: v(select_id_SeNBtoMeNBContainer()); return true;
			case 7: v(select_id_MeNB_UE_X2AP_ID_Extension()); return true;
			case 8: v(select_id_SeNB_UE_X2AP_ID_Extension()); return true;
			case 9: if(type != 9) {clear(); asn::base::set();} type = 9; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<UE_X2AP_ID>()); return true;
			case 2: v(var.as<UE_X2AP_ID>()); return true;
			case 3: v(var.as<Cause>()); return true;
			case 4: v(var.as<SCGChangeIndication>()); return true;
			case 5: v(var.as<E_RABs_ToBeReleased_ModReqd>()); return true;
			case 6: v(var.as<SeNBtoMeNBContainer>()); return true;
			case 7: v(var.as<UE_X2AP_ID_Extension>()); return true;
			case 8: v(var.as<UE_X2AP_ID_Extension>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(Cause)];
			char dummy2[sizeof(E_RABs_ToBeReleased_ModReqd)];
			char dummy3[sizeof(SCGChangeIndication)];
			char dummy4[sizeof(SeNBtoMeNBContainer)];
			char dummy5[sizeof(UE_X2AP_ID)];
			char dummy6[sizeof(UE_X2AP_ID_Extension)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 9; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(mandatory); type=1;}
		void select_id_SeNB_UE_X2AP_ID() { set(mandatory); type=2;}
		void select_id_Cause() { set(mandatory); type=3;}
		void select_id_SCGChangeIndication() { set(optional); type=4;}
		void select_id_E_RABs_ToBeReleased_ModReqd() { set(optional); type=5;}
		void select_id_SeNBtoMeNBContainer() { set(optional); type=6;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(optional); type=7;}
		void select_id_SeNB_UE_X2AP_ID_Extension() { set(optional); type=8;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(mandatory)) { type = 2; return true; }
			else if(equal(mandatory)) { type = 3; return true; }
			else if(equal(optional)) { type = 4; return true; }
			else if(equal(optional)) { type = 5; return true; }
			else if(equal(optional)) { type = 6; return true; }
			else if(equal(optional)) { type = 7; return true; }
			else if(equal(optional)) { type = 8; return true; }
			else { type = 9; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(optional);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(optional);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(optional);} return false;
			case 7: type = 7; if(v(ref_nested())) { return equal(optional);} return false;
			case 8: type = 8; if(v(ref_nested())) { return equal(optional);} return false;
			case 9: type = 9; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
SeNBModificationRequired ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container		{{SeNBModificationRequired-IEs}},
	...
}
*/

struct SeNBModificationRequired : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "SeNBModificationRequired";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<SeNBModificationRequired_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<SeNBModificationRequired_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
SeNBReconfigurationComplete-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-MeNB-UE-X2AP-ID							CRITICALITY reject	TYPE UE-X2AP-ID									PRESENCE mandatory}|
	{ ID id-SeNB-UE-X2AP-ID							CRITICALITY reject	TYPE UE-X2AP-ID									PRESENCE mandatory}|
	{ ID id-ResponseInformationSeNBReconfComp		CRITICALITY ignore	TYPE ResponseInformationSeNBReconfComp	PRESENCE mandatory}|
	{ ID id-MeNB-UE-X2AP-ID-Extension				CRITICALITY reject	TYPE UE-X2AP-ID-Extension						PRESENCE optional}|
	{ ID id-SeNB-UE-X2AP-ID-Extension				CRITICALITY reject	TYPE UE-X2AP-ID-Extension						PRESENCE optional},
	...
}
*/

struct SeNBReconfigurationComplete_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 6; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(id_MeNB_UE_X2AP_ID); type=1;}
		void select_id_SeNB_UE_X2AP_ID() { set(id_SeNB_UE_X2AP_ID); type=2;}
		void select_id_ResponseInformationSeNBReconfComp() { set(id_ResponseInformationSeNBReconfComp); type=3;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(id_MeNB_UE_X2AP_ID_Extension); type=4;}
		void select_id_SeNB_UE_X2AP_ID_Extension() { set(id_SeNB_UE_X2AP_ID_Extension); type=5;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_MeNB_UE_X2AP_ID)) { type = 1; return true; }
			else if(equal(id_SeNB_UE_X2AP_ID)) { type = 2; return true; }
			else if(equal(id_ResponseInformationSeNBReconfComp)) { type = 3; return true; }
			else if(equal(id_MeNB_UE_X2AP_ID_Extension)) { type = 4; return true; }
			else if(equal(id_SeNB_UE_X2AP_ID_Extension)) { type = 5; return true; }
			else { type = 6; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_SeNB_UE_X2AP_ID);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_ResponseInformationSeNBReconfComp);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID_Extension);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(id_SeNB_UE_X2AP_ID_Extension);} return false;
			case 6: type = 6; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 6; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(reject); type=1;}
		void select_id_SeNB_UE_X2AP_ID() { set(reject); type=2;}
		void select_id_ResponseInformationSeNBReconfComp() { set(ignore); type=3;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(reject); type=4;}
		void select_id_SeNB_UE_X2AP_ID_Extension() { set(reject); type=5;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else if(equal(reject)) { type = 2; return true; }
			else if(equal(ignore)) { type = 3; return true; }
			else if(equal(reject)) { type = 4; return true; }
			else if(equal(reject)) { type = 5; return true; }
			else { type = 6; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(reject);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(ignore);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(reject);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(reject);} return false;
			case 6: type = 6; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		UE_X2AP_ID& select_id_MeNB_UE_X2AP_ID() { return set<UE_X2AP_ID>(1); }
		UE_X2AP_ID const* get_id_MeNB_UE_X2AP_ID() const { return get<UE_X2AP_ID>(1); }
		UE_X2AP_ID& select_id_SeNB_UE_X2AP_ID() { return set<UE_X2AP_ID>(2); }
		UE_X2AP_ID const* get_id_SeNB_UE_X2AP_ID() const { return get<UE_X2AP_ID>(2); }
		ResponseInformationSeNBReconfComp& select_id_ResponseInformationSeNBReconfComp() { return set<ResponseInformationSeNBReconfComp>(3); }
		ResponseInformationSeNBReconfComp const* get_id_ResponseInformationSeNBReconfComp() const { return get<ResponseInformationSeNBReconfComp>(3); }
		UE_X2AP_ID_Extension& select_id_MeNB_UE_X2AP_ID_Extension() { return set<UE_X2AP_ID_Extension>(4); }
		UE_X2AP_ID_Extension const* get_id_MeNB_UE_X2AP_ID_Extension() const { return get<UE_X2AP_ID_Extension>(4); }
		UE_X2AP_ID_Extension& select_id_SeNB_UE_X2AP_ID_Extension() { return set<UE_X2AP_ID_Extension>(5); }
		UE_X2AP_ID_Extension const* get_id_SeNB_UE_X2AP_ID_Extension() const { return get<UE_X2AP_ID_Extension>(5); }
		bool is_unknown() const { return type == 6; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<UE_X2AP_ID>(); break;
			case 2: var.destroy<UE_X2AP_ID>(); break;
			case 3: var.destroy<ResponseInformationSeNBReconfComp>(); break;
			case 4: var.destroy<UE_X2AP_ID_Extension>(); break;
			case 5: var.destroy<UE_X2AP_ID_Extension>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<UE_X2AP_ID>(1);
			v.template operator()<UE_X2AP_ID>(2);
			v.template operator()<ResponseInformationSeNBReconfComp>(3);
			v.template operator()<UE_X2AP_ID_Extension>(4);
			v.template operator()<UE_X2AP_ID_Extension>(5);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_MeNB_UE_X2AP_ID()); return true;
			case 2: v(select_id_SeNB_UE_X2AP_ID()); return true;
			case 3: v(select_id_ResponseInformationSeNBReconfComp()); return true;
			case 4: v(select_id_MeNB_UE_X2AP_ID_Extension()); return true;
			case 5: v(select_id_SeNB_UE_X2AP_ID_Extension()); return true;
			case 6: if(type != 6) {clear(); asn::base::set();} type = 6; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<UE_X2AP_ID>()); return true;
			case 2: v(var.as<UE_X2AP_ID>()); return true;
			case 3: v(var.as<ResponseInformationSeNBReconfComp>()); return true;
			case 4: v(var.as<UE_X2AP_ID_Extension>()); return true;
			case 5: v(var.as<UE_X2AP_ID_Extension>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(ResponseInformationSeNBReconfComp)];
			char dummy2[sizeof(UE_X2AP_ID)];
			char dummy3[sizeof(UE_X2AP_ID_Extension)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 6; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(mandatory); type=1;}
		void select_id_SeNB_UE_X2AP_ID() { set(mandatory); type=2;}
		void select_id_ResponseInformationSeNBReconfComp() { set(mandatory); type=3;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(optional); type=4;}
		void select_id_SeNB_UE_X2AP_ID_Extension() { set(optional); type=5;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(mandatory)) { type = 2; return true; }
			else if(equal(mandatory)) { type = 3; return true; }
			else if(equal(optional)) { type = 4; return true; }
			else if(equal(optional)) { type = 5; return true; }
			else { type = 6; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(optional);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(optional);} return false;
			case 6: type = 6; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
SeNBReconfigurationComplete ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{SeNBReconfigurationComplete-IEs}},
	...
}
*/

struct SeNBReconfigurationComplete : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "SeNBReconfigurationComplete";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<SeNBReconfigurationComplete_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<SeNBReconfigurationComplete_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
SeNBReleaseConfirm-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-MeNB-UE-X2AP-ID							CRITICALITY ignore	TYPE UE-X2AP-ID									PRESENCE mandatory}|
	{ ID id-SeNB-UE-X2AP-ID							CRITICALITY ignore	TYPE UE-X2AP-ID									PRESENCE mandatory}|
	{ ID id-E-RABs-ToBeReleased-List-RelConf		CRITICALITY ignore	TYPE E-RABs-ToBeReleased-List-RelConf		PRESENCE optional}|
	{ ID id-CriticalityDiagnostics					CRITICALITY ignore	TYPE CriticalityDiagnostics					PRESENCE optional}|
	{ ID id-MeNB-UE-X2AP-ID-Extension				CRITICALITY ignore	TYPE UE-X2AP-ID-Extension						PRESENCE optional}|
	{ ID id-SeNB-UE-X2AP-ID-Extension				CRITICALITY ignore	TYPE UE-X2AP-ID-Extension						PRESENCE optional},
	...
}
*/

struct SeNBReleaseConfirm_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 7; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(id_MeNB_UE_X2AP_ID); type=1;}
		void select_id_SeNB_UE_X2AP_ID() { set(id_SeNB_UE_X2AP_ID); type=2;}
		void select_id_E_RABs_ToBeReleased_List_RelConf() { set(id_E_RABs_ToBeReleased_List_RelConf); type=3;}
		void select_id_CriticalityDiagnostics() { set(id_CriticalityDiagnostics); type=4;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(id_MeNB_UE_X2AP_ID_Extension); type=5;}
		void select_id_SeNB_UE_X2AP_ID_Extension() { set(id_SeNB_UE_X2AP_ID_Extension); type=6;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_MeNB_UE_X2AP_ID)) { type = 1; return true; }
			else if(equal(id_SeNB_UE_X2AP_ID)) { type = 2; return true; }
			else if(equal(id_E_RABs_ToBeReleased_List_RelConf)) { type = 3; return true; }
			else if(equal(id_CriticalityDiagnostics)) { type = 4; return true; }
			else if(equal(id_MeNB_UE_X2AP_ID_Extension)) { type = 5; return true; }
			else if(equal(id_SeNB_UE_X2AP_ID_Extension)) { type = 6; return true; }
			else { type = 7; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_SeNB_UE_X2AP_ID);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_E_RABs_ToBeReleased_List_RelConf);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(id_CriticalityDiagnostics);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID_Extension);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(id_SeNB_UE_X2AP_ID_Extension);} return false;
			case 7: type = 7; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 7; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(ignore); type=1;}
		void select_id_SeNB_UE_X2AP_ID() { set(ignore); type=2;}
		void select_id_E_RABs_ToBeReleased_List_RelConf() { set(ignore); type=3;}
		void select_id_CriticalityDiagnostics() { set(ignore); type=4;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(ignore); type=5;}
		void select_id_SeNB_UE_X2AP_ID_Extension() { set(ignore); type=6;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else if(equal(ignore)) { type = 2; return true; }
			else if(equal(ignore)) { type = 3; return true; }
			else if(equal(ignore)) { type = 4; return true; }
			else if(equal(ignore)) { type = 5; return true; }
			else if(equal(ignore)) { type = 6; return true; }
			else { type = 7; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(ignore);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(ignore);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(ignore);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(ignore);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(ignore);} return false;
			case 7: type = 7; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		UE_X2AP_ID& select_id_MeNB_UE_X2AP_ID() { return set<UE_X2AP_ID>(1); }
		UE_X2AP_ID const* get_id_MeNB_UE_X2AP_ID() const { return get<UE_X2AP_ID>(1); }
		UE_X2AP_ID& select_id_SeNB_UE_X2AP_ID() { return set<UE_X2AP_ID>(2); }
		UE_X2AP_ID const* get_id_SeNB_UE_X2AP_ID() const { return get<UE_X2AP_ID>(2); }
		E_RABs_ToBeReleased_List_RelConf& select_id_E_RABs_ToBeReleased_List_RelConf() { return set<E_RABs_ToBeReleased_List_RelConf>(3); }
		E_RABs_ToBeReleased_List_RelConf const* get_id_E_RABs_ToBeReleased_List_RelConf() const { return get<E_RABs_ToBeReleased_List_RelConf>(3); }
		CriticalityDiagnostics& select_id_CriticalityDiagnostics() { return set<CriticalityDiagnostics>(4); }
		CriticalityDiagnostics const* get_id_CriticalityDiagnostics() const { return get<CriticalityDiagnostics>(4); }
		UE_X2AP_ID_Extension& select_id_MeNB_UE_X2AP_ID_Extension() { return set<UE_X2AP_ID_Extension>(5); }
		UE_X2AP_ID_Extension const* get_id_MeNB_UE_X2AP_ID_Extension() const { return get<UE_X2AP_ID_Extension>(5); }
		UE_X2AP_ID_Extension& select_id_SeNB_UE_X2AP_ID_Extension() { return set<UE_X2AP_ID_Extension>(6); }
		UE_X2AP_ID_Extension const* get_id_SeNB_UE_X2AP_ID_Extension() const { return get<UE_X2AP_ID_Extension>(6); }
		bool is_unknown() const { return type == 7; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<UE_X2AP_ID>(); break;
			case 2: var.destroy<UE_X2AP_ID>(); break;
			case 3: var.destroy<E_RABs_ToBeReleased_List_RelConf>(); break;
			case 4: var.destroy<CriticalityDiagnostics>(); break;
			case 5: var.destroy<UE_X2AP_ID_Extension>(); break;
			case 6: var.destroy<UE_X2AP_ID_Extension>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<UE_X2AP_ID>(1);
			v.template operator()<UE_X2AP_ID>(2);
			v.template operator()<E_RABs_ToBeReleased_List_RelConf>(3);
			v.template operator()<CriticalityDiagnostics>(4);
			v.template operator()<UE_X2AP_ID_Extension>(5);
			v.template operator()<UE_X2AP_ID_Extension>(6);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_MeNB_UE_X2AP_ID()); return true;
			case 2: v(select_id_SeNB_UE_X2AP_ID()); return true;
			case 3: v(select_id_E_RABs_ToBeReleased_List_RelConf()); return true;
			case 4: v(select_id_CriticalityDiagnostics()); return true;
			case 5: v(select_id_MeNB_UE_X2AP_ID_Extension()); return true;
			case 6: v(select_id_SeNB_UE_X2AP_ID_Extension()); return true;
			case 7: if(type != 7) {clear(); asn::base::set();} type = 7; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<UE_X2AP_ID>()); return true;
			case 2: v(var.as<UE_X2AP_ID>()); return true;
			case 3: v(var.as<E_RABs_ToBeReleased_List_RelConf>()); return true;
			case 4: v(var.as<CriticalityDiagnostics>()); return true;
			case 5: v(var.as<UE_X2AP_ID_Extension>()); return true;
			case 6: v(var.as<UE_X2AP_ID_Extension>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(CriticalityDiagnostics)];
			char dummy2[sizeof(E_RABs_ToBeReleased_List_RelConf)];
			char dummy3[sizeof(UE_X2AP_ID)];
			char dummy4[sizeof(UE_X2AP_ID_Extension)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 7; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(mandatory); type=1;}
		void select_id_SeNB_UE_X2AP_ID() { set(mandatory); type=2;}
		void select_id_E_RABs_ToBeReleased_List_RelConf() { set(optional); type=3;}
		void select_id_CriticalityDiagnostics() { set(optional); type=4;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(optional); type=5;}
		void select_id_SeNB_UE_X2AP_ID_Extension() { set(optional); type=6;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(mandatory)) { type = 2; return true; }
			else if(equal(optional)) { type = 3; return true; }
			else if(equal(optional)) { type = 4; return true; }
			else if(equal(optional)) { type = 5; return true; }
			else if(equal(optional)) { type = 6; return true; }
			else { type = 7; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(optional);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(optional);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(optional);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(optional);} return false;
			case 7: type = 7; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
SeNBReleaseConfirm ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{SeNBReleaseConfirm-IEs}},
	...
}
*/

struct SeNBReleaseConfirm : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "SeNBReleaseConfirm";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<SeNBReleaseConfirm_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<SeNBReleaseConfirm_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
SeNBReleaseRequest-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-MeNB-UE-X2AP-ID						CRITICALITY reject	TYPE UE-X2AP-ID									PRESENCE mandatory}|
	{ ID id-SeNB-UE-X2AP-ID						CRITICALITY reject	TYPE UE-X2AP-ID									PRESENCE optional}|
	{ ID id-Cause								CRITICALITY ignore	TYPE Cause										PRESENCE optional}|
	{ ID id-E-RABs-ToBeReleased-List-RelReq		CRITICALITY ignore	TYPE E-RABs-ToBeReleased-List-RelReq		PRESENCE optional}|
	{ ID id-UE-ContextKeptIndicator				CRITICALITY ignore	TYPE UE-ContextKeptIndicator					PRESENCE optional}|
	{ ID id-MeNB-UE-X2AP-ID-Extension			CRITICALITY reject	TYPE UE-X2AP-ID-Extension						PRESENCE optional}|
	{ ID id-SeNB-UE-X2AP-ID-Extension			CRITICALITY reject	TYPE UE-X2AP-ID-Extension						PRESENCE optional}|
	{ ID id-MakeBeforeBreakIndicator			CRITICALITY ignore	TYPE MakeBeforeBreakIndicator					PRESENCE optional},
	...
}
*/

struct SeNBReleaseRequest_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 9; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(id_MeNB_UE_X2AP_ID); type=1;}
		void select_id_SeNB_UE_X2AP_ID() { set(id_SeNB_UE_X2AP_ID); type=2;}
		void select_id_Cause() { set(id_Cause); type=3;}
		void select_id_E_RABs_ToBeReleased_List_RelReq() { set(id_E_RABs_ToBeReleased_List_RelReq); type=4;}
		void select_id_UE_ContextKeptIndicator() { set(id_UE_ContextKeptIndicator); type=5;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(id_MeNB_UE_X2AP_ID_Extension); type=6;}
		void select_id_SeNB_UE_X2AP_ID_Extension() { set(id_SeNB_UE_X2AP_ID_Extension); type=7;}
		void select_id_MakeBeforeBreakIndicator() { set(id_MakeBeforeBreakIndicator); type=8;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_MeNB_UE_X2AP_ID)) { type = 1; return true; }
			else if(equal(id_SeNB_UE_X2AP_ID)) { type = 2; return true; }
			else if(equal(id_Cause)) { type = 3; return true; }
			else if(equal(id_E_RABs_ToBeReleased_List_RelReq)) { type = 4; return true; }
			else if(equal(id_UE_ContextKeptIndicator)) { type = 5; return true; }
			else if(equal(id_MeNB_UE_X2AP_ID_Extension)) { type = 6; return true; }
			else if(equal(id_SeNB_UE_X2AP_ID_Extension)) { type = 7; return true; }
			else if(equal(id_MakeBeforeBreakIndicator)) { type = 8; return true; }
			else { type = 9; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_SeNB_UE_X2AP_ID);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_Cause);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(id_E_RABs_ToBeReleased_List_RelReq);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(id_UE_ContextKeptIndicator);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID_Extension);} return false;
			case 7: type = 7; if(v(ref_nested())) { return equal(id_SeNB_UE_X2AP_ID_Extension);} return false;
			case 8: type = 8; if(v(ref_nested())) { return equal(id_MakeBeforeBreakIndicator);} return false;
			case 9: type = 9; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 9; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(reject); type=1;}
		void select_id_SeNB_UE_X2AP_ID() { set(reject); type=2;}
		void select_id_Cause() { set(ignore); type=3;}
		void select_id_E_RABs_ToBeReleased_List_RelReq() { set(ignore); type=4;}
		void select_id_UE_ContextKeptIndicator() { set(ignore); type=5;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(reject); type=6;}
		void select_id_SeNB_UE_X2AP_ID_Extension() { set(reject); type=7;}
		void select_id_MakeBeforeBreakIndicator() { set(ignore); type=8;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else if(equal(reject)) { type = 2; return true; }
			else if(equal(ignore)) { type = 3; return true; }
			else if(equal(ignore)) { type = 4; return true; }
			else if(equal(ignore)) { type = 5; return true; }
			else if(equal(reject)) { type = 6; return true; }
			else if(equal(reject)) { type = 7; return true; }
			else if(equal(ignore)) { type = 8; return true; }
			else { type = 9; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(reject);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(ignore);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(ignore);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(ignore);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(reject);} return false;
			case 7: type = 7; if(v(ref_nested())) { return equal(reject);} return false;
			case 8: type = 8; if(v(ref_nested())) { return equal(ignore);} return false;
			case 9: type = 9; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		UE_X2AP_ID& select_id_MeNB_UE_X2AP_ID() { return set<UE_X2AP_ID>(1); }
		UE_X2AP_ID const* get_id_MeNB_UE_X2AP_ID() const { return get<UE_X2AP_ID>(1); }
		UE_X2AP_ID& select_id_SeNB_UE_X2AP_ID() { return set<UE_X2AP_ID>(2); }
		UE_X2AP_ID const* get_id_SeNB_UE_X2AP_ID() const { return get<UE_X2AP_ID>(2); }
		Cause& select_id_Cause() { return set<Cause>(3); }
		Cause const* get_id_Cause() const { return get<Cause>(3); }
		E_RABs_ToBeReleased_List_RelReq& select_id_E_RABs_ToBeReleased_List_RelReq() { return set<E_RABs_ToBeReleased_List_RelReq>(4); }
		E_RABs_ToBeReleased_List_RelReq const* get_id_E_RABs_ToBeReleased_List_RelReq() const { return get<E_RABs_ToBeReleased_List_RelReq>(4); }
		UE_ContextKeptIndicator& select_id_UE_ContextKeptIndicator() { return set<UE_ContextKeptIndicator>(5); }
		UE_ContextKeptIndicator const* get_id_UE_ContextKeptIndicator() const { return get<UE_ContextKeptIndicator>(5); }
		UE_X2AP_ID_Extension& select_id_MeNB_UE_X2AP_ID_Extension() { return set<UE_X2AP_ID_Extension>(6); }
		UE_X2AP_ID_Extension const* get_id_MeNB_UE_X2AP_ID_Extension() const { return get<UE_X2AP_ID_Extension>(6); }
		UE_X2AP_ID_Extension& select_id_SeNB_UE_X2AP_ID_Extension() { return set<UE_X2AP_ID_Extension>(7); }
		UE_X2AP_ID_Extension const* get_id_SeNB_UE_X2AP_ID_Extension() const { return get<UE_X2AP_ID_Extension>(7); }
		MakeBeforeBreakIndicator& select_id_MakeBeforeBreakIndicator() { return set<MakeBeforeBreakIndicator>(8); }
		MakeBeforeBreakIndicator const* get_id_MakeBeforeBreakIndicator() const { return get<MakeBeforeBreakIndicator>(8); }
		bool is_unknown() const { return type == 9; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<UE_X2AP_ID>(); break;
			case 2: var.destroy<UE_X2AP_ID>(); break;
			case 3: var.destroy<Cause>(); break;
			case 4: var.destroy<E_RABs_ToBeReleased_List_RelReq>(); break;
			case 5: var.destroy<UE_ContextKeptIndicator>(); break;
			case 6: var.destroy<UE_X2AP_ID_Extension>(); break;
			case 7: var.destroy<UE_X2AP_ID_Extension>(); break;
			case 8: var.destroy<MakeBeforeBreakIndicator>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<UE_X2AP_ID>(1);
			v.template operator()<UE_X2AP_ID>(2);
			v.template operator()<Cause>(3);
			v.template operator()<E_RABs_ToBeReleased_List_RelReq>(4);
			v.template operator()<UE_ContextKeptIndicator>(5);
			v.template operator()<UE_X2AP_ID_Extension>(6);
			v.template operator()<UE_X2AP_ID_Extension>(7);
			v.template operator()<MakeBeforeBreakIndicator>(8);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_MeNB_UE_X2AP_ID()); return true;
			case 2: v(select_id_SeNB_UE_X2AP_ID()); return true;
			case 3: v(select_id_Cause()); return true;
			case 4: v(select_id_E_RABs_ToBeReleased_List_RelReq()); return true;
			case 5: v(select_id_UE_ContextKeptIndicator()); return true;
			case 6: v(select_id_MeNB_UE_X2AP_ID_Extension()); return true;
			case 7: v(select_id_SeNB_UE_X2AP_ID_Extension()); return true;
			case 8: v(select_id_MakeBeforeBreakIndicator()); return true;
			case 9: if(type != 9) {clear(); asn::base::set();} type = 9; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<UE_X2AP_ID>()); return true;
			case 2: v(var.as<UE_X2AP_ID>()); return true;
			case 3: v(var.as<Cause>()); return true;
			case 4: v(var.as<E_RABs_ToBeReleased_List_RelReq>()); return true;
			case 5: v(var.as<UE_ContextKeptIndicator>()); return true;
			case 6: v(var.as<UE_X2AP_ID_Extension>()); return true;
			case 7: v(var.as<UE_X2AP_ID_Extension>()); return true;
			case 8: v(var.as<MakeBeforeBreakIndicator>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(Cause)];
			char dummy2[sizeof(E_RABs_ToBeReleased_List_RelReq)];
			char dummy3[sizeof(MakeBeforeBreakIndicator)];
			char dummy4[sizeof(UE_ContextKeptIndicator)];
			char dummy5[sizeof(UE_X2AP_ID)];
			char dummy6[sizeof(UE_X2AP_ID_Extension)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 9; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(mandatory); type=1;}
		void select_id_SeNB_UE_X2AP_ID() { set(optional); type=2;}
		void select_id_Cause() { set(optional); type=3;}
		void select_id_E_RABs_ToBeReleased_List_RelReq() { set(optional); type=4;}
		void select_id_UE_ContextKeptIndicator() { set(optional); type=5;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(optional); type=6;}
		void select_id_SeNB_UE_X2AP_ID_Extension() { set(optional); type=7;}
		void select_id_MakeBeforeBreakIndicator() { set(optional); type=8;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(optional)) { type = 2; return true; }
			else if(equal(optional)) { type = 3; return true; }
			else if(equal(optional)) { type = 4; return true; }
			else if(equal(optional)) { type = 5; return true; }
			else if(equal(optional)) { type = 6; return true; }
			else if(equal(optional)) { type = 7; return true; }
			else if(equal(optional)) { type = 8; return true; }
			else { type = 9; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(optional);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(optional);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(optional);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(optional);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(optional);} return false;
			case 7: type = 7; if(v(ref_nested())) { return equal(optional);} return false;
			case 8: type = 8; if(v(ref_nested())) { return equal(optional);} return false;
			case 9: type = 9; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
SeNBReleaseRequest ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container		{{SeNBReleaseRequest-IEs}},
	...
}
*/

struct SeNBReleaseRequest : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "SeNBReleaseRequest";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<SeNBReleaseRequest_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<SeNBReleaseRequest_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
SeNBReleaseRequired-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-MeNB-UE-X2AP-ID					CRITICALITY reject	TYPE UE-X2AP-ID					PRESENCE mandatory}|
	{ ID id-SeNB-UE-X2AP-ID					CRITICALITY reject	TYPE UE-X2AP-ID					PRESENCE mandatory}|
	{ ID id-Cause							CRITICALITY ignore	TYPE Cause						PRESENCE mandatory}|
	{ ID id-MeNB-UE-X2AP-ID-Extension		CRITICALITY reject	TYPE UE-X2AP-ID-Extension		PRESENCE optional}|
	{ ID id-SeNB-UE-X2AP-ID-Extension		CRITICALITY reject	TYPE UE-X2AP-ID-Extension		PRESENCE optional},
	...
}
*/

struct SeNBReleaseRequired_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 6; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(id_MeNB_UE_X2AP_ID); type=1;}
		void select_id_SeNB_UE_X2AP_ID() { set(id_SeNB_UE_X2AP_ID); type=2;}
		void select_id_Cause() { set(id_Cause); type=3;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(id_MeNB_UE_X2AP_ID_Extension); type=4;}
		void select_id_SeNB_UE_X2AP_ID_Extension() { set(id_SeNB_UE_X2AP_ID_Extension); type=5;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_MeNB_UE_X2AP_ID)) { type = 1; return true; }
			else if(equal(id_SeNB_UE_X2AP_ID)) { type = 2; return true; }
			else if(equal(id_Cause)) { type = 3; return true; }
			else if(equal(id_MeNB_UE_X2AP_ID_Extension)) { type = 4; return true; }
			else if(equal(id_SeNB_UE_X2AP_ID_Extension)) { type = 5; return true; }
			else { type = 6; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_SeNB_UE_X2AP_ID);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_Cause);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID_Extension);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(id_SeNB_UE_X2AP_ID_Extension);} return false;
			case 6: type = 6; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 6; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(reject); type=1;}
		void select_id_SeNB_UE_X2AP_ID() { set(reject); type=2;}
		void select_id_Cause() { set(ignore); type=3;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(reject); type=4;}
		void select_id_SeNB_UE_X2AP_ID_Extension() { set(reject); type=5;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else if(equal(reject)) { type = 2; return true; }
			else if(equal(ignore)) { type = 3; return true; }
			else if(equal(reject)) { type = 4; return true; }
			else if(equal(reject)) { type = 5; return true; }
			else { type = 6; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(reject);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(ignore);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(reject);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(reject);} return false;
			case 6: type = 6; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		UE_X2AP_ID& select_id_MeNB_UE_X2AP_ID() { return set<UE_X2AP_ID>(1); }
		UE_X2AP_ID const* get_id_MeNB_UE_X2AP_ID() const { return get<UE_X2AP_ID>(1); }
		UE_X2AP_ID& select_id_SeNB_UE_X2AP_ID() { return set<UE_X2AP_ID>(2); }
		UE_X2AP_ID const* get_id_SeNB_UE_X2AP_ID() const { return get<UE_X2AP_ID>(2); }
		Cause& select_id_Cause() { return set<Cause>(3); }
		Cause const* get_id_Cause() const { return get<Cause>(3); }
		UE_X2AP_ID_Extension& select_id_MeNB_UE_X2AP_ID_Extension() { return set<UE_X2AP_ID_Extension>(4); }
		UE_X2AP_ID_Extension const* get_id_MeNB_UE_X2AP_ID_Extension() const { return get<UE_X2AP_ID_Extension>(4); }
		UE_X2AP_ID_Extension& select_id_SeNB_UE_X2AP_ID_Extension() { return set<UE_X2AP_ID_Extension>(5); }
		UE_X2AP_ID_Extension const* get_id_SeNB_UE_X2AP_ID_Extension() const { return get<UE_X2AP_ID_Extension>(5); }
		bool is_unknown() const { return type == 6; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<UE_X2AP_ID>(); break;
			case 2: var.destroy<UE_X2AP_ID>(); break;
			case 3: var.destroy<Cause>(); break;
			case 4: var.destroy<UE_X2AP_ID_Extension>(); break;
			case 5: var.destroy<UE_X2AP_ID_Extension>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<UE_X2AP_ID>(1);
			v.template operator()<UE_X2AP_ID>(2);
			v.template operator()<Cause>(3);
			v.template operator()<UE_X2AP_ID_Extension>(4);
			v.template operator()<UE_X2AP_ID_Extension>(5);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_MeNB_UE_X2AP_ID()); return true;
			case 2: v(select_id_SeNB_UE_X2AP_ID()); return true;
			case 3: v(select_id_Cause()); return true;
			case 4: v(select_id_MeNB_UE_X2AP_ID_Extension()); return true;
			case 5: v(select_id_SeNB_UE_X2AP_ID_Extension()); return true;
			case 6: if(type != 6) {clear(); asn::base::set();} type = 6; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<UE_X2AP_ID>()); return true;
			case 2: v(var.as<UE_X2AP_ID>()); return true;
			case 3: v(var.as<Cause>()); return true;
			case 4: v(var.as<UE_X2AP_ID_Extension>()); return true;
			case 5: v(var.as<UE_X2AP_ID_Extension>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(Cause)];
			char dummy2[sizeof(UE_X2AP_ID)];
			char dummy3[sizeof(UE_X2AP_ID_Extension)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 6; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(mandatory); type=1;}
		void select_id_SeNB_UE_X2AP_ID() { set(mandatory); type=2;}
		void select_id_Cause() { set(mandatory); type=3;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(optional); type=4;}
		void select_id_SeNB_UE_X2AP_ID_Extension() { set(optional); type=5;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(mandatory)) { type = 2; return true; }
			else if(equal(mandatory)) { type = 3; return true; }
			else if(equal(optional)) { type = 4; return true; }
			else if(equal(optional)) { type = 5; return true; }
			else { type = 6; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(optional);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(optional);} return false;
			case 6: type = 6; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
SeNBReleaseRequired ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{SeNBReleaseRequired-IEs}},
	...
}
*/

struct SeNBReleaseRequired : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "SeNBReleaseRequired";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<SeNBReleaseRequired_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<SeNBReleaseRequired_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
SecondaryRATDataUsageReport-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-MeNB-UE-X2AP-ID						CRITICALITY reject	TYPE UE-X2AP-ID								PRESENCE mandatory}|
	{ ID id-SgNB-UE-X2AP-ID						CRITICALITY reject	TYPE SgNB-UE-X2AP-ID							PRESENCE mandatory}|
	{ ID id-SecondaryRATUsageReportList			CRITICALITY reject	TYPE SecondaryRATUsageReportList			PRESENCE mandatory}|
	{ ID id-MeNB-UE-X2AP-ID-Extension			CRITICALITY reject	TYPE UE-X2AP-ID-Extension					PRESENCE optional},
	...
}
*/

struct SecondaryRATDataUsageReport_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 5; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(id_MeNB_UE_X2AP_ID); type=1;}
		void select_id_SgNB_UE_X2AP_ID() { set(id_SgNB_UE_X2AP_ID); type=2;}
		void select_id_SecondaryRATUsageReportList() { set(id_SecondaryRATUsageReportList); type=3;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(id_MeNB_UE_X2AP_ID_Extension); type=4;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_MeNB_UE_X2AP_ID)) { type = 1; return true; }
			else if(equal(id_SgNB_UE_X2AP_ID)) { type = 2; return true; }
			else if(equal(id_SecondaryRATUsageReportList)) { type = 3; return true; }
			else if(equal(id_MeNB_UE_X2AP_ID_Extension)) { type = 4; return true; }
			else { type = 5; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_SgNB_UE_X2AP_ID);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_SecondaryRATUsageReportList);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID_Extension);} return false;
			case 5: type = 5; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 5; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(reject); type=1;}
		void select_id_SgNB_UE_X2AP_ID() { set(reject); type=2;}
		void select_id_SecondaryRATUsageReportList() { set(reject); type=3;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(reject); type=4;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else if(equal(reject)) { type = 2; return true; }
			else if(equal(reject)) { type = 3; return true; }
			else if(equal(reject)) { type = 4; return true; }
			else { type = 5; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(reject);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(reject);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(reject);} return false;
			case 5: type = 5; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		UE_X2AP_ID& select_id_MeNB_UE_X2AP_ID() { return set<UE_X2AP_ID>(1); }
		UE_X2AP_ID const* get_id_MeNB_UE_X2AP_ID() const { return get<UE_X2AP_ID>(1); }
		SgNB_UE_X2AP_ID& select_id_SgNB_UE_X2AP_ID() { return set<SgNB_UE_X2AP_ID>(2); }
		SgNB_UE_X2AP_ID const* get_id_SgNB_UE_X2AP_ID() const { return get<SgNB_UE_X2AP_ID>(2); }
		SecondaryRATUsageReportList& select_id_SecondaryRATUsageReportList() { return set<SecondaryRATUsageReportList>(3); }
		SecondaryRATUsageReportList const* get_id_SecondaryRATUsageReportList() const { return get<SecondaryRATUsageReportList>(3); }
		UE_X2AP_ID_Extension& select_id_MeNB_UE_X2AP_ID_Extension() { return set<UE_X2AP_ID_Extension>(4); }
		UE_X2AP_ID_Extension const* get_id_MeNB_UE_X2AP_ID_Extension() const { return get<UE_X2AP_ID_Extension>(4); }
		bool is_unknown() const { return type == 5; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<UE_X2AP_ID>(); break;
			case 2: var.destroy<SgNB_UE_X2AP_ID>(); break;
			case 3: var.destroy<SecondaryRATUsageReportList>(); break;
			case 4: var.destroy<UE_X2AP_ID_Extension>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<UE_X2AP_ID>(1);
			v.template operator()<SgNB_UE_X2AP_ID>(2);
			v.template operator()<SecondaryRATUsageReportList>(3);
			v.template operator()<UE_X2AP_ID_Extension>(4);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_MeNB_UE_X2AP_ID()); return true;
			case 2: v(select_id_SgNB_UE_X2AP_ID()); return true;
			case 3: v(select_id_SecondaryRATUsageReportList()); return true;
			case 4: v(select_id_MeNB_UE_X2AP_ID_Extension()); return true;
			case 5: if(type != 5) {clear(); asn::base::set();} type = 5; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<UE_X2AP_ID>()); return true;
			case 2: v(var.as<SgNB_UE_X2AP_ID>()); return true;
			case 3: v(var.as<SecondaryRATUsageReportList>()); return true;
			case 4: v(var.as<UE_X2AP_ID_Extension>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(SecondaryRATUsageReportList)];
			char dummy2[sizeof(SgNB_UE_X2AP_ID)];
			char dummy3[sizeof(UE_X2AP_ID)];
			char dummy4[sizeof(UE_X2AP_ID_Extension)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 5; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(mandatory); type=1;}
		void select_id_SgNB_UE_X2AP_ID() { set(mandatory); type=2;}
		void select_id_SecondaryRATUsageReportList() { set(mandatory); type=3;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(optional); type=4;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(mandatory)) { type = 2; return true; }
			else if(equal(mandatory)) { type = 3; return true; }
			else if(equal(optional)) { type = 4; return true; }
			else { type = 5; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(optional);} return false;
			case 5: type = 5; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
SecondaryRATDataUsageReport ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container		{{SecondaryRATDataUsageReport-IEs}},
	...
}
*/

struct SecondaryRATDataUsageReport : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "SecondaryRATDataUsageReport";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<SecondaryRATDataUsageReport_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<SecondaryRATDataUsageReport_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
SgNBActivityNotification-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-MeNB-UE-X2AP-ID						CRITICALITY reject	TYPE UE-X2AP-ID								PRESENCE mandatory}|
	{ ID id-SgNB-UE-X2AP-ID						CRITICALITY reject	TYPE SgNB-UE-X2AP-ID							PRESENCE mandatory}|
	{ ID id-UEContextLevelUserPlaneActivity		CRITICALITY ignore	TYPE UserPlaneTrafficActivityReport		PRESENCE optional}|
	{ ID id-ERABActivityNotifyItemList			CRITICALITY ignore	TYPE ERABActivityNotifyItemList			PRESENCE optional}|
	{ ID id-MeNB-UE-X2AP-ID-Extension			CRITICALITY reject	TYPE UE-X2AP-ID-Extension					PRESENCE optional},
	...
}
*/

struct SgNBActivityNotification_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 6; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(id_MeNB_UE_X2AP_ID); type=1;}
		void select_id_SgNB_UE_X2AP_ID() { set(id_SgNB_UE_X2AP_ID); type=2;}
		void select_id_UEContextLevelUserPlaneActivity() { set(id_UEContextLevelUserPlaneActivity); type=3;}
		void select_id_ERABActivityNotifyItemList() { set(id_ERABActivityNotifyItemList); type=4;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(id_MeNB_UE_X2AP_ID_Extension); type=5;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_MeNB_UE_X2AP_ID)) { type = 1; return true; }
			else if(equal(id_SgNB_UE_X2AP_ID)) { type = 2; return true; }
			else if(equal(id_UEContextLevelUserPlaneActivity)) { type = 3; return true; }
			else if(equal(id_ERABActivityNotifyItemList)) { type = 4; return true; }
			else if(equal(id_MeNB_UE_X2AP_ID_Extension)) { type = 5; return true; }
			else { type = 6; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_SgNB_UE_X2AP_ID);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_UEContextLevelUserPlaneActivity);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(id_ERABActivityNotifyItemList);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID_Extension);} return false;
			case 6: type = 6; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 6; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(reject); type=1;}
		void select_id_SgNB_UE_X2AP_ID() { set(reject); type=2;}
		void select_id_UEContextLevelUserPlaneActivity() { set(ignore); type=3;}
		void select_id_ERABActivityNotifyItemList() { set(ignore); type=4;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(reject); type=5;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else if(equal(reject)) { type = 2; return true; }
			else if(equal(ignore)) { type = 3; return true; }
			else if(equal(ignore)) { type = 4; return true; }
			else if(equal(reject)) { type = 5; return true; }
			else { type = 6; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(reject);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(ignore);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(ignore);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(reject);} return false;
			case 6: type = 6; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		UE_X2AP_ID& select_id_MeNB_UE_X2AP_ID() { return set<UE_X2AP_ID>(1); }
		UE_X2AP_ID const* get_id_MeNB_UE_X2AP_ID() const { return get<UE_X2AP_ID>(1); }
		SgNB_UE_X2AP_ID& select_id_SgNB_UE_X2AP_ID() { return set<SgNB_UE_X2AP_ID>(2); }
		SgNB_UE_X2AP_ID const* get_id_SgNB_UE_X2AP_ID() const { return get<SgNB_UE_X2AP_ID>(2); }
		UserPlaneTrafficActivityReport& select_id_UEContextLevelUserPlaneActivity() { return set<UserPlaneTrafficActivityReport>(3); }
		UserPlaneTrafficActivityReport const* get_id_UEContextLevelUserPlaneActivity() const { return get<UserPlaneTrafficActivityReport>(3); }
		ERABActivityNotifyItemList& select_id_ERABActivityNotifyItemList() { return set<ERABActivityNotifyItemList>(4); }
		ERABActivityNotifyItemList const* get_id_ERABActivityNotifyItemList() const { return get<ERABActivityNotifyItemList>(4); }
		UE_X2AP_ID_Extension& select_id_MeNB_UE_X2AP_ID_Extension() { return set<UE_X2AP_ID_Extension>(5); }
		UE_X2AP_ID_Extension const* get_id_MeNB_UE_X2AP_ID_Extension() const { return get<UE_X2AP_ID_Extension>(5); }
		bool is_unknown() const { return type == 6; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<UE_X2AP_ID>(); break;
			case 2: var.destroy<SgNB_UE_X2AP_ID>(); break;
			case 3: var.destroy<UserPlaneTrafficActivityReport>(); break;
			case 4: var.destroy<ERABActivityNotifyItemList>(); break;
			case 5: var.destroy<UE_X2AP_ID_Extension>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<UE_X2AP_ID>(1);
			v.template operator()<SgNB_UE_X2AP_ID>(2);
			v.template operator()<UserPlaneTrafficActivityReport>(3);
			v.template operator()<ERABActivityNotifyItemList>(4);
			v.template operator()<UE_X2AP_ID_Extension>(5);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_MeNB_UE_X2AP_ID()); return true;
			case 2: v(select_id_SgNB_UE_X2AP_ID()); return true;
			case 3: v(select_id_UEContextLevelUserPlaneActivity()); return true;
			case 4: v(select_id_ERABActivityNotifyItemList()); return true;
			case 5: v(select_id_MeNB_UE_X2AP_ID_Extension()); return true;
			case 6: if(type != 6) {clear(); asn::base::set();} type = 6; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<UE_X2AP_ID>()); return true;
			case 2: v(var.as<SgNB_UE_X2AP_ID>()); return true;
			case 3: v(var.as<UserPlaneTrafficActivityReport>()); return true;
			case 4: v(var.as<ERABActivityNotifyItemList>()); return true;
			case 5: v(var.as<UE_X2AP_ID_Extension>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(ERABActivityNotifyItemList)];
			char dummy2[sizeof(SgNB_UE_X2AP_ID)];
			char dummy3[sizeof(UE_X2AP_ID)];
			char dummy4[sizeof(UE_X2AP_ID_Extension)];
			char dummy5[sizeof(UserPlaneTrafficActivityReport)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 6; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(mandatory); type=1;}
		void select_id_SgNB_UE_X2AP_ID() { set(mandatory); type=2;}
		void select_id_UEContextLevelUserPlaneActivity() { set(optional); type=3;}
		void select_id_ERABActivityNotifyItemList() { set(optional); type=4;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(optional); type=5;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(mandatory)) { type = 2; return true; }
			else if(equal(optional)) { type = 3; return true; }
			else if(equal(optional)) { type = 4; return true; }
			else if(equal(optional)) { type = 5; return true; }
			else { type = 6; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(optional);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(optional);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(optional);} return false;
			case 6: type = 6; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
SgNBActivityNotification ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container		{{SgNBActivityNotification-IEs}},
	...
}
*/

struct SgNBActivityNotification : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "SgNBActivityNotification";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<SgNBActivityNotification_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<SgNBActivityNotification_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
SgNBAdditionRequest-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-MeNB-UE-X2AP-ID							CRITICALITY reject	TYPE UE-X2AP-ID										PRESENCE mandatory}|
	{ ID id-NRUESecurityCapabilities					CRITICALITY reject	TYPE NRUESecurityCapabilities					PRESENCE mandatory}|
	{ ID id-SgNBSecurityKey							CRITICALITY reject	TYPE SgNBSecurityKey									PRESENCE mandatory}|
	{ ID id-SgNBUEAggregateMaximumBitRate			CRITICALITY reject	TYPE UEAggregateMaximumBitRate					PRESENCE mandatory}|
	{ ID id-SelectedPLMN								CRITICALITY ignore	TYPE PLMN-Identity									PRESENCE optional}|
	{ ID id-HandoverRestrictionList					CRITICALITY ignore	TYPE HandoverRestrictionList						PRESENCE optional}|
	{ ID id-E-RABs-ToBeAdded-SgNBAddReqList			CRITICALITY reject	TYPE E-RABs-ToBeAdded-SgNBAddReqList			PRESENCE mandatory}|
	{ ID id-MeNBtoSgNBContainer						CRITICALITY reject	TYPE MeNBtoSgNBContainer								PRESENCE mandatory}|
	{ ID id-SgNB-UE-X2AP-ID							CRITICALITY reject	TYPE SgNB-UE-X2AP-ID									PRESENCE optional}|
	{ ID id-ExpectedUEBehaviour						CRITICALITY ignore	TYPE ExpectedUEBehaviour								PRESENCE optional}|
	{ ID id-MeNB-UE-X2AP-ID-Extension				CRITICALITY reject	TYPE UE-X2AP-ID-Extension							PRESENCE optional}|
	{ ID id-RequestedSplitSRBs						CRITICALITY reject	TYPE SplitSRBs										PRESENCE optional}|
	{ ID id-MeNBResourceCoordinationInformation		CRITICALITY ignore	TYPE MeNBResourceCoordinationInformation		PRESENCE optional}|
	{ ID id-SGNB-Addition-Trigger-Ind				CRITICALITY reject	TYPE SGNB-Addition-Trigger-Ind					PRESENCE optional}|
	{ ID id-SubscriberProfileIDforRFP				CRITICALITY ignore	TYPE SubscriberProfileIDforRFP					PRESENCE optional}|
	{ ID id-MeNBCell-ID								CRITICALITY reject	TYPE ECGI											PRESENCE mandatory},
	...
}
*/

struct SgNBAdditionRequest_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 17; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(id_MeNB_UE_X2AP_ID); type=1;}
		void select_id_NRUESecurityCapabilities() { set(id_NRUESecurityCapabilities); type=2;}
		void select_id_SgNBSecurityKey() { set(id_SgNBSecurityKey); type=3;}
		void select_id_SgNBUEAggregateMaximumBitRate() { set(id_SgNBUEAggregateMaximumBitRate); type=4;}
		void select_id_SelectedPLMN() { set(id_SelectedPLMN); type=5;}
		void select_id_HandoverRestrictionList() { set(id_HandoverRestrictionList); type=6;}
		void select_id_E_RABs_ToBeAdded_SgNBAddReqList() { set(id_E_RABs_ToBeAdded_SgNBAddReqList); type=7;}
		void select_id_MeNBtoSgNBContainer() { set(id_MeNBtoSgNBContainer); type=8;}
		void select_id_SgNB_UE_X2AP_ID() { set(id_SgNB_UE_X2AP_ID); type=9;}
		void select_id_ExpectedUEBehaviour() { set(id_ExpectedUEBehaviour); type=10;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(id_MeNB_UE_X2AP_ID_Extension); type=11;}
		void select_id_RequestedSplitSRBs() { set(id_RequestedSplitSRBs); type=12;}
		void select_id_MeNBResourceCoordinationInformation() { set(id_MeNBResourceCoordinationInformation); type=13;}
		void select_id_SGNB_Addition_Trigger_Ind() { set(id_SGNB_Addition_Trigger_Ind); type=14;}
		void select_id_SubscriberProfileIDforRFP() { set(id_SubscriberProfileIDforRFP); type=15;}
		void select_id_MeNBCell_ID() { set(id_MeNBCell_ID); type=16;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_MeNB_UE_X2AP_ID)) { type = 1; return true; }
			else if(equal(id_NRUESecurityCapabilities)) { type = 2; return true; }
			else if(equal(id_SgNBSecurityKey)) { type = 3; return true; }
			else if(equal(id_SgNBUEAggregateMaximumBitRate)) { type = 4; return true; }
			else if(equal(id_SelectedPLMN)) { type = 5; return true; }
			else if(equal(id_HandoverRestrictionList)) { type = 6; return true; }
			else if(equal(id_E_RABs_ToBeAdded_SgNBAddReqList)) { type = 7; return true; }
			else if(equal(id_MeNBtoSgNBContainer)) { type = 8; return true; }
			else if(equal(id_SgNB_UE_X2AP_ID)) { type = 9; return true; }
			else if(equal(id_ExpectedUEBehaviour)) { type = 10; return true; }
			else if(equal(id_MeNB_UE_X2AP_ID_Extension)) { type = 11; return true; }
			else if(equal(id_RequestedSplitSRBs)) { type = 12; return true; }
			else if(equal(id_MeNBResourceCoordinationInformation)) { type = 13; return true; }
			else if(equal(id_SGNB_Addition_Trigger_Ind)) { type = 14; return true; }
			else if(equal(id_SubscriberProfileIDforRFP)) { type = 15; return true; }
			else if(equal(id_MeNBCell_ID)) { type = 16; return true; }
			else { type = 17; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_NRUESecurityCapabilities);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_SgNBSecurityKey);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(id_SgNBUEAggregateMaximumBitRate);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(id_SelectedPLMN);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(id_HandoverRestrictionList);} return false;
			case 7: type = 7; if(v(ref_nested())) { return equal(id_E_RABs_ToBeAdded_SgNBAddReqList);} return false;
			case 8: type = 8; if(v(ref_nested())) { return equal(id_MeNBtoSgNBContainer);} return false;
			case 9: type = 9; if(v(ref_nested())) { return equal(id_SgNB_UE_X2AP_ID);} return false;
			case 10: type = 10; if(v(ref_nested())) { return equal(id_ExpectedUEBehaviour);} return false;
			case 11: type = 11; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID_Extension);} return false;
			case 12: type = 12; if(v(ref_nested())) { return equal(id_RequestedSplitSRBs);} return false;
			case 13: type = 13; if(v(ref_nested())) { return equal(id_MeNBResourceCoordinationInformation);} return false;
			case 14: type = 14; if(v(ref_nested())) { return equal(id_SGNB_Addition_Trigger_Ind);} return false;
			case 15: type = 15; if(v(ref_nested())) { return equal(id_SubscriberProfileIDforRFP);} return false;
			case 16: type = 16; if(v(ref_nested())) { return equal(id_MeNBCell_ID);} return false;
			case 17: type = 17; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 17; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(reject); type=1;}
		void select_id_NRUESecurityCapabilities() { set(reject); type=2;}
		void select_id_SgNBSecurityKey() { set(reject); type=3;}
		void select_id_SgNBUEAggregateMaximumBitRate() { set(reject); type=4;}
		void select_id_SelectedPLMN() { set(ignore); type=5;}
		void select_id_HandoverRestrictionList() { set(ignore); type=6;}
		void select_id_E_RABs_ToBeAdded_SgNBAddReqList() { set(reject); type=7;}
		void select_id_MeNBtoSgNBContainer() { set(reject); type=8;}
		void select_id_SgNB_UE_X2AP_ID() { set(reject); type=9;}
		void select_id_ExpectedUEBehaviour() { set(ignore); type=10;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(reject); type=11;}
		void select_id_RequestedSplitSRBs() { set(reject); type=12;}
		void select_id_MeNBResourceCoordinationInformation() { set(ignore); type=13;}
		void select_id_SGNB_Addition_Trigger_Ind() { set(reject); type=14;}
		void select_id_SubscriberProfileIDforRFP() { set(ignore); type=15;}
		void select_id_MeNBCell_ID() { set(reject); type=16;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else if(equal(reject)) { type = 2; return true; }
			else if(equal(reject)) { type = 3; return true; }
			else if(equal(reject)) { type = 4; return true; }
			else if(equal(ignore)) { type = 5; return true; }
			else if(equal(ignore)) { type = 6; return true; }
			else if(equal(reject)) { type = 7; return true; }
			else if(equal(reject)) { type = 8; return true; }
			else if(equal(reject)) { type = 9; return true; }
			else if(equal(ignore)) { type = 10; return true; }
			else if(equal(reject)) { type = 11; return true; }
			else if(equal(reject)) { type = 12; return true; }
			else if(equal(ignore)) { type = 13; return true; }
			else if(equal(reject)) { type = 14; return true; }
			else if(equal(ignore)) { type = 15; return true; }
			else if(equal(reject)) { type = 16; return true; }
			else { type = 17; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(reject);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(reject);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(reject);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(ignore);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(ignore);} return false;
			case 7: type = 7; if(v(ref_nested())) { return equal(reject);} return false;
			case 8: type = 8; if(v(ref_nested())) { return equal(reject);} return false;
			case 9: type = 9; if(v(ref_nested())) { return equal(reject);} return false;
			case 10: type = 10; if(v(ref_nested())) { return equal(ignore);} return false;
			case 11: type = 11; if(v(ref_nested())) { return equal(reject);} return false;
			case 12: type = 12; if(v(ref_nested())) { return equal(reject);} return false;
			case 13: type = 13; if(v(ref_nested())) { return equal(ignore);} return false;
			case 14: type = 14; if(v(ref_nested())) { return equal(reject);} return false;
			case 15: type = 15; if(v(ref_nested())) { return equal(ignore);} return false;
			case 16: type = 16; if(v(ref_nested())) { return equal(reject);} return false;
			case 17: type = 17; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		UE_X2AP_ID& select_id_MeNB_UE_X2AP_ID() { return set<UE_X2AP_ID>(1); }
		UE_X2AP_ID const* get_id_MeNB_UE_X2AP_ID() const { return get<UE_X2AP_ID>(1); }
		NRUESecurityCapabilities& select_id_NRUESecurityCapabilities() { return set<NRUESecurityCapabilities>(2); }
		NRUESecurityCapabilities const* get_id_NRUESecurityCapabilities() const { return get<NRUESecurityCapabilities>(2); }
		SgNBSecurityKey& select_id_SgNBSecurityKey() { return set<SgNBSecurityKey>(3); }
		SgNBSecurityKey const* get_id_SgNBSecurityKey() const { return get<SgNBSecurityKey>(3); }
		UEAggregateMaximumBitRate& select_id_SgNBUEAggregateMaximumBitRate() { return set<UEAggregateMaximumBitRate>(4); }
		UEAggregateMaximumBitRate const* get_id_SgNBUEAggregateMaximumBitRate() const { return get<UEAggregateMaximumBitRate>(4); }
		PLMN_Identity& select_id_SelectedPLMN() { return set<PLMN_Identity>(5); }
		PLMN_Identity const* get_id_SelectedPLMN() const { return get<PLMN_Identity>(5); }
		HandoverRestrictionList& select_id_HandoverRestrictionList() { return set<HandoverRestrictionList>(6); }
		HandoverRestrictionList const* get_id_HandoverRestrictionList() const { return get<HandoverRestrictionList>(6); }
		E_RABs_ToBeAdded_SgNBAddReqList& select_id_E_RABs_ToBeAdded_SgNBAddReqList() { return set<E_RABs_ToBeAdded_SgNBAddReqList>(7); }
		E_RABs_ToBeAdded_SgNBAddReqList const* get_id_E_RABs_ToBeAdded_SgNBAddReqList() const { return get<E_RABs_ToBeAdded_SgNBAddReqList>(7); }
		MeNBtoSgNBContainer& select_id_MeNBtoSgNBContainer() { return set<MeNBtoSgNBContainer>(8); }
		MeNBtoSgNBContainer const* get_id_MeNBtoSgNBContainer() const { return get<MeNBtoSgNBContainer>(8); }
		SgNB_UE_X2AP_ID& select_id_SgNB_UE_X2AP_ID() { return set<SgNB_UE_X2AP_ID>(9); }
		SgNB_UE_X2AP_ID const* get_id_SgNB_UE_X2AP_ID() const { return get<SgNB_UE_X2AP_ID>(9); }
		ExpectedUEBehaviour& select_id_ExpectedUEBehaviour() { return set<ExpectedUEBehaviour>(10); }
		ExpectedUEBehaviour const* get_id_ExpectedUEBehaviour() const { return get<ExpectedUEBehaviour>(10); }
		UE_X2AP_ID_Extension& select_id_MeNB_UE_X2AP_ID_Extension() { return set<UE_X2AP_ID_Extension>(11); }
		UE_X2AP_ID_Extension const* get_id_MeNB_UE_X2AP_ID_Extension() const { return get<UE_X2AP_ID_Extension>(11); }
		SplitSRBs& select_id_RequestedSplitSRBs() { return set<SplitSRBs>(12); }
		SplitSRBs const* get_id_RequestedSplitSRBs() const { return get<SplitSRBs>(12); }
		MeNBResourceCoordinationInformation& select_id_MeNBResourceCoordinationInformation() { return set<MeNBResourceCoordinationInformation>(13); }
		MeNBResourceCoordinationInformation const* get_id_MeNBResourceCoordinationInformation() const { return get<MeNBResourceCoordinationInformation>(13); }
		SGNB_Addition_Trigger_Ind& select_id_SGNB_Addition_Trigger_Ind() { return set<SGNB_Addition_Trigger_Ind>(14); }
		SGNB_Addition_Trigger_Ind const* get_id_SGNB_Addition_Trigger_Ind() const { return get<SGNB_Addition_Trigger_Ind>(14); }
		SubscriberProfileIDforRFP& select_id_SubscriberProfileIDforRFP() { return set<SubscriberProfileIDforRFP>(15); }
		SubscriberProfileIDforRFP const* get_id_SubscriberProfileIDforRFP() const { return get<SubscriberProfileIDforRFP>(15); }
		ECGI& select_id_MeNBCell_ID() { return set<ECGI>(16); }
		ECGI const* get_id_MeNBCell_ID() const { return get<ECGI>(16); }
		bool is_unknown() const { return type == 17; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<UE_X2AP_ID>(); break;
			case 2: var.destroy<NRUESecurityCapabilities>(); break;
			case 3: var.destroy<SgNBSecurityKey>(); break;
			case 4: var.destroy<UEAggregateMaximumBitRate>(); break;
			case 5: var.destroy<PLMN_Identity>(); break;
			case 6: var.destroy<HandoverRestrictionList>(); break;
			case 7: var.destroy<E_RABs_ToBeAdded_SgNBAddReqList>(); break;
			case 8: var.destroy<MeNBtoSgNBContainer>(); break;
			case 9: var.destroy<SgNB_UE_X2AP_ID>(); break;
			case 10: var.destroy<ExpectedUEBehaviour>(); break;
			case 11: var.destroy<UE_X2AP_ID_Extension>(); break;
			case 12: var.destroy<SplitSRBs>(); break;
			case 13: var.destroy<MeNBResourceCoordinationInformation>(); break;
			case 14: var.destroy<SGNB_Addition_Trigger_Ind>(); break;
			case 15: var.destroy<SubscriberProfileIDforRFP>(); break;
			case 16: var.destroy<ECGI>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<UE_X2AP_ID>(1);
			v.template operator()<NRUESecurityCapabilities>(2);
			v.template operator()<SgNBSecurityKey>(3);
			v.template operator()<UEAggregateMaximumBitRate>(4);
			v.template operator()<PLMN_Identity>(5);
			v.template operator()<HandoverRestrictionList>(6);
			v.template operator()<E_RABs_ToBeAdded_SgNBAddReqList>(7);
			v.template operator()<MeNBtoSgNBContainer>(8);
			v.template operator()<SgNB_UE_X2AP_ID>(9);
			v.template operator()<ExpectedUEBehaviour>(10);
			v.template operator()<UE_X2AP_ID_Extension>(11);
			v.template operator()<SplitSRBs>(12);
			v.template operator()<MeNBResourceCoordinationInformation>(13);
			v.template operator()<SGNB_Addition_Trigger_Ind>(14);
			v.template operator()<SubscriberProfileIDforRFP>(15);
			v.template operator()<ECGI>(16);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_MeNB_UE_X2AP_ID()); return true;
			case 2: v(select_id_NRUESecurityCapabilities()); return true;
			case 3: v(select_id_SgNBSecurityKey()); return true;
			case 4: v(select_id_SgNBUEAggregateMaximumBitRate()); return true;
			case 5: v(select_id_SelectedPLMN()); return true;
			case 6: v(select_id_HandoverRestrictionList()); return true;
			case 7: v(select_id_E_RABs_ToBeAdded_SgNBAddReqList()); return true;
			case 8: v(select_id_MeNBtoSgNBContainer()); return true;
			case 9: v(select_id_SgNB_UE_X2AP_ID()); return true;
			case 10: v(select_id_ExpectedUEBehaviour()); return true;
			case 11: v(select_id_MeNB_UE_X2AP_ID_Extension()); return true;
			case 12: v(select_id_RequestedSplitSRBs()); return true;
			case 13: v(select_id_MeNBResourceCoordinationInformation()); return true;
			case 14: v(select_id_SGNB_Addition_Trigger_Ind()); return true;
			case 15: v(select_id_SubscriberProfileIDforRFP()); return true;
			case 16: v(select_id_MeNBCell_ID()); return true;
			case 17: if(type != 17) {clear(); asn::base::set();} type = 17; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<UE_X2AP_ID>()); return true;
			case 2: v(var.as<NRUESecurityCapabilities>()); return true;
			case 3: v(var.as<SgNBSecurityKey>()); return true;
			case 4: v(var.as<UEAggregateMaximumBitRate>()); return true;
			case 5: v(var.as<PLMN_Identity>()); return true;
			case 6: v(var.as<HandoverRestrictionList>()); return true;
			case 7: v(var.as<E_RABs_ToBeAdded_SgNBAddReqList>()); return true;
			case 8: v(var.as<MeNBtoSgNBContainer>()); return true;
			case 9: v(var.as<SgNB_UE_X2AP_ID>()); return true;
			case 10: v(var.as<ExpectedUEBehaviour>()); return true;
			case 11: v(var.as<UE_X2AP_ID_Extension>()); return true;
			case 12: v(var.as<SplitSRBs>()); return true;
			case 13: v(var.as<MeNBResourceCoordinationInformation>()); return true;
			case 14: v(var.as<SGNB_Addition_Trigger_Ind>()); return true;
			case 15: v(var.as<SubscriberProfileIDforRFP>()); return true;
			case 16: v(var.as<ECGI>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(ECGI)];
			char dummy2[sizeof(E_RABs_ToBeAdded_SgNBAddReqList)];
			char dummy3[sizeof(ExpectedUEBehaviour)];
			char dummy4[sizeof(HandoverRestrictionList)];
			char dummy5[sizeof(MeNBResourceCoordinationInformation)];
			char dummy6[sizeof(MeNBtoSgNBContainer)];
			char dummy7[sizeof(NRUESecurityCapabilities)];
			char dummy8[sizeof(PLMN_Identity)];
			char dummy9[sizeof(SGNB_Addition_Trigger_Ind)];
			char dummy10[sizeof(SgNBSecurityKey)];
			char dummy11[sizeof(SgNB_UE_X2AP_ID)];
			char dummy12[sizeof(SplitSRBs)];
			char dummy13[sizeof(SubscriberProfileIDforRFP)];
			char dummy14[sizeof(UEAggregateMaximumBitRate)];
			char dummy15[sizeof(UE_X2AP_ID)];
			char dummy16[sizeof(UE_X2AP_ID_Extension)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 17; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(mandatory); type=1;}
		void select_id_NRUESecurityCapabilities() { set(mandatory); type=2;}
		void select_id_SgNBSecurityKey() { set(mandatory); type=3;}
		void select_id_SgNBUEAggregateMaximumBitRate() { set(mandatory); type=4;}
		void select_id_SelectedPLMN() { set(optional); type=5;}
		void select_id_HandoverRestrictionList() { set(optional); type=6;}
		void select_id_E_RABs_ToBeAdded_SgNBAddReqList() { set(mandatory); type=7;}
		void select_id_MeNBtoSgNBContainer() { set(mandatory); type=8;}
		void select_id_SgNB_UE_X2AP_ID() { set(optional); type=9;}
		void select_id_ExpectedUEBehaviour() { set(optional); type=10;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(optional); type=11;}
		void select_id_RequestedSplitSRBs() { set(optional); type=12;}
		void select_id_MeNBResourceCoordinationInformation() { set(optional); type=13;}
		void select_id_SGNB_Addition_Trigger_Ind() { set(optional); type=14;}
		void select_id_SubscriberProfileIDforRFP() { set(optional); type=15;}
		void select_id_MeNBCell_ID() { set(mandatory); type=16;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(mandatory)) { type = 2; return true; }
			else if(equal(mandatory)) { type = 3; return true; }
			else if(equal(mandatory)) { type = 4; return true; }
			else if(equal(optional)) { type = 5; return true; }
			else if(equal(optional)) { type = 6; return true; }
			else if(equal(mandatory)) { type = 7; return true; }
			else if(equal(mandatory)) { type = 8; return true; }
			else if(equal(optional)) { type = 9; return true; }
			else if(equal(optional)) { type = 10; return true; }
			else if(equal(optional)) { type = 11; return true; }
			else if(equal(optional)) { type = 12; return true; }
			else if(equal(optional)) { type = 13; return true; }
			else if(equal(optional)) { type = 14; return true; }
			else if(equal(optional)) { type = 15; return true; }
			else if(equal(mandatory)) { type = 16; return true; }
			else { type = 17; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(optional);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(optional);} return false;
			case 7: type = 7; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 8: type = 8; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 9: type = 9; if(v(ref_nested())) { return equal(optional);} return false;
			case 10: type = 10; if(v(ref_nested())) { return equal(optional);} return false;
			case 11: type = 11; if(v(ref_nested())) { return equal(optional);} return false;
			case 12: type = 12; if(v(ref_nested())) { return equal(optional);} return false;
			case 13: type = 13; if(v(ref_nested())) { return equal(optional);} return false;
			case 14: type = 14; if(v(ref_nested())) { return equal(optional);} return false;
			case 15: type = 15; if(v(ref_nested())) { return equal(optional);} return false;
			case 16: type = 16; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 17: type = 17; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
SgNBAdditionRequest ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container {{SgNBAdditionRequest-IEs}},
	...
}
*/

struct SgNBAdditionRequest : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "SgNBAdditionRequest";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<SgNBAdditionRequest_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<SgNBAdditionRequest_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
SgNBAdditionRequestAcknowledge-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-MeNB-UE-X2AP-ID								CRITICALITY reject	TYPE UE-X2AP-ID													PRESENCE mandatory}|
	{ ID id-SgNB-UE-X2AP-ID								CRITICALITY reject	TYPE SgNB-UE-X2AP-ID												PRESENCE mandatory}|
	{ ID id-E-RABs-Admitted-ToBeAdded-SgNBAddReqAckList	CRITICALITY ignore	TYPE E-RABs-Admitted-ToBeAdded-SgNBAddReqAckList			PRESENCE mandatory}|
	{ ID id-E-RABs-NotAdmitted-List						CRITICALITY ignore	TYPE E-RAB-List													PRESENCE optional}|
	{ ID id-SgNBtoMeNBContainer							CRITICALITY reject	TYPE SgNBtoMeNBContainer										PRESENCE mandatory}|
	{ ID id-CriticalityDiagnostics						CRITICALITY ignore	TYPE CriticalityDiagnostics									PRESENCE optional}|
	{ ID id-MeNB-UE-X2AP-ID-Extension					CRITICALITY reject	TYPE UE-X2AP-ID-Extension									PRESENCE optional}|
	{ ID id-AdmittedSplitSRBs							CRITICALITY reject	TYPE SplitSRBs													PRESENCE optional}|
	{ ID id-SgNBResourceCoordinationInformation			CRITICALITY ignore	TYPE SgNBResourceCoordinationInformation				PRESENCE optional}|
	{ ID id-RRCConfigIndication							CRITICALITY reject	TYPE RRC-Config-Ind												PRESENCE optional},
	...
}
*/

struct SgNBAdditionRequestAcknowledge_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 11; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(id_MeNB_UE_X2AP_ID); type=1;}
		void select_id_SgNB_UE_X2AP_ID() { set(id_SgNB_UE_X2AP_ID); type=2;}
		void select_id_E_RABs_Admitted_ToBeAdded_SgNBAddReqAckList() { set(id_E_RABs_Admitted_ToBeAdded_SgNBAddReqAckList); type=3;}
		void select_id_E_RABs_NotAdmitted_List() { set(id_E_RABs_NotAdmitted_List); type=4;}
		void select_id_SgNBtoMeNBContainer() { set(id_SgNBtoMeNBContainer); type=5;}
		void select_id_CriticalityDiagnostics() { set(id_CriticalityDiagnostics); type=6;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(id_MeNB_UE_X2AP_ID_Extension); type=7;}
		void select_id_AdmittedSplitSRBs() { set(id_AdmittedSplitSRBs); type=8;}
		void select_id_SgNBResourceCoordinationInformation() { set(id_SgNBResourceCoordinationInformation); type=9;}
		void select_id_RRCConfigIndication() { set(id_RRCConfigIndication); type=10;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_MeNB_UE_X2AP_ID)) { type = 1; return true; }
			else if(equal(id_SgNB_UE_X2AP_ID)) { type = 2; return true; }
			else if(equal(id_E_RABs_Admitted_ToBeAdded_SgNBAddReqAckList)) { type = 3; return true; }
			else if(equal(id_E_RABs_NotAdmitted_List)) { type = 4; return true; }
			else if(equal(id_SgNBtoMeNBContainer)) { type = 5; return true; }
			else if(equal(id_CriticalityDiagnostics)) { type = 6; return true; }
			else if(equal(id_MeNB_UE_X2AP_ID_Extension)) { type = 7; return true; }
			else if(equal(id_AdmittedSplitSRBs)) { type = 8; return true; }
			else if(equal(id_SgNBResourceCoordinationInformation)) { type = 9; return true; }
			else if(equal(id_RRCConfigIndication)) { type = 10; return true; }
			else { type = 11; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_SgNB_UE_X2AP_ID);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_E_RABs_Admitted_ToBeAdded_SgNBAddReqAckList);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(id_E_RABs_NotAdmitted_List);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(id_SgNBtoMeNBContainer);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(id_CriticalityDiagnostics);} return false;
			case 7: type = 7; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID_Extension);} return false;
			case 8: type = 8; if(v(ref_nested())) { return equal(id_AdmittedSplitSRBs);} return false;
			case 9: type = 9; if(v(ref_nested())) { return equal(id_SgNBResourceCoordinationInformation);} return false;
			case 10: type = 10; if(v(ref_nested())) { return equal(id_RRCConfigIndication);} return false;
			case 11: type = 11; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 11; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(reject); type=1;}
		void select_id_SgNB_UE_X2AP_ID() { set(reject); type=2;}
		void select_id_E_RABs_Admitted_ToBeAdded_SgNBAddReqAckList() { set(ignore); type=3;}
		void select_id_E_RABs_NotAdmitted_List() { set(ignore); type=4;}
		void select_id_SgNBtoMeNBContainer() { set(reject); type=5;}
		void select_id_CriticalityDiagnostics() { set(ignore); type=6;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(reject); type=7;}
		void select_id_AdmittedSplitSRBs() { set(reject); type=8;}
		void select_id_SgNBResourceCoordinationInformation() { set(ignore); type=9;}
		void select_id_RRCConfigIndication() { set(reject); type=10;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else if(equal(reject)) { type = 2; return true; }
			else if(equal(ignore)) { type = 3; return true; }
			else if(equal(ignore)) { type = 4; return true; }
			else if(equal(reject)) { type = 5; return true; }
			else if(equal(ignore)) { type = 6; return true; }
			else if(equal(reject)) { type = 7; return true; }
			else if(equal(reject)) { type = 8; return true; }
			else if(equal(ignore)) { type = 9; return true; }
			else if(equal(reject)) { type = 10; return true; }
			else { type = 11; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(reject);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(ignore);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(ignore);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(reject);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(ignore);} return false;
			case 7: type = 7; if(v(ref_nested())) { return equal(reject);} return false;
			case 8: type = 8; if(v(ref_nested())) { return equal(reject);} return false;
			case 9: type = 9; if(v(ref_nested())) { return equal(ignore);} return false;
			case 10: type = 10; if(v(ref_nested())) { return equal(reject);} return false;
			case 11: type = 11; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		UE_X2AP_ID& select_id_MeNB_UE_X2AP_ID() { return set<UE_X2AP_ID>(1); }
		UE_X2AP_ID const* get_id_MeNB_UE_X2AP_ID() const { return get<UE_X2AP_ID>(1); }
		SgNB_UE_X2AP_ID& select_id_SgNB_UE_X2AP_ID() { return set<SgNB_UE_X2AP_ID>(2); }
		SgNB_UE_X2AP_ID const* get_id_SgNB_UE_X2AP_ID() const { return get<SgNB_UE_X2AP_ID>(2); }
		E_RABs_Admitted_ToBeAdded_SgNBAddReqAckList& select_id_E_RABs_Admitted_ToBeAdded_SgNBAddReqAckList() { return set<E_RABs_Admitted_ToBeAdded_SgNBAddReqAckList>(3); }
		E_RABs_Admitted_ToBeAdded_SgNBAddReqAckList const* get_id_E_RABs_Admitted_ToBeAdded_SgNBAddReqAckList() const { return get<E_RABs_Admitted_ToBeAdded_SgNBAddReqAckList>(3); }
		E_RAB_List& select_id_E_RABs_NotAdmitted_List() { return set<E_RAB_List>(4); }
		E_RAB_List const* get_id_E_RABs_NotAdmitted_List() const { return get<E_RAB_List>(4); }
		SgNBtoMeNBContainer& select_id_SgNBtoMeNBContainer() { return set<SgNBtoMeNBContainer>(5); }
		SgNBtoMeNBContainer const* get_id_SgNBtoMeNBContainer() const { return get<SgNBtoMeNBContainer>(5); }
		CriticalityDiagnostics& select_id_CriticalityDiagnostics() { return set<CriticalityDiagnostics>(6); }
		CriticalityDiagnostics const* get_id_CriticalityDiagnostics() const { return get<CriticalityDiagnostics>(6); }
		UE_X2AP_ID_Extension& select_id_MeNB_UE_X2AP_ID_Extension() { return set<UE_X2AP_ID_Extension>(7); }
		UE_X2AP_ID_Extension const* get_id_MeNB_UE_X2AP_ID_Extension() const { return get<UE_X2AP_ID_Extension>(7); }
		SplitSRBs& select_id_AdmittedSplitSRBs() { return set<SplitSRBs>(8); }
		SplitSRBs const* get_id_AdmittedSplitSRBs() const { return get<SplitSRBs>(8); }
		SgNBResourceCoordinationInformation& select_id_SgNBResourceCoordinationInformation() { return set<SgNBResourceCoordinationInformation>(9); }
		SgNBResourceCoordinationInformation const* get_id_SgNBResourceCoordinationInformation() const { return get<SgNBResourceCoordinationInformation>(9); }
		RRC_Config_Ind& select_id_RRCConfigIndication() { return set<RRC_Config_Ind>(10); }
		RRC_Config_Ind const* get_id_RRCConfigIndication() const { return get<RRC_Config_Ind>(10); }
		bool is_unknown() const { return type == 11; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<UE_X2AP_ID>(); break;
			case 2: var.destroy<SgNB_UE_X2AP_ID>(); break;
			case 3: var.destroy<E_RABs_Admitted_ToBeAdded_SgNBAddReqAckList>(); break;
			case 4: var.destroy<E_RAB_List>(); break;
			case 5: var.destroy<SgNBtoMeNBContainer>(); break;
			case 6: var.destroy<CriticalityDiagnostics>(); break;
			case 7: var.destroy<UE_X2AP_ID_Extension>(); break;
			case 8: var.destroy<SplitSRBs>(); break;
			case 9: var.destroy<SgNBResourceCoordinationInformation>(); break;
			case 10: var.destroy<RRC_Config_Ind>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<UE_X2AP_ID>(1);
			v.template operator()<SgNB_UE_X2AP_ID>(2);
			v.template operator()<E_RABs_Admitted_ToBeAdded_SgNBAddReqAckList>(3);
			v.template operator()<E_RAB_List>(4);
			v.template operator()<SgNBtoMeNBContainer>(5);
			v.template operator()<CriticalityDiagnostics>(6);
			v.template operator()<UE_X2AP_ID_Extension>(7);
			v.template operator()<SplitSRBs>(8);
			v.template operator()<SgNBResourceCoordinationInformation>(9);
			v.template operator()<RRC_Config_Ind>(10);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_MeNB_UE_X2AP_ID()); return true;
			case 2: v(select_id_SgNB_UE_X2AP_ID()); return true;
			case 3: v(select_id_E_RABs_Admitted_ToBeAdded_SgNBAddReqAckList()); return true;
			case 4: v(select_id_E_RABs_NotAdmitted_List()); return true;
			case 5: v(select_id_SgNBtoMeNBContainer()); return true;
			case 6: v(select_id_CriticalityDiagnostics()); return true;
			case 7: v(select_id_MeNB_UE_X2AP_ID_Extension()); return true;
			case 8: v(select_id_AdmittedSplitSRBs()); return true;
			case 9: v(select_id_SgNBResourceCoordinationInformation()); return true;
			case 10: v(select_id_RRCConfigIndication()); return true;
			case 11: if(type != 11) {clear(); asn::base::set();} type = 11; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<UE_X2AP_ID>()); return true;
			case 2: v(var.as<SgNB_UE_X2AP_ID>()); return true;
			case 3: v(var.as<E_RABs_Admitted_ToBeAdded_SgNBAddReqAckList>()); return true;
			case 4: v(var.as<E_RAB_List>()); return true;
			case 5: v(var.as<SgNBtoMeNBContainer>()); return true;
			case 6: v(var.as<CriticalityDiagnostics>()); return true;
			case 7: v(var.as<UE_X2AP_ID_Extension>()); return true;
			case 8: v(var.as<SplitSRBs>()); return true;
			case 9: v(var.as<SgNBResourceCoordinationInformation>()); return true;
			case 10: v(var.as<RRC_Config_Ind>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(CriticalityDiagnostics)];
			char dummy2[sizeof(E_RAB_List)];
			char dummy3[sizeof(E_RABs_Admitted_ToBeAdded_SgNBAddReqAckList)];
			char dummy4[sizeof(RRC_Config_Ind)];
			char dummy5[sizeof(SgNBResourceCoordinationInformation)];
			char dummy6[sizeof(SgNB_UE_X2AP_ID)];
			char dummy7[sizeof(SgNBtoMeNBContainer)];
			char dummy8[sizeof(SplitSRBs)];
			char dummy9[sizeof(UE_X2AP_ID)];
			char dummy10[sizeof(UE_X2AP_ID_Extension)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 11; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(mandatory); type=1;}
		void select_id_SgNB_UE_X2AP_ID() { set(mandatory); type=2;}
		void select_id_E_RABs_Admitted_ToBeAdded_SgNBAddReqAckList() { set(mandatory); type=3;}
		void select_id_E_RABs_NotAdmitted_List() { set(optional); type=4;}
		void select_id_SgNBtoMeNBContainer() { set(mandatory); type=5;}
		void select_id_CriticalityDiagnostics() { set(optional); type=6;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(optional); type=7;}
		void select_id_AdmittedSplitSRBs() { set(optional); type=8;}
		void select_id_SgNBResourceCoordinationInformation() { set(optional); type=9;}
		void select_id_RRCConfigIndication() { set(optional); type=10;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(mandatory)) { type = 2; return true; }
			else if(equal(mandatory)) { type = 3; return true; }
			else if(equal(optional)) { type = 4; return true; }
			else if(equal(mandatory)) { type = 5; return true; }
			else if(equal(optional)) { type = 6; return true; }
			else if(equal(optional)) { type = 7; return true; }
			else if(equal(optional)) { type = 8; return true; }
			else if(equal(optional)) { type = 9; return true; }
			else if(equal(optional)) { type = 10; return true; }
			else { type = 11; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(optional);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(optional);} return false;
			case 7: type = 7; if(v(ref_nested())) { return equal(optional);} return false;
			case 8: type = 8; if(v(ref_nested())) { return equal(optional);} return false;
			case 9: type = 9; if(v(ref_nested())) { return equal(optional);} return false;
			case 10: type = 10; if(v(ref_nested())) { return equal(optional);} return false;
			case 11: type = 11; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
SgNBAdditionRequestAcknowledge ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{SgNBAdditionRequestAcknowledge-IEs}},
	...
}
*/

struct SgNBAdditionRequestAcknowledge : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "SgNBAdditionRequestAcknowledge";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<SgNBAdditionRequestAcknowledge_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<SgNBAdditionRequestAcknowledge_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
SgNBAdditionRequestReject-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-MeNB-UE-X2AP-ID					CRITICALITY reject	TYPE UE-X2AP-ID					PRESENCE mandatory}|
	{ ID id-SgNB-UE-X2AP-ID					CRITICALITY reject	TYPE SgNB-UE-X2AP-ID			PRESENCE optional}|
	{ ID id-Cause							CRITICALITY ignore	TYPE Cause						PRESENCE mandatory}|
	{ ID id-CriticalityDiagnostics			CRITICALITY ignore	TYPE CriticalityDiagnostics		PRESENCE optional}|
	{ ID id-MeNB-UE-X2AP-ID-Extension		CRITICALITY reject	TYPE UE-X2AP-ID-Extension		PRESENCE optional},
	...
}
*/

struct SgNBAdditionRequestReject_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 6; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(id_MeNB_UE_X2AP_ID); type=1;}
		void select_id_SgNB_UE_X2AP_ID() { set(id_SgNB_UE_X2AP_ID); type=2;}
		void select_id_Cause() { set(id_Cause); type=3;}
		void select_id_CriticalityDiagnostics() { set(id_CriticalityDiagnostics); type=4;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(id_MeNB_UE_X2AP_ID_Extension); type=5;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_MeNB_UE_X2AP_ID)) { type = 1; return true; }
			else if(equal(id_SgNB_UE_X2AP_ID)) { type = 2; return true; }
			else if(equal(id_Cause)) { type = 3; return true; }
			else if(equal(id_CriticalityDiagnostics)) { type = 4; return true; }
			else if(equal(id_MeNB_UE_X2AP_ID_Extension)) { type = 5; return true; }
			else { type = 6; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_SgNB_UE_X2AP_ID);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_Cause);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(id_CriticalityDiagnostics);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID_Extension);} return false;
			case 6: type = 6; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 6; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(reject); type=1;}
		void select_id_SgNB_UE_X2AP_ID() { set(reject); type=2;}
		void select_id_Cause() { set(ignore); type=3;}
		void select_id_CriticalityDiagnostics() { set(ignore); type=4;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(reject); type=5;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else if(equal(reject)) { type = 2; return true; }
			else if(equal(ignore)) { type = 3; return true; }
			else if(equal(ignore)) { type = 4; return true; }
			else if(equal(reject)) { type = 5; return true; }
			else { type = 6; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(reject);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(ignore);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(ignore);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(reject);} return false;
			case 6: type = 6; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		UE_X2AP_ID& select_id_MeNB_UE_X2AP_ID() { return set<UE_X2AP_ID>(1); }
		UE_X2AP_ID const* get_id_MeNB_UE_X2AP_ID() const { return get<UE_X2AP_ID>(1); }
		SgNB_UE_X2AP_ID& select_id_SgNB_UE_X2AP_ID() { return set<SgNB_UE_X2AP_ID>(2); }
		SgNB_UE_X2AP_ID const* get_id_SgNB_UE_X2AP_ID() const { return get<SgNB_UE_X2AP_ID>(2); }
		Cause& select_id_Cause() { return set<Cause>(3); }
		Cause const* get_id_Cause() const { return get<Cause>(3); }
		CriticalityDiagnostics& select_id_CriticalityDiagnostics() { return set<CriticalityDiagnostics>(4); }
		CriticalityDiagnostics const* get_id_CriticalityDiagnostics() const { return get<CriticalityDiagnostics>(4); }
		UE_X2AP_ID_Extension& select_id_MeNB_UE_X2AP_ID_Extension() { return set<UE_X2AP_ID_Extension>(5); }
		UE_X2AP_ID_Extension const* get_id_MeNB_UE_X2AP_ID_Extension() const { return get<UE_X2AP_ID_Extension>(5); }
		bool is_unknown() const { return type == 6; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<UE_X2AP_ID>(); break;
			case 2: var.destroy<SgNB_UE_X2AP_ID>(); break;
			case 3: var.destroy<Cause>(); break;
			case 4: var.destroy<CriticalityDiagnostics>(); break;
			case 5: var.destroy<UE_X2AP_ID_Extension>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<UE_X2AP_ID>(1);
			v.template operator()<SgNB_UE_X2AP_ID>(2);
			v.template operator()<Cause>(3);
			v.template operator()<CriticalityDiagnostics>(4);
			v.template operator()<UE_X2AP_ID_Extension>(5);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_MeNB_UE_X2AP_ID()); return true;
			case 2: v(select_id_SgNB_UE_X2AP_ID()); return true;
			case 3: v(select_id_Cause()); return true;
			case 4: v(select_id_CriticalityDiagnostics()); return true;
			case 5: v(select_id_MeNB_UE_X2AP_ID_Extension()); return true;
			case 6: if(type != 6) {clear(); asn::base::set();} type = 6; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<UE_X2AP_ID>()); return true;
			case 2: v(var.as<SgNB_UE_X2AP_ID>()); return true;
			case 3: v(var.as<Cause>()); return true;
			case 4: v(var.as<CriticalityDiagnostics>()); return true;
			case 5: v(var.as<UE_X2AP_ID_Extension>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(Cause)];
			char dummy2[sizeof(CriticalityDiagnostics)];
			char dummy3[sizeof(SgNB_UE_X2AP_ID)];
			char dummy4[sizeof(UE_X2AP_ID)];
			char dummy5[sizeof(UE_X2AP_ID_Extension)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 6; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(mandatory); type=1;}
		void select_id_SgNB_UE_X2AP_ID() { set(optional); type=2;}
		void select_id_Cause() { set(mandatory); type=3;}
		void select_id_CriticalityDiagnostics() { set(optional); type=4;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(optional); type=5;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(optional)) { type = 2; return true; }
			else if(equal(mandatory)) { type = 3; return true; }
			else if(equal(optional)) { type = 4; return true; }
			else if(equal(optional)) { type = 5; return true; }
			else { type = 6; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(optional);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(optional);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(optional);} return false;
			case 6: type = 6; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
SgNBAdditionRequestReject ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{SgNBAdditionRequestReject-IEs}},
	...
}
*/

struct SgNBAdditionRequestReject : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "SgNBAdditionRequestReject";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<SgNBAdditionRequestReject_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<SgNBAdditionRequestReject_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
SgNBChangeConfirm-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-MeNB-UE-X2AP-ID							CRITICALITY ignore	TYPE UE-X2AP-ID										PRESENCE mandatory}|
	{ ID id-SgNB-UE-X2AP-ID							CRITICALITY ignore	TYPE SgNB-UE-X2AP-ID									PRESENCE mandatory}|
	{ ID id-E-RABs-ToBeReleased-SgNBChaConfList		CRITICALITY ignore	TYPE E-RABs-ToBeReleased-SgNBChaConfList		PRESENCE optional}|
	{ ID id-CriticalityDiagnostics					CRITICALITY ignore	TYPE CriticalityDiagnostics						PRESENCE optional}|
	{ ID id-MeNB-UE-X2AP-ID-Extension				CRITICALITY ignore	TYPE UE-X2AP-ID-Extension							PRESENCE optional},
	...
}
*/

struct SgNBChangeConfirm_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 6; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(id_MeNB_UE_X2AP_ID); type=1;}
		void select_id_SgNB_UE_X2AP_ID() { set(id_SgNB_UE_X2AP_ID); type=2;}
		void select_id_E_RABs_ToBeReleased_SgNBChaConfList() { set(id_E_RABs_ToBeReleased_SgNBChaConfList); type=3;}
		void select_id_CriticalityDiagnostics() { set(id_CriticalityDiagnostics); type=4;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(id_MeNB_UE_X2AP_ID_Extension); type=5;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_MeNB_UE_X2AP_ID)) { type = 1; return true; }
			else if(equal(id_SgNB_UE_X2AP_ID)) { type = 2; return true; }
			else if(equal(id_E_RABs_ToBeReleased_SgNBChaConfList)) { type = 3; return true; }
			else if(equal(id_CriticalityDiagnostics)) { type = 4; return true; }
			else if(equal(id_MeNB_UE_X2AP_ID_Extension)) { type = 5; return true; }
			else { type = 6; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_SgNB_UE_X2AP_ID);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_E_RABs_ToBeReleased_SgNBChaConfList);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(id_CriticalityDiagnostics);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID_Extension);} return false;
			case 6: type = 6; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 6; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(ignore); type=1;}
		void select_id_SgNB_UE_X2AP_ID() { set(ignore); type=2;}
		void select_id_E_RABs_ToBeReleased_SgNBChaConfList() { set(ignore); type=3;}
		void select_id_CriticalityDiagnostics() { set(ignore); type=4;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(ignore); type=5;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else if(equal(ignore)) { type = 2; return true; }
			else if(equal(ignore)) { type = 3; return true; }
			else if(equal(ignore)) { type = 4; return true; }
			else if(equal(ignore)) { type = 5; return true; }
			else { type = 6; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(ignore);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(ignore);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(ignore);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(ignore);} return false;
			case 6: type = 6; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		UE_X2AP_ID& select_id_MeNB_UE_X2AP_ID() { return set<UE_X2AP_ID>(1); }
		UE_X2AP_ID const* get_id_MeNB_UE_X2AP_ID() const { return get<UE_X2AP_ID>(1); }
		SgNB_UE_X2AP_ID& select_id_SgNB_UE_X2AP_ID() { return set<SgNB_UE_X2AP_ID>(2); }
		SgNB_UE_X2AP_ID const* get_id_SgNB_UE_X2AP_ID() const { return get<SgNB_UE_X2AP_ID>(2); }
		E_RABs_ToBeReleased_SgNBChaConfList& select_id_E_RABs_ToBeReleased_SgNBChaConfList() { return set<E_RABs_ToBeReleased_SgNBChaConfList>(3); }
		E_RABs_ToBeReleased_SgNBChaConfList const* get_id_E_RABs_ToBeReleased_SgNBChaConfList() const { return get<E_RABs_ToBeReleased_SgNBChaConfList>(3); }
		CriticalityDiagnostics& select_id_CriticalityDiagnostics() { return set<CriticalityDiagnostics>(4); }
		CriticalityDiagnostics const* get_id_CriticalityDiagnostics() const { return get<CriticalityDiagnostics>(4); }
		UE_X2AP_ID_Extension& select_id_MeNB_UE_X2AP_ID_Extension() { return set<UE_X2AP_ID_Extension>(5); }
		UE_X2AP_ID_Extension const* get_id_MeNB_UE_X2AP_ID_Extension() const { return get<UE_X2AP_ID_Extension>(5); }
		bool is_unknown() const { return type == 6; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<UE_X2AP_ID>(); break;
			case 2: var.destroy<SgNB_UE_X2AP_ID>(); break;
			case 3: var.destroy<E_RABs_ToBeReleased_SgNBChaConfList>(); break;
			case 4: var.destroy<CriticalityDiagnostics>(); break;
			case 5: var.destroy<UE_X2AP_ID_Extension>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<UE_X2AP_ID>(1);
			v.template operator()<SgNB_UE_X2AP_ID>(2);
			v.template operator()<E_RABs_ToBeReleased_SgNBChaConfList>(3);
			v.template operator()<CriticalityDiagnostics>(4);
			v.template operator()<UE_X2AP_ID_Extension>(5);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_MeNB_UE_X2AP_ID()); return true;
			case 2: v(select_id_SgNB_UE_X2AP_ID()); return true;
			case 3: v(select_id_E_RABs_ToBeReleased_SgNBChaConfList()); return true;
			case 4: v(select_id_CriticalityDiagnostics()); return true;
			case 5: v(select_id_MeNB_UE_X2AP_ID_Extension()); return true;
			case 6: if(type != 6) {clear(); asn::base::set();} type = 6; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<UE_X2AP_ID>()); return true;
			case 2: v(var.as<SgNB_UE_X2AP_ID>()); return true;
			case 3: v(var.as<E_RABs_ToBeReleased_SgNBChaConfList>()); return true;
			case 4: v(var.as<CriticalityDiagnostics>()); return true;
			case 5: v(var.as<UE_X2AP_ID_Extension>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(CriticalityDiagnostics)];
			char dummy2[sizeof(E_RABs_ToBeReleased_SgNBChaConfList)];
			char dummy3[sizeof(SgNB_UE_X2AP_ID)];
			char dummy4[sizeof(UE_X2AP_ID)];
			char dummy5[sizeof(UE_X2AP_ID_Extension)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 6; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(mandatory); type=1;}
		void select_id_SgNB_UE_X2AP_ID() { set(mandatory); type=2;}
		void select_id_E_RABs_ToBeReleased_SgNBChaConfList() { set(optional); type=3;}
		void select_id_CriticalityDiagnostics() { set(optional); type=4;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(optional); type=5;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(mandatory)) { type = 2; return true; }
			else if(equal(optional)) { type = 3; return true; }
			else if(equal(optional)) { type = 4; return true; }
			else if(equal(optional)) { type = 5; return true; }
			else { type = 6; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(optional);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(optional);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(optional);} return false;
			case 6: type = 6; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
SgNBChangeConfirm ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{SgNBChangeConfirm-IEs}},
	...
}
*/

struct SgNBChangeConfirm : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "SgNBChangeConfirm";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<SgNBChangeConfirm_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<SgNBChangeConfirm_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
SgNBChangeRefuse-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-MeNB-UE-X2AP-ID						CRITICALITY ignore	TYPE UE-X2AP-ID					PRESENCE mandatory}|
	{ ID id-SgNB-UE-X2AP-ID						CRITICALITY ignore	TYPE SgNB-UE-X2AP-ID				PRESENCE mandatory}|
	{ ID id-Cause								CRITICALITY ignore	TYPE Cause						PRESENCE mandatory}|
	{ ID id-CriticalityDiagnostics				CRITICALITY ignore	TYPE CriticalityDiagnostics		PRESENCE optional}|
	{ ID id-MeNB-UE-X2AP-ID-Extension			CRITICALITY reject	TYPE UE-X2AP-ID-Extension		PRESENCE optional},
	...
}
*/

struct SgNBChangeRefuse_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 6; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(id_MeNB_UE_X2AP_ID); type=1;}
		void select_id_SgNB_UE_X2AP_ID() { set(id_SgNB_UE_X2AP_ID); type=2;}
		void select_id_Cause() { set(id_Cause); type=3;}
		void select_id_CriticalityDiagnostics() { set(id_CriticalityDiagnostics); type=4;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(id_MeNB_UE_X2AP_ID_Extension); type=5;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_MeNB_UE_X2AP_ID)) { type = 1; return true; }
			else if(equal(id_SgNB_UE_X2AP_ID)) { type = 2; return true; }
			else if(equal(id_Cause)) { type = 3; return true; }
			else if(equal(id_CriticalityDiagnostics)) { type = 4; return true; }
			else if(equal(id_MeNB_UE_X2AP_ID_Extension)) { type = 5; return true; }
			else { type = 6; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_SgNB_UE_X2AP_ID);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_Cause);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(id_CriticalityDiagnostics);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID_Extension);} return false;
			case 6: type = 6; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 6; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(ignore); type=1;}
		void select_id_SgNB_UE_X2AP_ID() { set(ignore); type=2;}
		void select_id_Cause() { set(ignore); type=3;}
		void select_id_CriticalityDiagnostics() { set(ignore); type=4;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(reject); type=5;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else if(equal(ignore)) { type = 2; return true; }
			else if(equal(ignore)) { type = 3; return true; }
			else if(equal(ignore)) { type = 4; return true; }
			else if(equal(reject)) { type = 5; return true; }
			else { type = 6; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(ignore);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(ignore);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(ignore);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(reject);} return false;
			case 6: type = 6; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		UE_X2AP_ID& select_id_MeNB_UE_X2AP_ID() { return set<UE_X2AP_ID>(1); }
		UE_X2AP_ID const* get_id_MeNB_UE_X2AP_ID() const { return get<UE_X2AP_ID>(1); }
		SgNB_UE_X2AP_ID& select_id_SgNB_UE_X2AP_ID() { return set<SgNB_UE_X2AP_ID>(2); }
		SgNB_UE_X2AP_ID const* get_id_SgNB_UE_X2AP_ID() const { return get<SgNB_UE_X2AP_ID>(2); }
		Cause& select_id_Cause() { return set<Cause>(3); }
		Cause const* get_id_Cause() const { return get<Cause>(3); }
		CriticalityDiagnostics& select_id_CriticalityDiagnostics() { return set<CriticalityDiagnostics>(4); }
		CriticalityDiagnostics const* get_id_CriticalityDiagnostics() const { return get<CriticalityDiagnostics>(4); }
		UE_X2AP_ID_Extension& select_id_MeNB_UE_X2AP_ID_Extension() { return set<UE_X2AP_ID_Extension>(5); }
		UE_X2AP_ID_Extension const* get_id_MeNB_UE_X2AP_ID_Extension() const { return get<UE_X2AP_ID_Extension>(5); }
		bool is_unknown() const { return type == 6; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<UE_X2AP_ID>(); break;
			case 2: var.destroy<SgNB_UE_X2AP_ID>(); break;
			case 3: var.destroy<Cause>(); break;
			case 4: var.destroy<CriticalityDiagnostics>(); break;
			case 5: var.destroy<UE_X2AP_ID_Extension>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<UE_X2AP_ID>(1);
			v.template operator()<SgNB_UE_X2AP_ID>(2);
			v.template operator()<Cause>(3);
			v.template operator()<CriticalityDiagnostics>(4);
			v.template operator()<UE_X2AP_ID_Extension>(5);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_MeNB_UE_X2AP_ID()); return true;
			case 2: v(select_id_SgNB_UE_X2AP_ID()); return true;
			case 3: v(select_id_Cause()); return true;
			case 4: v(select_id_CriticalityDiagnostics()); return true;
			case 5: v(select_id_MeNB_UE_X2AP_ID_Extension()); return true;
			case 6: if(type != 6) {clear(); asn::base::set();} type = 6; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<UE_X2AP_ID>()); return true;
			case 2: v(var.as<SgNB_UE_X2AP_ID>()); return true;
			case 3: v(var.as<Cause>()); return true;
			case 4: v(var.as<CriticalityDiagnostics>()); return true;
			case 5: v(var.as<UE_X2AP_ID_Extension>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(Cause)];
			char dummy2[sizeof(CriticalityDiagnostics)];
			char dummy3[sizeof(SgNB_UE_X2AP_ID)];
			char dummy4[sizeof(UE_X2AP_ID)];
			char dummy5[sizeof(UE_X2AP_ID_Extension)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 6; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(mandatory); type=1;}
		void select_id_SgNB_UE_X2AP_ID() { set(mandatory); type=2;}
		void select_id_Cause() { set(mandatory); type=3;}
		void select_id_CriticalityDiagnostics() { set(optional); type=4;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(optional); type=5;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(mandatory)) { type = 2; return true; }
			else if(equal(mandatory)) { type = 3; return true; }
			else if(equal(optional)) { type = 4; return true; }
			else if(equal(optional)) { type = 5; return true; }
			else { type = 6; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(optional);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(optional);} return false;
			case 6: type = 6; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
SgNBChangeRefuse ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container		{{SgNBChangeRefuse-IEs}},
	...
}
*/

struct SgNBChangeRefuse : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "SgNBChangeRefuse";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<SgNBChangeRefuse_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<SgNBChangeRefuse_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
SgNBChangeRequired-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-MeNB-UE-X2AP-ID						CRITICALITY reject	TYPE UE-X2AP-ID					PRESENCE mandatory}|
	{ ID id-SgNB-UE-X2AP-ID						CRITICALITY reject	TYPE SgNB-UE-X2AP-ID				PRESENCE mandatory}|
	{ ID id-Target-SgNB-ID						CRITICALITY reject	TYPE GlobalGNB-ID						PRESENCE mandatory}|
	{ ID id-Cause								CRITICALITY ignore	TYPE Cause						PRESENCE mandatory}|
	{ ID id-SgNBtoMeNBContainer					CRITICALITY reject	TYPE SgNBtoMeNBContainer			PRESENCE optional}|
	{ ID id-MeNB-UE-X2AP-ID-Extension			CRITICALITY reject	TYPE UE-X2AP-ID-Extension		PRESENCE optional},
	...
}
*/

struct SgNBChangeRequired_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 7; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(id_MeNB_UE_X2AP_ID); type=1;}
		void select_id_SgNB_UE_X2AP_ID() { set(id_SgNB_UE_X2AP_ID); type=2;}
		void select_id_Target_SgNB_ID() { set(id_Target_SgNB_ID); type=3;}
		void select_id_Cause() { set(id_Cause); type=4;}
		void select_id_SgNBtoMeNBContainer() { set(id_SgNBtoMeNBContainer); type=5;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(id_MeNB_UE_X2AP_ID_Extension); type=6;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_MeNB_UE_X2AP_ID)) { type = 1; return true; }
			else if(equal(id_SgNB_UE_X2AP_ID)) { type = 2; return true; }
			else if(equal(id_Target_SgNB_ID)) { type = 3; return true; }
			else if(equal(id_Cause)) { type = 4; return true; }
			else if(equal(id_SgNBtoMeNBContainer)) { type = 5; return true; }
			else if(equal(id_MeNB_UE_X2AP_ID_Extension)) { type = 6; return true; }
			else { type = 7; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_SgNB_UE_X2AP_ID);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_Target_SgNB_ID);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(id_Cause);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(id_SgNBtoMeNBContainer);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID_Extension);} return false;
			case 7: type = 7; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 7; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(reject); type=1;}
		void select_id_SgNB_UE_X2AP_ID() { set(reject); type=2;}
		void select_id_Target_SgNB_ID() { set(reject); type=3;}
		void select_id_Cause() { set(ignore); type=4;}
		void select_id_SgNBtoMeNBContainer() { set(reject); type=5;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(reject); type=6;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else if(equal(reject)) { type = 2; return true; }
			else if(equal(reject)) { type = 3; return true; }
			else if(equal(ignore)) { type = 4; return true; }
			else if(equal(reject)) { type = 5; return true; }
			else if(equal(reject)) { type = 6; return true; }
			else { type = 7; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(reject);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(reject);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(ignore);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(reject);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(reject);} return false;
			case 7: type = 7; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		UE_X2AP_ID& select_id_MeNB_UE_X2AP_ID() { return set<UE_X2AP_ID>(1); }
		UE_X2AP_ID const* get_id_MeNB_UE_X2AP_ID() const { return get<UE_X2AP_ID>(1); }
		SgNB_UE_X2AP_ID& select_id_SgNB_UE_X2AP_ID() { return set<SgNB_UE_X2AP_ID>(2); }
		SgNB_UE_X2AP_ID const* get_id_SgNB_UE_X2AP_ID() const { return get<SgNB_UE_X2AP_ID>(2); }
		GlobalGNB_ID& select_id_Target_SgNB_ID() { return set<GlobalGNB_ID>(3); }
		GlobalGNB_ID const* get_id_Target_SgNB_ID() const { return get<GlobalGNB_ID>(3); }
		Cause& select_id_Cause() { return set<Cause>(4); }
		Cause const* get_id_Cause() const { return get<Cause>(4); }
		SgNBtoMeNBContainer& select_id_SgNBtoMeNBContainer() { return set<SgNBtoMeNBContainer>(5); }
		SgNBtoMeNBContainer const* get_id_SgNBtoMeNBContainer() const { return get<SgNBtoMeNBContainer>(5); }
		UE_X2AP_ID_Extension& select_id_MeNB_UE_X2AP_ID_Extension() { return set<UE_X2AP_ID_Extension>(6); }
		UE_X2AP_ID_Extension const* get_id_MeNB_UE_X2AP_ID_Extension() const { return get<UE_X2AP_ID_Extension>(6); }
		bool is_unknown() const { return type == 7; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<UE_X2AP_ID>(); break;
			case 2: var.destroy<SgNB_UE_X2AP_ID>(); break;
			case 3: var.destroy<GlobalGNB_ID>(); break;
			case 4: var.destroy<Cause>(); break;
			case 5: var.destroy<SgNBtoMeNBContainer>(); break;
			case 6: var.destroy<UE_X2AP_ID_Extension>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<UE_X2AP_ID>(1);
			v.template operator()<SgNB_UE_X2AP_ID>(2);
			v.template operator()<GlobalGNB_ID>(3);
			v.template operator()<Cause>(4);
			v.template operator()<SgNBtoMeNBContainer>(5);
			v.template operator()<UE_X2AP_ID_Extension>(6);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_MeNB_UE_X2AP_ID()); return true;
			case 2: v(select_id_SgNB_UE_X2AP_ID()); return true;
			case 3: v(select_id_Target_SgNB_ID()); return true;
			case 4: v(select_id_Cause()); return true;
			case 5: v(select_id_SgNBtoMeNBContainer()); return true;
			case 6: v(select_id_MeNB_UE_X2AP_ID_Extension()); return true;
			case 7: if(type != 7) {clear(); asn::base::set();} type = 7; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<UE_X2AP_ID>()); return true;
			case 2: v(var.as<SgNB_UE_X2AP_ID>()); return true;
			case 3: v(var.as<GlobalGNB_ID>()); return true;
			case 4: v(var.as<Cause>()); return true;
			case 5: v(var.as<SgNBtoMeNBContainer>()); return true;
			case 6: v(var.as<UE_X2AP_ID_Extension>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(Cause)];
			char dummy2[sizeof(GlobalGNB_ID)];
			char dummy3[sizeof(SgNB_UE_X2AP_ID)];
			char dummy4[sizeof(SgNBtoMeNBContainer)];
			char dummy5[sizeof(UE_X2AP_ID)];
			char dummy6[sizeof(UE_X2AP_ID_Extension)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 7; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(mandatory); type=1;}
		void select_id_SgNB_UE_X2AP_ID() { set(mandatory); type=2;}
		void select_id_Target_SgNB_ID() { set(mandatory); type=3;}
		void select_id_Cause() { set(mandatory); type=4;}
		void select_id_SgNBtoMeNBContainer() { set(optional); type=5;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(optional); type=6;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(mandatory)) { type = 2; return true; }
			else if(equal(mandatory)) { type = 3; return true; }
			else if(equal(mandatory)) { type = 4; return true; }
			else if(equal(optional)) { type = 5; return true; }
			else if(equal(optional)) { type = 6; return true; }
			else { type = 7; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(optional);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(optional);} return false;
			case 7: type = 7; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
SgNBChangeRequired ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container		{{SgNBChangeRequired-IEs}},
	...
}
*/

struct SgNBChangeRequired : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "SgNBChangeRequired";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<SgNBChangeRequired_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<SgNBChangeRequired_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
SgNBCounterCheckRequest-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-MeNB-UE-X2AP-ID								CRITICALITY reject	TYPE UE-X2AP-ID											PRESENCE mandatory}|
	{ ID id-SgNB-UE-X2AP-ID								CRITICALITY reject	TYPE SgNB-UE-X2AP-ID										PRESENCE mandatory}|
	{ ID id-E-RABs-SubjectToSgNBCounterCheck-List		CRITICALITY ignore	TYPE E-RABs-SubjectToSgNBCounterCheck-List		PRESENCE mandatory}|
	{ ID id-MeNB-UE-X2AP-ID-Extension					CRITICALITY ignore	TYPE UE-X2AP-ID-Extension							PRESENCE optional},
	...
}
*/

struct SgNBCounterCheckRequest_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 5; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(id_MeNB_UE_X2AP_ID); type=1;}
		void select_id_SgNB_UE_X2AP_ID() { set(id_SgNB_UE_X2AP_ID); type=2;}
		void select_id_E_RABs_SubjectToSgNBCounterCheck_List() { set(id_E_RABs_SubjectToSgNBCounterCheck_List); type=3;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(id_MeNB_UE_X2AP_ID_Extension); type=4;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_MeNB_UE_X2AP_ID)) { type = 1; return true; }
			else if(equal(id_SgNB_UE_X2AP_ID)) { type = 2; return true; }
			else if(equal(id_E_RABs_SubjectToSgNBCounterCheck_List)) { type = 3; return true; }
			else if(equal(id_MeNB_UE_X2AP_ID_Extension)) { type = 4; return true; }
			else { type = 5; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_SgNB_UE_X2AP_ID);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_E_RABs_SubjectToSgNBCounterCheck_List);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID_Extension);} return false;
			case 5: type = 5; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 5; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(reject); type=1;}
		void select_id_SgNB_UE_X2AP_ID() { set(reject); type=2;}
		void select_id_E_RABs_SubjectToSgNBCounterCheck_List() { set(ignore); type=3;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(ignore); type=4;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else if(equal(reject)) { type = 2; return true; }
			else if(equal(ignore)) { type = 3; return true; }
			else if(equal(ignore)) { type = 4; return true; }
			else { type = 5; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(reject);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(ignore);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(ignore);} return false;
			case 5: type = 5; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		UE_X2AP_ID& select_id_MeNB_UE_X2AP_ID() { return set<UE_X2AP_ID>(1); }
		UE_X2AP_ID const* get_id_MeNB_UE_X2AP_ID() const { return get<UE_X2AP_ID>(1); }
		SgNB_UE_X2AP_ID& select_id_SgNB_UE_X2AP_ID() { return set<SgNB_UE_X2AP_ID>(2); }
		SgNB_UE_X2AP_ID const* get_id_SgNB_UE_X2AP_ID() const { return get<SgNB_UE_X2AP_ID>(2); }
		E_RABs_SubjectToSgNBCounterCheck_List& select_id_E_RABs_SubjectToSgNBCounterCheck_List() { return set<E_RABs_SubjectToSgNBCounterCheck_List>(3); }
		E_RABs_SubjectToSgNBCounterCheck_List const* get_id_E_RABs_SubjectToSgNBCounterCheck_List() const { return get<E_RABs_SubjectToSgNBCounterCheck_List>(3); }
		UE_X2AP_ID_Extension& select_id_MeNB_UE_X2AP_ID_Extension() { return set<UE_X2AP_ID_Extension>(4); }
		UE_X2AP_ID_Extension const* get_id_MeNB_UE_X2AP_ID_Extension() const { return get<UE_X2AP_ID_Extension>(4); }
		bool is_unknown() const { return type == 5; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<UE_X2AP_ID>(); break;
			case 2: var.destroy<SgNB_UE_X2AP_ID>(); break;
			case 3: var.destroy<E_RABs_SubjectToSgNBCounterCheck_List>(); break;
			case 4: var.destroy<UE_X2AP_ID_Extension>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<UE_X2AP_ID>(1);
			v.template operator()<SgNB_UE_X2AP_ID>(2);
			v.template operator()<E_RABs_SubjectToSgNBCounterCheck_List>(3);
			v.template operator()<UE_X2AP_ID_Extension>(4);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_MeNB_UE_X2AP_ID()); return true;
			case 2: v(select_id_SgNB_UE_X2AP_ID()); return true;
			case 3: v(select_id_E_RABs_SubjectToSgNBCounterCheck_List()); return true;
			case 4: v(select_id_MeNB_UE_X2AP_ID_Extension()); return true;
			case 5: if(type != 5) {clear(); asn::base::set();} type = 5; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<UE_X2AP_ID>()); return true;
			case 2: v(var.as<SgNB_UE_X2AP_ID>()); return true;
			case 3: v(var.as<E_RABs_SubjectToSgNBCounterCheck_List>()); return true;
			case 4: v(var.as<UE_X2AP_ID_Extension>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(E_RABs_SubjectToSgNBCounterCheck_List)];
			char dummy2[sizeof(SgNB_UE_X2AP_ID)];
			char dummy3[sizeof(UE_X2AP_ID)];
			char dummy4[sizeof(UE_X2AP_ID_Extension)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 5; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(mandatory); type=1;}
		void select_id_SgNB_UE_X2AP_ID() { set(mandatory); type=2;}
		void select_id_E_RABs_SubjectToSgNBCounterCheck_List() { set(mandatory); type=3;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(optional); type=4;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(mandatory)) { type = 2; return true; }
			else if(equal(mandatory)) { type = 3; return true; }
			else if(equal(optional)) { type = 4; return true; }
			else { type = 5; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(optional);} return false;
			case 5: type = 5; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
SgNBCounterCheckRequest ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{SgNBCounterCheckRequest-IEs}},
	...
}
*/

struct SgNBCounterCheckRequest : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "SgNBCounterCheckRequest";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<SgNBCounterCheckRequest_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<SgNBCounterCheckRequest_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
SgNBModificationConfirm-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-MeNB-UE-X2AP-ID									CRITICALITY ignore	TYPE UE-X2AP-ID											PRESENCE mandatory}|
	{ ID id-SgNB-UE-X2AP-ID									CRITICALITY ignore	TYPE SgNB-UE-X2AP-ID									PRESENCE mandatory}|
	{ ID id-E-RABs-AdmittedToBeModified-SgNBModConfList		CRITICALITY ignore	TYPE E-RABs-AdmittedToBeModified-SgNBModConfList		PRESENCE optional}|
	{ ID id-MeNBtoSgNBContainer								CRITICALITY ignore	TYPE MeNBtoSgNBContainer							PRESENCE optional}|
	{ ID id-CriticalityDiagnostics							CRITICALITY ignore	TYPE CriticalityDiagnostics						PRESENCE optional}|
	{ ID id-MeNB-UE-X2AP-ID-Extension						CRITICALITY ignore	TYPE UE-X2AP-ID-Extension							PRESENCE optional}|
	{ ID id-MeNBResourceCoordinationInformation				CRITICALITY ignore	TYPE MeNBResourceCoordinationInformation		PRESENCE optional},
	...
}
*/

struct SgNBModificationConfirm_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 8; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(id_MeNB_UE_X2AP_ID); type=1;}
		void select_id_SgNB_UE_X2AP_ID() { set(id_SgNB_UE_X2AP_ID); type=2;}
		void select_id_E_RABs_AdmittedToBeModified_SgNBModConfList() { set(id_E_RABs_AdmittedToBeModified_SgNBModConfList); type=3;}
		void select_id_MeNBtoSgNBContainer() { set(id_MeNBtoSgNBContainer); type=4;}
		void select_id_CriticalityDiagnostics() { set(id_CriticalityDiagnostics); type=5;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(id_MeNB_UE_X2AP_ID_Extension); type=6;}
		void select_id_MeNBResourceCoordinationInformation() { set(id_MeNBResourceCoordinationInformation); type=7;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_MeNB_UE_X2AP_ID)) { type = 1; return true; }
			else if(equal(id_SgNB_UE_X2AP_ID)) { type = 2; return true; }
			else if(equal(id_E_RABs_AdmittedToBeModified_SgNBModConfList)) { type = 3; return true; }
			else if(equal(id_MeNBtoSgNBContainer)) { type = 4; return true; }
			else if(equal(id_CriticalityDiagnostics)) { type = 5; return true; }
			else if(equal(id_MeNB_UE_X2AP_ID_Extension)) { type = 6; return true; }
			else if(equal(id_MeNBResourceCoordinationInformation)) { type = 7; return true; }
			else { type = 8; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_SgNB_UE_X2AP_ID);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_E_RABs_AdmittedToBeModified_SgNBModConfList);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(id_MeNBtoSgNBContainer);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(id_CriticalityDiagnostics);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID_Extension);} return false;
			case 7: type = 7; if(v(ref_nested())) { return equal(id_MeNBResourceCoordinationInformation);} return false;
			case 8: type = 8; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 8; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(ignore); type=1;}
		void select_id_SgNB_UE_X2AP_ID() { set(ignore); type=2;}
		void select_id_E_RABs_AdmittedToBeModified_SgNBModConfList() { set(ignore); type=3;}
		void select_id_MeNBtoSgNBContainer() { set(ignore); type=4;}
		void select_id_CriticalityDiagnostics() { set(ignore); type=5;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(ignore); type=6;}
		void select_id_MeNBResourceCoordinationInformation() { set(ignore); type=7;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else if(equal(ignore)) { type = 2; return true; }
			else if(equal(ignore)) { type = 3; return true; }
			else if(equal(ignore)) { type = 4; return true; }
			else if(equal(ignore)) { type = 5; return true; }
			else if(equal(ignore)) { type = 6; return true; }
			else if(equal(ignore)) { type = 7; return true; }
			else { type = 8; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(ignore);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(ignore);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(ignore);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(ignore);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(ignore);} return false;
			case 7: type = 7; if(v(ref_nested())) { return equal(ignore);} return false;
			case 8: type = 8; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		UE_X2AP_ID& select_id_MeNB_UE_X2AP_ID() { return set<UE_X2AP_ID>(1); }
		UE_X2AP_ID const* get_id_MeNB_UE_X2AP_ID() const { return get<UE_X2AP_ID>(1); }
		SgNB_UE_X2AP_ID& select_id_SgNB_UE_X2AP_ID() { return set<SgNB_UE_X2AP_ID>(2); }
		SgNB_UE_X2AP_ID const* get_id_SgNB_UE_X2AP_ID() const { return get<SgNB_UE_X2AP_ID>(2); }
		E_RABs_AdmittedToBeModified_SgNBModConfList& select_id_E_RABs_AdmittedToBeModified_SgNBModConfList() { return set<E_RABs_AdmittedToBeModified_SgNBModConfList>(3); }
		E_RABs_AdmittedToBeModified_SgNBModConfList const* get_id_E_RABs_AdmittedToBeModified_SgNBModConfList() const { return get<E_RABs_AdmittedToBeModified_SgNBModConfList>(3); }
		MeNBtoSgNBContainer& select_id_MeNBtoSgNBContainer() { return set<MeNBtoSgNBContainer>(4); }
		MeNBtoSgNBContainer const* get_id_MeNBtoSgNBContainer() const { return get<MeNBtoSgNBContainer>(4); }
		CriticalityDiagnostics& select_id_CriticalityDiagnostics() { return set<CriticalityDiagnostics>(5); }
		CriticalityDiagnostics const* get_id_CriticalityDiagnostics() const { return get<CriticalityDiagnostics>(5); }
		UE_X2AP_ID_Extension& select_id_MeNB_UE_X2AP_ID_Extension() { return set<UE_X2AP_ID_Extension>(6); }
		UE_X2AP_ID_Extension const* get_id_MeNB_UE_X2AP_ID_Extension() const { return get<UE_X2AP_ID_Extension>(6); }
		MeNBResourceCoordinationInformation& select_id_MeNBResourceCoordinationInformation() { return set<MeNBResourceCoordinationInformation>(7); }
		MeNBResourceCoordinationInformation const* get_id_MeNBResourceCoordinationInformation() const { return get<MeNBResourceCoordinationInformation>(7); }
		bool is_unknown() const { return type == 8; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<UE_X2AP_ID>(); break;
			case 2: var.destroy<SgNB_UE_X2AP_ID>(); break;
			case 3: var.destroy<E_RABs_AdmittedToBeModified_SgNBModConfList>(); break;
			case 4: var.destroy<MeNBtoSgNBContainer>(); break;
			case 5: var.destroy<CriticalityDiagnostics>(); break;
			case 6: var.destroy<UE_X2AP_ID_Extension>(); break;
			case 7: var.destroy<MeNBResourceCoordinationInformation>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<UE_X2AP_ID>(1);
			v.template operator()<SgNB_UE_X2AP_ID>(2);
			v.template operator()<E_RABs_AdmittedToBeModified_SgNBModConfList>(3);
			v.template operator()<MeNBtoSgNBContainer>(4);
			v.template operator()<CriticalityDiagnostics>(5);
			v.template operator()<UE_X2AP_ID_Extension>(6);
			v.template operator()<MeNBResourceCoordinationInformation>(7);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_MeNB_UE_X2AP_ID()); return true;
			case 2: v(select_id_SgNB_UE_X2AP_ID()); return true;
			case 3: v(select_id_E_RABs_AdmittedToBeModified_SgNBModConfList()); return true;
			case 4: v(select_id_MeNBtoSgNBContainer()); return true;
			case 5: v(select_id_CriticalityDiagnostics()); return true;
			case 6: v(select_id_MeNB_UE_X2AP_ID_Extension()); return true;
			case 7: v(select_id_MeNBResourceCoordinationInformation()); return true;
			case 8: if(type != 8) {clear(); asn::base::set();} type = 8; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<UE_X2AP_ID>()); return true;
			case 2: v(var.as<SgNB_UE_X2AP_ID>()); return true;
			case 3: v(var.as<E_RABs_AdmittedToBeModified_SgNBModConfList>()); return true;
			case 4: v(var.as<MeNBtoSgNBContainer>()); return true;
			case 5: v(var.as<CriticalityDiagnostics>()); return true;
			case 6: v(var.as<UE_X2AP_ID_Extension>()); return true;
			case 7: v(var.as<MeNBResourceCoordinationInformation>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(CriticalityDiagnostics)];
			char dummy2[sizeof(E_RABs_AdmittedToBeModified_SgNBModConfList)];
			char dummy3[sizeof(MeNBResourceCoordinationInformation)];
			char dummy4[sizeof(MeNBtoSgNBContainer)];
			char dummy5[sizeof(SgNB_UE_X2AP_ID)];
			char dummy6[sizeof(UE_X2AP_ID)];
			char dummy7[sizeof(UE_X2AP_ID_Extension)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 8; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(mandatory); type=1;}
		void select_id_SgNB_UE_X2AP_ID() { set(mandatory); type=2;}
		void select_id_E_RABs_AdmittedToBeModified_SgNBModConfList() { set(optional); type=3;}
		void select_id_MeNBtoSgNBContainer() { set(optional); type=4;}
		void select_id_CriticalityDiagnostics() { set(optional); type=5;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(optional); type=6;}
		void select_id_MeNBResourceCoordinationInformation() { set(optional); type=7;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(mandatory)) { type = 2; return true; }
			else if(equal(optional)) { type = 3; return true; }
			else if(equal(optional)) { type = 4; return true; }
			else if(equal(optional)) { type = 5; return true; }
			else if(equal(optional)) { type = 6; return true; }
			else if(equal(optional)) { type = 7; return true; }
			else { type = 8; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(optional);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(optional);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(optional);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(optional);} return false;
			case 7: type = 7; if(v(ref_nested())) { return equal(optional);} return false;
			case 8: type = 8; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
SgNBModificationConfirm ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{SgNBModificationConfirm-IEs}},
	...
}
*/

struct SgNBModificationConfirm : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "SgNBModificationConfirm";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<SgNBModificationConfirm_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<SgNBModificationConfirm_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
SgNBModificationRefuse-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-MeNB-UE-X2AP-ID						CRITICALITY ignore	TYPE UE-X2AP-ID					PRESENCE mandatory}|
	{ ID id-SgNB-UE-X2AP-ID						CRITICALITY ignore	TYPE SgNB-UE-X2AP-ID				PRESENCE mandatory}|
	{ ID id-Cause								CRITICALITY ignore	TYPE Cause						PRESENCE mandatory}|
	{ ID id-MeNBtoSgNBContainer					CRITICALITY ignore	TYPE MeNBtoSgNBContainer			PRESENCE optional}|
	{ ID id-CriticalityDiagnostics				CRITICALITY ignore	TYPE CriticalityDiagnostics		PRESENCE optional}|
	{ ID id-MeNB-UE-X2AP-ID-Extension			CRITICALITY ignore	TYPE UE-X2AP-ID-Extension		PRESENCE optional},
	...
}
*/

struct SgNBModificationRefuse_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 7; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(id_MeNB_UE_X2AP_ID); type=1;}
		void select_id_SgNB_UE_X2AP_ID() { set(id_SgNB_UE_X2AP_ID); type=2;}
		void select_id_Cause() { set(id_Cause); type=3;}
		void select_id_MeNBtoSgNBContainer() { set(id_MeNBtoSgNBContainer); type=4;}
		void select_id_CriticalityDiagnostics() { set(id_CriticalityDiagnostics); type=5;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(id_MeNB_UE_X2AP_ID_Extension); type=6;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_MeNB_UE_X2AP_ID)) { type = 1; return true; }
			else if(equal(id_SgNB_UE_X2AP_ID)) { type = 2; return true; }
			else if(equal(id_Cause)) { type = 3; return true; }
			else if(equal(id_MeNBtoSgNBContainer)) { type = 4; return true; }
			else if(equal(id_CriticalityDiagnostics)) { type = 5; return true; }
			else if(equal(id_MeNB_UE_X2AP_ID_Extension)) { type = 6; return true; }
			else { type = 7; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_SgNB_UE_X2AP_ID);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_Cause);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(id_MeNBtoSgNBContainer);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(id_CriticalityDiagnostics);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID_Extension);} return false;
			case 7: type = 7; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 7; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(ignore); type=1;}
		void select_id_SgNB_UE_X2AP_ID() { set(ignore); type=2;}
		void select_id_Cause() { set(ignore); type=3;}
		void select_id_MeNBtoSgNBContainer() { set(ignore); type=4;}
		void select_id_CriticalityDiagnostics() { set(ignore); type=5;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(ignore); type=6;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else if(equal(ignore)) { type = 2; return true; }
			else if(equal(ignore)) { type = 3; return true; }
			else if(equal(ignore)) { type = 4; return true; }
			else if(equal(ignore)) { type = 5; return true; }
			else if(equal(ignore)) { type = 6; return true; }
			else { type = 7; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(ignore);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(ignore);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(ignore);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(ignore);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(ignore);} return false;
			case 7: type = 7; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		UE_X2AP_ID& select_id_MeNB_UE_X2AP_ID() { return set<UE_X2AP_ID>(1); }
		UE_X2AP_ID const* get_id_MeNB_UE_X2AP_ID() const { return get<UE_X2AP_ID>(1); }
		SgNB_UE_X2AP_ID& select_id_SgNB_UE_X2AP_ID() { return set<SgNB_UE_X2AP_ID>(2); }
		SgNB_UE_X2AP_ID const* get_id_SgNB_UE_X2AP_ID() const { return get<SgNB_UE_X2AP_ID>(2); }
		Cause& select_id_Cause() { return set<Cause>(3); }
		Cause const* get_id_Cause() const { return get<Cause>(3); }
		MeNBtoSgNBContainer& select_id_MeNBtoSgNBContainer() { return set<MeNBtoSgNBContainer>(4); }
		MeNBtoSgNBContainer const* get_id_MeNBtoSgNBContainer() const { return get<MeNBtoSgNBContainer>(4); }
		CriticalityDiagnostics& select_id_CriticalityDiagnostics() { return set<CriticalityDiagnostics>(5); }
		CriticalityDiagnostics const* get_id_CriticalityDiagnostics() const { return get<CriticalityDiagnostics>(5); }
		UE_X2AP_ID_Extension& select_id_MeNB_UE_X2AP_ID_Extension() { return set<UE_X2AP_ID_Extension>(6); }
		UE_X2AP_ID_Extension const* get_id_MeNB_UE_X2AP_ID_Extension() const { return get<UE_X2AP_ID_Extension>(6); }
		bool is_unknown() const { return type == 7; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<UE_X2AP_ID>(); break;
			case 2: var.destroy<SgNB_UE_X2AP_ID>(); break;
			case 3: var.destroy<Cause>(); break;
			case 4: var.destroy<MeNBtoSgNBContainer>(); break;
			case 5: var.destroy<CriticalityDiagnostics>(); break;
			case 6: var.destroy<UE_X2AP_ID_Extension>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<UE_X2AP_ID>(1);
			v.template operator()<SgNB_UE_X2AP_ID>(2);
			v.template operator()<Cause>(3);
			v.template operator()<MeNBtoSgNBContainer>(4);
			v.template operator()<CriticalityDiagnostics>(5);
			v.template operator()<UE_X2AP_ID_Extension>(6);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_MeNB_UE_X2AP_ID()); return true;
			case 2: v(select_id_SgNB_UE_X2AP_ID()); return true;
			case 3: v(select_id_Cause()); return true;
			case 4: v(select_id_MeNBtoSgNBContainer()); return true;
			case 5: v(select_id_CriticalityDiagnostics()); return true;
			case 6: v(select_id_MeNB_UE_X2AP_ID_Extension()); return true;
			case 7: if(type != 7) {clear(); asn::base::set();} type = 7; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<UE_X2AP_ID>()); return true;
			case 2: v(var.as<SgNB_UE_X2AP_ID>()); return true;
			case 3: v(var.as<Cause>()); return true;
			case 4: v(var.as<MeNBtoSgNBContainer>()); return true;
			case 5: v(var.as<CriticalityDiagnostics>()); return true;
			case 6: v(var.as<UE_X2AP_ID_Extension>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(Cause)];
			char dummy2[sizeof(CriticalityDiagnostics)];
			char dummy3[sizeof(MeNBtoSgNBContainer)];
			char dummy4[sizeof(SgNB_UE_X2AP_ID)];
			char dummy5[sizeof(UE_X2AP_ID)];
			char dummy6[sizeof(UE_X2AP_ID_Extension)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 7; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(mandatory); type=1;}
		void select_id_SgNB_UE_X2AP_ID() { set(mandatory); type=2;}
		void select_id_Cause() { set(mandatory); type=3;}
		void select_id_MeNBtoSgNBContainer() { set(optional); type=4;}
		void select_id_CriticalityDiagnostics() { set(optional); type=5;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(optional); type=6;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(mandatory)) { type = 2; return true; }
			else if(equal(mandatory)) { type = 3; return true; }
			else if(equal(optional)) { type = 4; return true; }
			else if(equal(optional)) { type = 5; return true; }
			else if(equal(optional)) { type = 6; return true; }
			else { type = 7; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(optional);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(optional);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(optional);} return false;
			case 7: type = 7; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
SgNBModificationRefuse ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container		{{SgNBModificationRefuse-IEs}},
	...
}
*/

struct SgNBModificationRefuse : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "SgNBModificationRefuse";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<SgNBModificationRefuse_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<SgNBModificationRefuse_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
UE-ContextInformationSgNBModReqExtIEs X2AP-PROTOCOL-EXTENSION ::= {
	{	ID id-SubscriberProfileIDforRFP					CRITICALITY ignore	EXTENSION SubscriberProfileIDforRFP									PRESENCE optional},
	...
}
*/

struct UE_ContextInformationSgNBModReqExtIEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_SubscriberProfileIDforRFP() { set(id_SubscriberProfileIDforRFP); type=1;}
		X2AP_PROTOCOL_EXTENSION::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_SubscriberProfileIDforRFP)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_SubscriberProfileIDforRFP);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_SubscriberProfileIDforRFP() { set(ignore); type=1;}
		X2AP_PROTOCOL_EXTENSION::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Extension_t : asn::typefield<true>
	{
		~Extension_t()	{clear();}
		size_t get_index() const {return type;}
		SubscriberProfileIDforRFP& select_id_SubscriberProfileIDforRFP() { return set<SubscriberProfileIDforRFP>(1); }
		SubscriberProfileIDforRFP const* get_id_SubscriberProfileIDforRFP() const { return get<SubscriberProfileIDforRFP>(1); }
		bool is_unknown() const { return type == 2; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<SubscriberProfileIDforRFP>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<SubscriberProfileIDforRFP>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_SubscriberProfileIDforRFP()); return true;
			case 2: if(type != 2) {clear(); asn::base::set();} type = 2; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<SubscriberProfileIDforRFP>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(SubscriberProfileIDforRFP)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_EXTENSION::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_SubscriberProfileIDforRFP() { set(optional); type=1;}
		X2AP_PROTOCOL_EXTENSION::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(optional)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(optional);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
UE-ContextInformation-SgNBModReq ::= SEQUENCE {
	nRUE-SecurityCapabilities		NRUESecurityCapabilities															OPTIONAL,
	sgNB-SecurityKey				SgNBSecurityKey 																	OPTIONAL,
	sgNBUEAggregateMaximumBitRate	UEAggregateMaximumBitRate															OPTIONAL,
	e-RABs-ToBeAdded				E-RABs-ToBeAdded-SgNBModReq-List													OPTIONAL,
	e-RABs-ToBeModified				E-RABs-ToBeModified-SgNBModReq-List													OPTIONAL,
	e-RABs-ToBeReleased				E-RABs-ToBeReleased-SgNBModReq-List													OPTIONAL,
	iE-Extensions					ProtocolExtensionContainer { {UE-ContextInformationSgNBModReqExtIEs} }			OPTIONAL,
	...
}
*/

struct UE_ContextInformation_SgNBModReq : asn::sequence<7, 0, true, 7>
{
	static constexpr const char* name() {return "UE-ContextInformation-SgNBModReq";}
	using parent_t = asn::sequence<7, 0, true, 7>;
	struct nRUE_SecurityCapabilities_t : NRUESecurityCapabilities
	{
		static constexpr const char* name() {return "nRUE_SecurityCapabilities_t";}
		using parent_t = NRUESecurityCapabilities;
		static constexpr bool optional = true;

	};
	nRUE_SecurityCapabilities_t& set_nRUE_SecurityCapabilities() { nRUE_SecurityCapabilities.setpresent(true); return nRUE_SecurityCapabilities;}
	nRUE_SecurityCapabilities_t const* get_nRUE_SecurityCapabilities() const {return nRUE_SecurityCapabilities.is_valid() ? &nRUE_SecurityCapabilities : nullptr;}
	struct sgNB_SecurityKey_t : SgNBSecurityKey
	{
		static constexpr const char* name() {return "sgNB_SecurityKey_t";}
		using parent_t = SgNBSecurityKey;
		static constexpr bool optional = true;

	};
	sgNB_SecurityKey_t& set_sgNB_SecurityKey() { sgNB_SecurityKey.setpresent(true); return sgNB_SecurityKey;}
	sgNB_SecurityKey_t const* get_sgNB_SecurityKey() const {return sgNB_SecurityKey.is_valid() ? &sgNB_SecurityKey : nullptr;}
	struct sgNBUEAggregateMaximumBitRate_t : UEAggregateMaximumBitRate
	{
		static constexpr const char* name() {return "sgNBUEAggregateMaximumBitRate_t";}
		using parent_t = UEAggregateMaximumBitRate;
		static constexpr bool optional = true;

	};
	sgNBUEAggregateMaximumBitRate_t& set_sgNBUEAggregateMaximumBitRate() { sgNBUEAggregateMaximumBitRate.setpresent(true); return sgNBUEAggregateMaximumBitRate;}
	sgNBUEAggregateMaximumBitRate_t const* get_sgNBUEAggregateMaximumBitRate() const {return sgNBUEAggregateMaximumBitRate.is_valid() ? &sgNBUEAggregateMaximumBitRate : nullptr;}
	struct e_RABs_ToBeAdded_t : E_RABs_ToBeAdded_SgNBModReq_List
	{
		static constexpr const char* name() {return "e_RABs_ToBeAdded_t";}
		using parent_t = E_RABs_ToBeAdded_SgNBModReq_List;
		static constexpr bool optional = true;

	};
	e_RABs_ToBeAdded_t& set_e_RABs_ToBeAdded() { e_RABs_ToBeAdded.setpresent(true); return e_RABs_ToBeAdded;}
	e_RABs_ToBeAdded_t const* get_e_RABs_ToBeAdded() const {return e_RABs_ToBeAdded.is_valid() ? &e_RABs_ToBeAdded : nullptr;}
	struct e_RABs_ToBeModified_t : E_RABs_ToBeModified_SgNBModReq_List
	{
		static constexpr const char* name() {return "e_RABs_ToBeModified_t";}
		using parent_t = E_RABs_ToBeModified_SgNBModReq_List;
		static constexpr bool optional = true;

	};
	e_RABs_ToBeModified_t& set_e_RABs_ToBeModified() { e_RABs_ToBeModified.setpresent(true); return e_RABs_ToBeModified;}
	e_RABs_ToBeModified_t const* get_e_RABs_ToBeModified() const {return e_RABs_ToBeModified.is_valid() ? &e_RABs_ToBeModified : nullptr;}
	struct e_RABs_ToBeReleased_t : E_RABs_ToBeReleased_SgNBModReq_List
	{
		static constexpr const char* name() {return "e_RABs_ToBeReleased_t";}
		using parent_t = E_RABs_ToBeReleased_SgNBModReq_List;
		static constexpr bool optional = true;

	};
	e_RABs_ToBeReleased_t& set_e_RABs_ToBeReleased() { e_RABs_ToBeReleased.setpresent(true); return e_RABs_ToBeReleased;}
	e_RABs_ToBeReleased_t const* get_e_RABs_ToBeReleased() const {return e_RABs_ToBeReleased.is_valid() ? &e_RABs_ToBeReleased : nullptr;}
	struct iE_Extensions_t : ProtocolExtensionContainer<UE_ContextInformationSgNBModReqExtIEs>
	{
		static constexpr const char* name() {return "iE_Extensions_t";}
		using parent_t = ProtocolExtensionContainer<UE_ContextInformationSgNBModReqExtIEs>;
		static constexpr bool optional = true;

	};
	iE_Extensions_t& set_iE_Extensions() { iE_Extensions.setpresent(true); return iE_Extensions;}
	iE_Extensions_t const* get_iE_Extensions() const {return iE_Extensions.is_valid() ? &iE_Extensions : nullptr;}
	template<typename V> void decode(V& v)
	{
		v(nRUE_SecurityCapabilities);
		v(sgNB_SecurityKey);
		v(sgNBUEAggregateMaximumBitRate);
		v(e_RABs_ToBeAdded);
		v(e_RABs_ToBeModified);
		v(e_RABs_ToBeReleased);
		v(iE_Extensions);

	};
	template<typename V> void encode(V& v) const
	{
		v(nRUE_SecurityCapabilities);
		v(sgNB_SecurityKey);
		v(sgNBUEAggregateMaximumBitRate);
		v(e_RABs_ToBeAdded);
		v(e_RABs_ToBeModified);
		v(e_RABs_ToBeReleased);
		v(iE_Extensions);

	};
	void clear()
	{
		nRUE_SecurityCapabilities.clear();
		sgNB_SecurityKey.clear();
		sgNBUEAggregateMaximumBitRate.clear();
		e_RABs_ToBeAdded.clear();
		e_RABs_ToBeModified.clear();
		e_RABs_ToBeReleased.clear();
		iE_Extensions.clear();

	};
	private:
	nRUE_SecurityCapabilities_t	nRUE_SecurityCapabilities;
	sgNB_SecurityKey_t	sgNB_SecurityKey;
	sgNBUEAggregateMaximumBitRate_t	sgNBUEAggregateMaximumBitRate;
	e_RABs_ToBeAdded_t	e_RABs_ToBeAdded;
	e_RABs_ToBeModified_t	e_RABs_ToBeModified;
	e_RABs_ToBeReleased_t	e_RABs_ToBeReleased;
	iE_Extensions_t	iE_Extensions;

};
/*
SgNBModificationRequest-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-MeNB-UE-X2AP-ID						CRITICALITY reject	TYPE UE-X2AP-ID									PRESENCE mandatory}|
	{ ID id-SgNB-UE-X2AP-ID						CRITICALITY reject	TYPE SgNB-UE-X2AP-ID							PRESENCE mandatory}|
	{ ID id-Cause								CRITICALITY ignore	TYPE Cause										PRESENCE mandatory}|
	{ ID id-SelectedPLMN						CRITICALITY ignore	TYPE PLMN-Identity								PRESENCE optional}|
	{ ID id-HandoverRestrictionList				CRITICALITY ignore	TYPE HandoverRestrictionList					PRESENCE optional}|
	{ ID	id-SCGConfigurationQuery			CRITICALITY ignore	TYPE SCGConfigurationQuery						PRESENCE optional}|
	{ ID id-UE-ContextInformation-SgNBModReq	CRITICALITY reject	TYPE UE-ContextInformation-SgNBModReq		PRESENCE optional}|
	{ ID id-MeNBtoSgNBContainer					CRITICALITY reject	TYPE MeNBtoSgNBContainer						PRESENCE optional}|
	{ ID id-MeNB-UE-X2AP-ID-Extension			CRITICALITY reject	TYPE UE-X2AP-ID-Extension						PRESENCE optional}|
	{ ID id-MeNBResourceCoordinationInformation	CRITICALITY ignore	TYPE MeNBResourceCoordinationInformation	PRESENCE optional}|
	{ ID id-RequestedSplitSRBs					CRITICALITY ignore	TYPE SplitSRBs									PRESENCE optional}|
	{ ID id-RequestedSplitSRBsrelease			CRITICALITY ignore	TYPE SplitSRBs									PRESENCE optional},
	...
}
*/

struct SgNBModificationRequest_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 13; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(id_MeNB_UE_X2AP_ID); type=1;}
		void select_id_SgNB_UE_X2AP_ID() { set(id_SgNB_UE_X2AP_ID); type=2;}
		void select_id_Cause() { set(id_Cause); type=3;}
		void select_id_SelectedPLMN() { set(id_SelectedPLMN); type=4;}
		void select_id_HandoverRestrictionList() { set(id_HandoverRestrictionList); type=5;}
		void select_id_SCGConfigurationQuery() { set(id_SCGConfigurationQuery); type=6;}
		void select_id_UE_ContextInformation_SgNBModReq() { set(id_UE_ContextInformation_SgNBModReq); type=7;}
		void select_id_MeNBtoSgNBContainer() { set(id_MeNBtoSgNBContainer); type=8;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(id_MeNB_UE_X2AP_ID_Extension); type=9;}
		void select_id_MeNBResourceCoordinationInformation() { set(id_MeNBResourceCoordinationInformation); type=10;}
		void select_id_RequestedSplitSRBs() { set(id_RequestedSplitSRBs); type=11;}
		void select_id_RequestedSplitSRBsrelease() { set(id_RequestedSplitSRBsrelease); type=12;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_MeNB_UE_X2AP_ID)) { type = 1; return true; }
			else if(equal(id_SgNB_UE_X2AP_ID)) { type = 2; return true; }
			else if(equal(id_Cause)) { type = 3; return true; }
			else if(equal(id_SelectedPLMN)) { type = 4; return true; }
			else if(equal(id_HandoverRestrictionList)) { type = 5; return true; }
			else if(equal(id_SCGConfigurationQuery)) { type = 6; return true; }
			else if(equal(id_UE_ContextInformation_SgNBModReq)) { type = 7; return true; }
			else if(equal(id_MeNBtoSgNBContainer)) { type = 8; return true; }
			else if(equal(id_MeNB_UE_X2AP_ID_Extension)) { type = 9; return true; }
			else if(equal(id_MeNBResourceCoordinationInformation)) { type = 10; return true; }
			else if(equal(id_RequestedSplitSRBs)) { type = 11; return true; }
			else if(equal(id_RequestedSplitSRBsrelease)) { type = 12; return true; }
			else { type = 13; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_SgNB_UE_X2AP_ID);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_Cause);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(id_SelectedPLMN);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(id_HandoverRestrictionList);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(id_SCGConfigurationQuery);} return false;
			case 7: type = 7; if(v(ref_nested())) { return equal(id_UE_ContextInformation_SgNBModReq);} return false;
			case 8: type = 8; if(v(ref_nested())) { return equal(id_MeNBtoSgNBContainer);} return false;
			case 9: type = 9; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID_Extension);} return false;
			case 10: type = 10; if(v(ref_nested())) { return equal(id_MeNBResourceCoordinationInformation);} return false;
			case 11: type = 11; if(v(ref_nested())) { return equal(id_RequestedSplitSRBs);} return false;
			case 12: type = 12; if(v(ref_nested())) { return equal(id_RequestedSplitSRBsrelease);} return false;
			case 13: type = 13; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 13; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(reject); type=1;}
		void select_id_SgNB_UE_X2AP_ID() { set(reject); type=2;}
		void select_id_Cause() { set(ignore); type=3;}
		void select_id_SelectedPLMN() { set(ignore); type=4;}
		void select_id_HandoverRestrictionList() { set(ignore); type=5;}
		void select_id_SCGConfigurationQuery() { set(ignore); type=6;}
		void select_id_UE_ContextInformation_SgNBModReq() { set(reject); type=7;}
		void select_id_MeNBtoSgNBContainer() { set(reject); type=8;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(reject); type=9;}
		void select_id_MeNBResourceCoordinationInformation() { set(ignore); type=10;}
		void select_id_RequestedSplitSRBs() { set(ignore); type=11;}
		void select_id_RequestedSplitSRBsrelease() { set(ignore); type=12;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else if(equal(reject)) { type = 2; return true; }
			else if(equal(ignore)) { type = 3; return true; }
			else if(equal(ignore)) { type = 4; return true; }
			else if(equal(ignore)) { type = 5; return true; }
			else if(equal(ignore)) { type = 6; return true; }
			else if(equal(reject)) { type = 7; return true; }
			else if(equal(reject)) { type = 8; return true; }
			else if(equal(reject)) { type = 9; return true; }
			else if(equal(ignore)) { type = 10; return true; }
			else if(equal(ignore)) { type = 11; return true; }
			else if(equal(ignore)) { type = 12; return true; }
			else { type = 13; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(reject);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(ignore);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(ignore);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(ignore);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(ignore);} return false;
			case 7: type = 7; if(v(ref_nested())) { return equal(reject);} return false;
			case 8: type = 8; if(v(ref_nested())) { return equal(reject);} return false;
			case 9: type = 9; if(v(ref_nested())) { return equal(reject);} return false;
			case 10: type = 10; if(v(ref_nested())) { return equal(ignore);} return false;
			case 11: type = 11; if(v(ref_nested())) { return equal(ignore);} return false;
			case 12: type = 12; if(v(ref_nested())) { return equal(ignore);} return false;
			case 13: type = 13; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		UE_X2AP_ID& select_id_MeNB_UE_X2AP_ID() { return set<UE_X2AP_ID>(1); }
		UE_X2AP_ID const* get_id_MeNB_UE_X2AP_ID() const { return get<UE_X2AP_ID>(1); }
		SgNB_UE_X2AP_ID& select_id_SgNB_UE_X2AP_ID() { return set<SgNB_UE_X2AP_ID>(2); }
		SgNB_UE_X2AP_ID const* get_id_SgNB_UE_X2AP_ID() const { return get<SgNB_UE_X2AP_ID>(2); }
		Cause& select_id_Cause() { return set<Cause>(3); }
		Cause const* get_id_Cause() const { return get<Cause>(3); }
		PLMN_Identity& select_id_SelectedPLMN() { return set<PLMN_Identity>(4); }
		PLMN_Identity const* get_id_SelectedPLMN() const { return get<PLMN_Identity>(4); }
		HandoverRestrictionList& select_id_HandoverRestrictionList() { return set<HandoverRestrictionList>(5); }
		HandoverRestrictionList const* get_id_HandoverRestrictionList() const { return get<HandoverRestrictionList>(5); }
		SCGConfigurationQuery& select_id_SCGConfigurationQuery() { return set<SCGConfigurationQuery>(6); }
		SCGConfigurationQuery const* get_id_SCGConfigurationQuery() const { return get<SCGConfigurationQuery>(6); }
		UE_ContextInformation_SgNBModReq& select_id_UE_ContextInformation_SgNBModReq() { return set<UE_ContextInformation_SgNBModReq>(7); }
		UE_ContextInformation_SgNBModReq const* get_id_UE_ContextInformation_SgNBModReq() const { return get<UE_ContextInformation_SgNBModReq>(7); }
		MeNBtoSgNBContainer& select_id_MeNBtoSgNBContainer() { return set<MeNBtoSgNBContainer>(8); }
		MeNBtoSgNBContainer const* get_id_MeNBtoSgNBContainer() const { return get<MeNBtoSgNBContainer>(8); }
		UE_X2AP_ID_Extension& select_id_MeNB_UE_X2AP_ID_Extension() { return set<UE_X2AP_ID_Extension>(9); }
		UE_X2AP_ID_Extension const* get_id_MeNB_UE_X2AP_ID_Extension() const { return get<UE_X2AP_ID_Extension>(9); }
		MeNBResourceCoordinationInformation& select_id_MeNBResourceCoordinationInformation() { return set<MeNBResourceCoordinationInformation>(10); }
		MeNBResourceCoordinationInformation const* get_id_MeNBResourceCoordinationInformation() const { return get<MeNBResourceCoordinationInformation>(10); }
		SplitSRBs& select_id_RequestedSplitSRBs() { return set<SplitSRBs>(11); }
		SplitSRBs const* get_id_RequestedSplitSRBs() const { return get<SplitSRBs>(11); }
		SplitSRBs& select_id_RequestedSplitSRBsrelease() { return set<SplitSRBs>(12); }
		SplitSRBs const* get_id_RequestedSplitSRBsrelease() const { return get<SplitSRBs>(12); }
		bool is_unknown() const { return type == 13; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<UE_X2AP_ID>(); break;
			case 2: var.destroy<SgNB_UE_X2AP_ID>(); break;
			case 3: var.destroy<Cause>(); break;
			case 4: var.destroy<PLMN_Identity>(); break;
			case 5: var.destroy<HandoverRestrictionList>(); break;
			case 6: var.destroy<SCGConfigurationQuery>(); break;
			case 7: var.destroy<UE_ContextInformation_SgNBModReq>(); break;
			case 8: var.destroy<MeNBtoSgNBContainer>(); break;
			case 9: var.destroy<UE_X2AP_ID_Extension>(); break;
			case 10: var.destroy<MeNBResourceCoordinationInformation>(); break;
			case 11: var.destroy<SplitSRBs>(); break;
			case 12: var.destroy<SplitSRBs>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<UE_X2AP_ID>(1);
			v.template operator()<SgNB_UE_X2AP_ID>(2);
			v.template operator()<Cause>(3);
			v.template operator()<PLMN_Identity>(4);
			v.template operator()<HandoverRestrictionList>(5);
			v.template operator()<SCGConfigurationQuery>(6);
			v.template operator()<UE_ContextInformation_SgNBModReq>(7);
			v.template operator()<MeNBtoSgNBContainer>(8);
			v.template operator()<UE_X2AP_ID_Extension>(9);
			v.template operator()<MeNBResourceCoordinationInformation>(10);
			v.template operator()<SplitSRBs>(11);
			v.template operator()<SplitSRBs>(12);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_MeNB_UE_X2AP_ID()); return true;
			case 2: v(select_id_SgNB_UE_X2AP_ID()); return true;
			case 3: v(select_id_Cause()); return true;
			case 4: v(select_id_SelectedPLMN()); return true;
			case 5: v(select_id_HandoverRestrictionList()); return true;
			case 6: v(select_id_SCGConfigurationQuery()); return true;
			case 7: v(select_id_UE_ContextInformation_SgNBModReq()); return true;
			case 8: v(select_id_MeNBtoSgNBContainer()); return true;
			case 9: v(select_id_MeNB_UE_X2AP_ID_Extension()); return true;
			case 10: v(select_id_MeNBResourceCoordinationInformation()); return true;
			case 11: v(select_id_RequestedSplitSRBs()); return true;
			case 12: v(select_id_RequestedSplitSRBsrelease()); return true;
			case 13: if(type != 13) {clear(); asn::base::set();} type = 13; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<UE_X2AP_ID>()); return true;
			case 2: v(var.as<SgNB_UE_X2AP_ID>()); return true;
			case 3: v(var.as<Cause>()); return true;
			case 4: v(var.as<PLMN_Identity>()); return true;
			case 5: v(var.as<HandoverRestrictionList>()); return true;
			case 6: v(var.as<SCGConfigurationQuery>()); return true;
			case 7: v(var.as<UE_ContextInformation_SgNBModReq>()); return true;
			case 8: v(var.as<MeNBtoSgNBContainer>()); return true;
			case 9: v(var.as<UE_X2AP_ID_Extension>()); return true;
			case 10: v(var.as<MeNBResourceCoordinationInformation>()); return true;
			case 11: v(var.as<SplitSRBs>()); return true;
			case 12: v(var.as<SplitSRBs>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(Cause)];
			char dummy2[sizeof(HandoverRestrictionList)];
			char dummy3[sizeof(MeNBResourceCoordinationInformation)];
			char dummy4[sizeof(MeNBtoSgNBContainer)];
			char dummy5[sizeof(PLMN_Identity)];
			char dummy6[sizeof(SCGConfigurationQuery)];
			char dummy7[sizeof(SgNB_UE_X2AP_ID)];
			char dummy8[sizeof(SplitSRBs)];
			char dummy9[sizeof(UE_ContextInformation_SgNBModReq)];
			char dummy10[sizeof(UE_X2AP_ID)];
			char dummy11[sizeof(UE_X2AP_ID_Extension)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 13; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(mandatory); type=1;}
		void select_id_SgNB_UE_X2AP_ID() { set(mandatory); type=2;}
		void select_id_Cause() { set(mandatory); type=3;}
		void select_id_SelectedPLMN() { set(optional); type=4;}
		void select_id_HandoverRestrictionList() { set(optional); type=5;}
		void select_id_SCGConfigurationQuery() { set(optional); type=6;}
		void select_id_UE_ContextInformation_SgNBModReq() { set(optional); type=7;}
		void select_id_MeNBtoSgNBContainer() { set(optional); type=8;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(optional); type=9;}
		void select_id_MeNBResourceCoordinationInformation() { set(optional); type=10;}
		void select_id_RequestedSplitSRBs() { set(optional); type=11;}
		void select_id_RequestedSplitSRBsrelease() { set(optional); type=12;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(mandatory)) { type = 2; return true; }
			else if(equal(mandatory)) { type = 3; return true; }
			else if(equal(optional)) { type = 4; return true; }
			else if(equal(optional)) { type = 5; return true; }
			else if(equal(optional)) { type = 6; return true; }
			else if(equal(optional)) { type = 7; return true; }
			else if(equal(optional)) { type = 8; return true; }
			else if(equal(optional)) { type = 9; return true; }
			else if(equal(optional)) { type = 10; return true; }
			else if(equal(optional)) { type = 11; return true; }
			else if(equal(optional)) { type = 12; return true; }
			else { type = 13; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(optional);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(optional);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(optional);} return false;
			case 7: type = 7; if(v(ref_nested())) { return equal(optional);} return false;
			case 8: type = 8; if(v(ref_nested())) { return equal(optional);} return false;
			case 9: type = 9; if(v(ref_nested())) { return equal(optional);} return false;
			case 10: type = 10; if(v(ref_nested())) { return equal(optional);} return false;
			case 11: type = 11; if(v(ref_nested())) { return equal(optional);} return false;
			case 12: type = 12; if(v(ref_nested())) { return equal(optional);} return false;
			case 13: type = 13; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
SgNBModificationRequest ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{ SgNBModificationRequest-IEs}},
	...
}
*/

struct SgNBModificationRequest : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "SgNBModificationRequest";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<SgNBModificationRequest_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<SgNBModificationRequest_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
SgNBModificationRequestAcknowledge-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-MeNB-UE-X2AP-ID								CRITICALITY ignore	TYPE UE-X2AP-ID													PRESENCE mandatory}|
	{ ID id-SgNB-UE-X2AP-ID								CRITICALITY ignore	TYPE SgNB-UE-X2AP-ID												PRESENCE mandatory}|
	{ ID id-E-RABs-Admitted-ToBeAdded-SgNBModAckList		CRITICALITY ignore	TYPE E-RABs-Admitted-ToBeAdded-SgNBModAckList			PRESENCE optional}|
	{ ID id-E-RABs-Admitted-ToBeModified-SgNBModAckList	CRITICALITY ignore	TYPE E-RABs-Admitted-ToBeModified-SgNBModAckList		PRESENCE optional}|
	{ ID id-E-RABs-Admitted-ToBeReleased-SgNBModAckList	CRITICALITY ignore	TYPE E-RABs-Admitted-ToBeReleased-SgNBModAckList		PRESENCE optional}|
	{ ID id-E-RABs-NotAdmitted-List						CRITICALITY ignore	TYPE E-RAB-List													PRESENCE optional}|
	{ ID id-SgNBtoMeNBContainer							CRITICALITY ignore	TYPE SgNBtoMeNBContainer										PRESENCE optional}|
	{ ID id-CriticalityDiagnostics						CRITICALITY ignore	TYPE CriticalityDiagnostics									PRESENCE optional}|
	{ ID id-MeNB-UE-X2AP-ID-Extension					CRITICALITY ignore	TYPE UE-X2AP-ID-Extension									PRESENCE optional}|
	{ ID id-SgNBResourceCoordinationInformation			CRITICALITY ignore	TYPE SgNBResourceCoordinationInformation				PRESENCE optional}|
	{ ID id-AdmittedSplitSRBs							CRITICALITY ignore	TYPE SplitSRBs													PRESENCE optional}|
	{ ID id-AdmittedSplitSRBsrelease						CRITICALITY ignore	TYPE SplitSRBs													PRESENCE optional}|
	{ ID id-RRCConfigIndication							CRITICALITY reject	TYPE RRC-Config-Ind			PRESENCE optional},
	...
}
*/

struct SgNBModificationRequestAcknowledge_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 14; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(id_MeNB_UE_X2AP_ID); type=1;}
		void select_id_SgNB_UE_X2AP_ID() { set(id_SgNB_UE_X2AP_ID); type=2;}
		void select_id_E_RABs_Admitted_ToBeAdded_SgNBModAckList() { set(id_E_RABs_Admitted_ToBeAdded_SgNBModAckList); type=3;}
		void select_id_E_RABs_Admitted_ToBeModified_SgNBModAckList() { set(id_E_RABs_Admitted_ToBeModified_SgNBModAckList); type=4;}
		void select_id_E_RABs_Admitted_ToBeReleased_SgNBModAckList() { set(id_E_RABs_Admitted_ToBeReleased_SgNBModAckList); type=5;}
		void select_id_E_RABs_NotAdmitted_List() { set(id_E_RABs_NotAdmitted_List); type=6;}
		void select_id_SgNBtoMeNBContainer() { set(id_SgNBtoMeNBContainer); type=7;}
		void select_id_CriticalityDiagnostics() { set(id_CriticalityDiagnostics); type=8;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(id_MeNB_UE_X2AP_ID_Extension); type=9;}
		void select_id_SgNBResourceCoordinationInformation() { set(id_SgNBResourceCoordinationInformation); type=10;}
		void select_id_AdmittedSplitSRBs() { set(id_AdmittedSplitSRBs); type=11;}
		void select_id_AdmittedSplitSRBsrelease() { set(id_AdmittedSplitSRBsrelease); type=12;}
		void select_id_RRCConfigIndication() { set(id_RRCConfigIndication); type=13;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_MeNB_UE_X2AP_ID)) { type = 1; return true; }
			else if(equal(id_SgNB_UE_X2AP_ID)) { type = 2; return true; }
			else if(equal(id_E_RABs_Admitted_ToBeAdded_SgNBModAckList)) { type = 3; return true; }
			else if(equal(id_E_RABs_Admitted_ToBeModified_SgNBModAckList)) { type = 4; return true; }
			else if(equal(id_E_RABs_Admitted_ToBeReleased_SgNBModAckList)) { type = 5; return true; }
			else if(equal(id_E_RABs_NotAdmitted_List)) { type = 6; return true; }
			else if(equal(id_SgNBtoMeNBContainer)) { type = 7; return true; }
			else if(equal(id_CriticalityDiagnostics)) { type = 8; return true; }
			else if(equal(id_MeNB_UE_X2AP_ID_Extension)) { type = 9; return true; }
			else if(equal(id_SgNBResourceCoordinationInformation)) { type = 10; return true; }
			else if(equal(id_AdmittedSplitSRBs)) { type = 11; return true; }
			else if(equal(id_AdmittedSplitSRBsrelease)) { type = 12; return true; }
			else if(equal(id_RRCConfigIndication)) { type = 13; return true; }
			else { type = 14; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_SgNB_UE_X2AP_ID);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_E_RABs_Admitted_ToBeAdded_SgNBModAckList);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(id_E_RABs_Admitted_ToBeModified_SgNBModAckList);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(id_E_RABs_Admitted_ToBeReleased_SgNBModAckList);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(id_E_RABs_NotAdmitted_List);} return false;
			case 7: type = 7; if(v(ref_nested())) { return equal(id_SgNBtoMeNBContainer);} return false;
			case 8: type = 8; if(v(ref_nested())) { return equal(id_CriticalityDiagnostics);} return false;
			case 9: type = 9; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID_Extension);} return false;
			case 10: type = 10; if(v(ref_nested())) { return equal(id_SgNBResourceCoordinationInformation);} return false;
			case 11: type = 11; if(v(ref_nested())) { return equal(id_AdmittedSplitSRBs);} return false;
			case 12: type = 12; if(v(ref_nested())) { return equal(id_AdmittedSplitSRBsrelease);} return false;
			case 13: type = 13; if(v(ref_nested())) { return equal(id_RRCConfigIndication);} return false;
			case 14: type = 14; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 14; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(ignore); type=1;}
		void select_id_SgNB_UE_X2AP_ID() { set(ignore); type=2;}
		void select_id_E_RABs_Admitted_ToBeAdded_SgNBModAckList() { set(ignore); type=3;}
		void select_id_E_RABs_Admitted_ToBeModified_SgNBModAckList() { set(ignore); type=4;}
		void select_id_E_RABs_Admitted_ToBeReleased_SgNBModAckList() { set(ignore); type=5;}
		void select_id_E_RABs_NotAdmitted_List() { set(ignore); type=6;}
		void select_id_SgNBtoMeNBContainer() { set(ignore); type=7;}
		void select_id_CriticalityDiagnostics() { set(ignore); type=8;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(ignore); type=9;}
		void select_id_SgNBResourceCoordinationInformation() { set(ignore); type=10;}
		void select_id_AdmittedSplitSRBs() { set(ignore); type=11;}
		void select_id_AdmittedSplitSRBsrelease() { set(ignore); type=12;}
		void select_id_RRCConfigIndication() { set(reject); type=13;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else if(equal(ignore)) { type = 2; return true; }
			else if(equal(ignore)) { type = 3; return true; }
			else if(equal(ignore)) { type = 4; return true; }
			else if(equal(ignore)) { type = 5; return true; }
			else if(equal(ignore)) { type = 6; return true; }
			else if(equal(ignore)) { type = 7; return true; }
			else if(equal(ignore)) { type = 8; return true; }
			else if(equal(ignore)) { type = 9; return true; }
			else if(equal(ignore)) { type = 10; return true; }
			else if(equal(ignore)) { type = 11; return true; }
			else if(equal(ignore)) { type = 12; return true; }
			else if(equal(reject)) { type = 13; return true; }
			else { type = 14; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(ignore);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(ignore);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(ignore);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(ignore);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(ignore);} return false;
			case 7: type = 7; if(v(ref_nested())) { return equal(ignore);} return false;
			case 8: type = 8; if(v(ref_nested())) { return equal(ignore);} return false;
			case 9: type = 9; if(v(ref_nested())) { return equal(ignore);} return false;
			case 10: type = 10; if(v(ref_nested())) { return equal(ignore);} return false;
			case 11: type = 11; if(v(ref_nested())) { return equal(ignore);} return false;
			case 12: type = 12; if(v(ref_nested())) { return equal(ignore);} return false;
			case 13: type = 13; if(v(ref_nested())) { return equal(reject);} return false;
			case 14: type = 14; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		UE_X2AP_ID& select_id_MeNB_UE_X2AP_ID() { return set<UE_X2AP_ID>(1); }
		UE_X2AP_ID const* get_id_MeNB_UE_X2AP_ID() const { return get<UE_X2AP_ID>(1); }
		SgNB_UE_X2AP_ID& select_id_SgNB_UE_X2AP_ID() { return set<SgNB_UE_X2AP_ID>(2); }
		SgNB_UE_X2AP_ID const* get_id_SgNB_UE_X2AP_ID() const { return get<SgNB_UE_X2AP_ID>(2); }
		E_RABs_Admitted_ToBeAdded_SgNBModAckList& select_id_E_RABs_Admitted_ToBeAdded_SgNBModAckList() { return set<E_RABs_Admitted_ToBeAdded_SgNBModAckList>(3); }
		E_RABs_Admitted_ToBeAdded_SgNBModAckList const* get_id_E_RABs_Admitted_ToBeAdded_SgNBModAckList() const { return get<E_RABs_Admitted_ToBeAdded_SgNBModAckList>(3); }
		E_RABs_Admitted_ToBeModified_SgNBModAckList& select_id_E_RABs_Admitted_ToBeModified_SgNBModAckList() { return set<E_RABs_Admitted_ToBeModified_SgNBModAckList>(4); }
		E_RABs_Admitted_ToBeModified_SgNBModAckList const* get_id_E_RABs_Admitted_ToBeModified_SgNBModAckList() const { return get<E_RABs_Admitted_ToBeModified_SgNBModAckList>(4); }
		E_RABs_Admitted_ToBeReleased_SgNBModAckList& select_id_E_RABs_Admitted_ToBeReleased_SgNBModAckList() { return set<E_RABs_Admitted_ToBeReleased_SgNBModAckList>(5); }
		E_RABs_Admitted_ToBeReleased_SgNBModAckList const* get_id_E_RABs_Admitted_ToBeReleased_SgNBModAckList() const { return get<E_RABs_Admitted_ToBeReleased_SgNBModAckList>(5); }
		E_RAB_List& select_id_E_RABs_NotAdmitted_List() { return set<E_RAB_List>(6); }
		E_RAB_List const* get_id_E_RABs_NotAdmitted_List() const { return get<E_RAB_List>(6); }
		SgNBtoMeNBContainer& select_id_SgNBtoMeNBContainer() { return set<SgNBtoMeNBContainer>(7); }
		SgNBtoMeNBContainer const* get_id_SgNBtoMeNBContainer() const { return get<SgNBtoMeNBContainer>(7); }
		CriticalityDiagnostics& select_id_CriticalityDiagnostics() { return set<CriticalityDiagnostics>(8); }
		CriticalityDiagnostics const* get_id_CriticalityDiagnostics() const { return get<CriticalityDiagnostics>(8); }
		UE_X2AP_ID_Extension& select_id_MeNB_UE_X2AP_ID_Extension() { return set<UE_X2AP_ID_Extension>(9); }
		UE_X2AP_ID_Extension const* get_id_MeNB_UE_X2AP_ID_Extension() const { return get<UE_X2AP_ID_Extension>(9); }
		SgNBResourceCoordinationInformation& select_id_SgNBResourceCoordinationInformation() { return set<SgNBResourceCoordinationInformation>(10); }
		SgNBResourceCoordinationInformation const* get_id_SgNBResourceCoordinationInformation() const { return get<SgNBResourceCoordinationInformation>(10); }
		SplitSRBs& select_id_AdmittedSplitSRBs() { return set<SplitSRBs>(11); }
		SplitSRBs const* get_id_AdmittedSplitSRBs() const { return get<SplitSRBs>(11); }
		SplitSRBs& select_id_AdmittedSplitSRBsrelease() { return set<SplitSRBs>(12); }
		SplitSRBs const* get_id_AdmittedSplitSRBsrelease() const { return get<SplitSRBs>(12); }
		RRC_Config_Ind& select_id_RRCConfigIndication() { return set<RRC_Config_Ind>(13); }
		RRC_Config_Ind const* get_id_RRCConfigIndication() const { return get<RRC_Config_Ind>(13); }
		bool is_unknown() const { return type == 14; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<UE_X2AP_ID>(); break;
			case 2: var.destroy<SgNB_UE_X2AP_ID>(); break;
			case 3: var.destroy<E_RABs_Admitted_ToBeAdded_SgNBModAckList>(); break;
			case 4: var.destroy<E_RABs_Admitted_ToBeModified_SgNBModAckList>(); break;
			case 5: var.destroy<E_RABs_Admitted_ToBeReleased_SgNBModAckList>(); break;
			case 6: var.destroy<E_RAB_List>(); break;
			case 7: var.destroy<SgNBtoMeNBContainer>(); break;
			case 8: var.destroy<CriticalityDiagnostics>(); break;
			case 9: var.destroy<UE_X2AP_ID_Extension>(); break;
			case 10: var.destroy<SgNBResourceCoordinationInformation>(); break;
			case 11: var.destroy<SplitSRBs>(); break;
			case 12: var.destroy<SplitSRBs>(); break;
			case 13: var.destroy<RRC_Config_Ind>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<UE_X2AP_ID>(1);
			v.template operator()<SgNB_UE_X2AP_ID>(2);
			v.template operator()<E_RABs_Admitted_ToBeAdded_SgNBModAckList>(3);
			v.template operator()<E_RABs_Admitted_ToBeModified_SgNBModAckList>(4);
			v.template operator()<E_RABs_Admitted_ToBeReleased_SgNBModAckList>(5);
			v.template operator()<E_RAB_List>(6);
			v.template operator()<SgNBtoMeNBContainer>(7);
			v.template operator()<CriticalityDiagnostics>(8);
			v.template operator()<UE_X2AP_ID_Extension>(9);
			v.template operator()<SgNBResourceCoordinationInformation>(10);
			v.template operator()<SplitSRBs>(11);
			v.template operator()<SplitSRBs>(12);
			v.template operator()<RRC_Config_Ind>(13);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_MeNB_UE_X2AP_ID()); return true;
			case 2: v(select_id_SgNB_UE_X2AP_ID()); return true;
			case 3: v(select_id_E_RABs_Admitted_ToBeAdded_SgNBModAckList()); return true;
			case 4: v(select_id_E_RABs_Admitted_ToBeModified_SgNBModAckList()); return true;
			case 5: v(select_id_E_RABs_Admitted_ToBeReleased_SgNBModAckList()); return true;
			case 6: v(select_id_E_RABs_NotAdmitted_List()); return true;
			case 7: v(select_id_SgNBtoMeNBContainer()); return true;
			case 8: v(select_id_CriticalityDiagnostics()); return true;
			case 9: v(select_id_MeNB_UE_X2AP_ID_Extension()); return true;
			case 10: v(select_id_SgNBResourceCoordinationInformation()); return true;
			case 11: v(select_id_AdmittedSplitSRBs()); return true;
			case 12: v(select_id_AdmittedSplitSRBsrelease()); return true;
			case 13: v(select_id_RRCConfigIndication()); return true;
			case 14: if(type != 14) {clear(); asn::base::set();} type = 14; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<UE_X2AP_ID>()); return true;
			case 2: v(var.as<SgNB_UE_X2AP_ID>()); return true;
			case 3: v(var.as<E_RABs_Admitted_ToBeAdded_SgNBModAckList>()); return true;
			case 4: v(var.as<E_RABs_Admitted_ToBeModified_SgNBModAckList>()); return true;
			case 5: v(var.as<E_RABs_Admitted_ToBeReleased_SgNBModAckList>()); return true;
			case 6: v(var.as<E_RAB_List>()); return true;
			case 7: v(var.as<SgNBtoMeNBContainer>()); return true;
			case 8: v(var.as<CriticalityDiagnostics>()); return true;
			case 9: v(var.as<UE_X2AP_ID_Extension>()); return true;
			case 10: v(var.as<SgNBResourceCoordinationInformation>()); return true;
			case 11: v(var.as<SplitSRBs>()); return true;
			case 12: v(var.as<SplitSRBs>()); return true;
			case 13: v(var.as<RRC_Config_Ind>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(CriticalityDiagnostics)];
			char dummy2[sizeof(E_RAB_List)];
			char dummy3[sizeof(E_RABs_Admitted_ToBeAdded_SgNBModAckList)];
			char dummy4[sizeof(E_RABs_Admitted_ToBeModified_SgNBModAckList)];
			char dummy5[sizeof(E_RABs_Admitted_ToBeReleased_SgNBModAckList)];
			char dummy6[sizeof(RRC_Config_Ind)];
			char dummy7[sizeof(SgNBResourceCoordinationInformation)];
			char dummy8[sizeof(SgNB_UE_X2AP_ID)];
			char dummy9[sizeof(SgNBtoMeNBContainer)];
			char dummy10[sizeof(SplitSRBs)];
			char dummy11[sizeof(UE_X2AP_ID)];
			char dummy12[sizeof(UE_X2AP_ID_Extension)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 14; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(mandatory); type=1;}
		void select_id_SgNB_UE_X2AP_ID() { set(mandatory); type=2;}
		void select_id_E_RABs_Admitted_ToBeAdded_SgNBModAckList() { set(optional); type=3;}
		void select_id_E_RABs_Admitted_ToBeModified_SgNBModAckList() { set(optional); type=4;}
		void select_id_E_RABs_Admitted_ToBeReleased_SgNBModAckList() { set(optional); type=5;}
		void select_id_E_RABs_NotAdmitted_List() { set(optional); type=6;}
		void select_id_SgNBtoMeNBContainer() { set(optional); type=7;}
		void select_id_CriticalityDiagnostics() { set(optional); type=8;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(optional); type=9;}
		void select_id_SgNBResourceCoordinationInformation() { set(optional); type=10;}
		void select_id_AdmittedSplitSRBs() { set(optional); type=11;}
		void select_id_AdmittedSplitSRBsrelease() { set(optional); type=12;}
		void select_id_RRCConfigIndication() { set(optional); type=13;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(mandatory)) { type = 2; return true; }
			else if(equal(optional)) { type = 3; return true; }
			else if(equal(optional)) { type = 4; return true; }
			else if(equal(optional)) { type = 5; return true; }
			else if(equal(optional)) { type = 6; return true; }
			else if(equal(optional)) { type = 7; return true; }
			else if(equal(optional)) { type = 8; return true; }
			else if(equal(optional)) { type = 9; return true; }
			else if(equal(optional)) { type = 10; return true; }
			else if(equal(optional)) { type = 11; return true; }
			else if(equal(optional)) { type = 12; return true; }
			else if(equal(optional)) { type = 13; return true; }
			else { type = 14; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(optional);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(optional);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(optional);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(optional);} return false;
			case 7: type = 7; if(v(ref_nested())) { return equal(optional);} return false;
			case 8: type = 8; if(v(ref_nested())) { return equal(optional);} return false;
			case 9: type = 9; if(v(ref_nested())) { return equal(optional);} return false;
			case 10: type = 10; if(v(ref_nested())) { return equal(optional);} return false;
			case 11: type = 11; if(v(ref_nested())) { return equal(optional);} return false;
			case 12: type = 12; if(v(ref_nested())) { return equal(optional);} return false;
			case 13: type = 13; if(v(ref_nested())) { return equal(optional);} return false;
			case 14: type = 14; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
SgNBModificationRequestAcknowledge ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{SgNBModificationRequestAcknowledge-IEs}},
	...
}
*/

struct SgNBModificationRequestAcknowledge : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "SgNBModificationRequestAcknowledge";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<SgNBModificationRequestAcknowledge_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<SgNBModificationRequestAcknowledge_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
SgNBModificationRequestReject-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-MeNB-UE-X2AP-ID						CRITICALITY ignore	TYPE UE-X2AP-ID					PRESENCE mandatory}|
	{ ID id-SgNB-UE-X2AP-ID						CRITICALITY ignore	TYPE SgNB-UE-X2AP-ID				PRESENCE mandatory}|
	{ ID id-Cause								CRITICALITY ignore	TYPE Cause						PRESENCE mandatory}|
	{ ID id-CriticalityDiagnostics				CRITICALITY ignore	TYPE CriticalityDiagnostics		PRESENCE optional}|
	{ ID id-MeNB-UE-X2AP-ID-Extension			CRITICALITY ignore	TYPE UE-X2AP-ID-Extension		PRESENCE optional},
	...
}
*/

struct SgNBModificationRequestReject_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 6; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(id_MeNB_UE_X2AP_ID); type=1;}
		void select_id_SgNB_UE_X2AP_ID() { set(id_SgNB_UE_X2AP_ID); type=2;}
		void select_id_Cause() { set(id_Cause); type=3;}
		void select_id_CriticalityDiagnostics() { set(id_CriticalityDiagnostics); type=4;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(id_MeNB_UE_X2AP_ID_Extension); type=5;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_MeNB_UE_X2AP_ID)) { type = 1; return true; }
			else if(equal(id_SgNB_UE_X2AP_ID)) { type = 2; return true; }
			else if(equal(id_Cause)) { type = 3; return true; }
			else if(equal(id_CriticalityDiagnostics)) { type = 4; return true; }
			else if(equal(id_MeNB_UE_X2AP_ID_Extension)) { type = 5; return true; }
			else { type = 6; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_SgNB_UE_X2AP_ID);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_Cause);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(id_CriticalityDiagnostics);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID_Extension);} return false;
			case 6: type = 6; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 6; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(ignore); type=1;}
		void select_id_SgNB_UE_X2AP_ID() { set(ignore); type=2;}
		void select_id_Cause() { set(ignore); type=3;}
		void select_id_CriticalityDiagnostics() { set(ignore); type=4;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(ignore); type=5;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else if(equal(ignore)) { type = 2; return true; }
			else if(equal(ignore)) { type = 3; return true; }
			else if(equal(ignore)) { type = 4; return true; }
			else if(equal(ignore)) { type = 5; return true; }
			else { type = 6; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(ignore);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(ignore);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(ignore);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(ignore);} return false;
			case 6: type = 6; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		UE_X2AP_ID& select_id_MeNB_UE_X2AP_ID() { return set<UE_X2AP_ID>(1); }
		UE_X2AP_ID const* get_id_MeNB_UE_X2AP_ID() const { return get<UE_X2AP_ID>(1); }
		SgNB_UE_X2AP_ID& select_id_SgNB_UE_X2AP_ID() { return set<SgNB_UE_X2AP_ID>(2); }
		SgNB_UE_X2AP_ID const* get_id_SgNB_UE_X2AP_ID() const { return get<SgNB_UE_X2AP_ID>(2); }
		Cause& select_id_Cause() { return set<Cause>(3); }
		Cause const* get_id_Cause() const { return get<Cause>(3); }
		CriticalityDiagnostics& select_id_CriticalityDiagnostics() { return set<CriticalityDiagnostics>(4); }
		CriticalityDiagnostics const* get_id_CriticalityDiagnostics() const { return get<CriticalityDiagnostics>(4); }
		UE_X2AP_ID_Extension& select_id_MeNB_UE_X2AP_ID_Extension() { return set<UE_X2AP_ID_Extension>(5); }
		UE_X2AP_ID_Extension const* get_id_MeNB_UE_X2AP_ID_Extension() const { return get<UE_X2AP_ID_Extension>(5); }
		bool is_unknown() const { return type == 6; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<UE_X2AP_ID>(); break;
			case 2: var.destroy<SgNB_UE_X2AP_ID>(); break;
			case 3: var.destroy<Cause>(); break;
			case 4: var.destroy<CriticalityDiagnostics>(); break;
			case 5: var.destroy<UE_X2AP_ID_Extension>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<UE_X2AP_ID>(1);
			v.template operator()<SgNB_UE_X2AP_ID>(2);
			v.template operator()<Cause>(3);
			v.template operator()<CriticalityDiagnostics>(4);
			v.template operator()<UE_X2AP_ID_Extension>(5);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_MeNB_UE_X2AP_ID()); return true;
			case 2: v(select_id_SgNB_UE_X2AP_ID()); return true;
			case 3: v(select_id_Cause()); return true;
			case 4: v(select_id_CriticalityDiagnostics()); return true;
			case 5: v(select_id_MeNB_UE_X2AP_ID_Extension()); return true;
			case 6: if(type != 6) {clear(); asn::base::set();} type = 6; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<UE_X2AP_ID>()); return true;
			case 2: v(var.as<SgNB_UE_X2AP_ID>()); return true;
			case 3: v(var.as<Cause>()); return true;
			case 4: v(var.as<CriticalityDiagnostics>()); return true;
			case 5: v(var.as<UE_X2AP_ID_Extension>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(Cause)];
			char dummy2[sizeof(CriticalityDiagnostics)];
			char dummy3[sizeof(SgNB_UE_X2AP_ID)];
			char dummy4[sizeof(UE_X2AP_ID)];
			char dummy5[sizeof(UE_X2AP_ID_Extension)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 6; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(mandatory); type=1;}
		void select_id_SgNB_UE_X2AP_ID() { set(mandatory); type=2;}
		void select_id_Cause() { set(mandatory); type=3;}
		void select_id_CriticalityDiagnostics() { set(optional); type=4;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(optional); type=5;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(mandatory)) { type = 2; return true; }
			else if(equal(mandatory)) { type = 3; return true; }
			else if(equal(optional)) { type = 4; return true; }
			else if(equal(optional)) { type = 5; return true; }
			else { type = 6; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(optional);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(optional);} return false;
			case 6: type = 6; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
SgNBModificationRequestReject ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{SgNBModificationRequestReject-IEs}},
	...
}
*/

struct SgNBModificationRequestReject : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "SgNBModificationRequestReject";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<SgNBModificationRequestReject_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<SgNBModificationRequestReject_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
SgNBModificationRequired-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-MeNB-UE-X2AP-ID							CRITICALITY reject	TYPE UE-X2AP-ID										PRESENCE mandatory}|
	{ ID id-SgNB-UE-X2AP-ID							CRITICALITY reject	TYPE SgNB-UE-X2AP-ID								PRESENCE mandatory}|
	{ ID id-Cause									CRITICALITY ignore	TYPE Cause											PRESENCE mandatory}|
	{ ID id-PDCPChangeIndication					CRITICALITY ignore	TYPE PDCPChangeIndication							PRESENCE optional}|
	{ ID id-E-RABs-ToBeReleased-SgNBModReqdList		CRITICALITY ignore	TYPE E-RABs-ToBeReleased-SgNBModReqdList		PRESENCE optional}|
	{ ID id-SgNBtoMeNBContainer						CRITICALITY ignore	TYPE SgNBtoMeNBContainer							PRESENCE optional}|
	{ ID id-MeNB-UE-X2AP-ID-Extension				CRITICALITY reject	TYPE UE-X2AP-ID-Extension							PRESENCE optional}|
	{ ID id-E-RABs-ToBeModified-SgNBModReqdList		CRITICALITY ignore	TYPE E-RABs-ToBeModified-SgNBModReqdList		PRESENCE optional}|
	{ ID id-SgNBResourceCoordinationInformation		CRITICALITY ignore	TYPE SgNBResourceCoordinationInformation		PRESENCE optional}|
	{ ID id-RRCConfigIndication						CRITICALITY reject	TYPE RRC-Config-Ind									PRESENCE optional},
	...
}
*/

struct SgNBModificationRequired_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 11; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(id_MeNB_UE_X2AP_ID); type=1;}
		void select_id_SgNB_UE_X2AP_ID() { set(id_SgNB_UE_X2AP_ID); type=2;}
		void select_id_Cause() { set(id_Cause); type=3;}
		void select_id_PDCPChangeIndication() { set(id_PDCPChangeIndication); type=4;}
		void select_id_E_RABs_ToBeReleased_SgNBModReqdList() { set(id_E_RABs_ToBeReleased_SgNBModReqdList); type=5;}
		void select_id_SgNBtoMeNBContainer() { set(id_SgNBtoMeNBContainer); type=6;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(id_MeNB_UE_X2AP_ID_Extension); type=7;}
		void select_id_E_RABs_ToBeModified_SgNBModReqdList() { set(id_E_RABs_ToBeModified_SgNBModReqdList); type=8;}
		void select_id_SgNBResourceCoordinationInformation() { set(id_SgNBResourceCoordinationInformation); type=9;}
		void select_id_RRCConfigIndication() { set(id_RRCConfigIndication); type=10;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_MeNB_UE_X2AP_ID)) { type = 1; return true; }
			else if(equal(id_SgNB_UE_X2AP_ID)) { type = 2; return true; }
			else if(equal(id_Cause)) { type = 3; return true; }
			else if(equal(id_PDCPChangeIndication)) { type = 4; return true; }
			else if(equal(id_E_RABs_ToBeReleased_SgNBModReqdList)) { type = 5; return true; }
			else if(equal(id_SgNBtoMeNBContainer)) { type = 6; return true; }
			else if(equal(id_MeNB_UE_X2AP_ID_Extension)) { type = 7; return true; }
			else if(equal(id_E_RABs_ToBeModified_SgNBModReqdList)) { type = 8; return true; }
			else if(equal(id_SgNBResourceCoordinationInformation)) { type = 9; return true; }
			else if(equal(id_RRCConfigIndication)) { type = 10; return true; }
			else { type = 11; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_SgNB_UE_X2AP_ID);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_Cause);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(id_PDCPChangeIndication);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(id_E_RABs_ToBeReleased_SgNBModReqdList);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(id_SgNBtoMeNBContainer);} return false;
			case 7: type = 7; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID_Extension);} return false;
			case 8: type = 8; if(v(ref_nested())) { return equal(id_E_RABs_ToBeModified_SgNBModReqdList);} return false;
			case 9: type = 9; if(v(ref_nested())) { return equal(id_SgNBResourceCoordinationInformation);} return false;
			case 10: type = 10; if(v(ref_nested())) { return equal(id_RRCConfigIndication);} return false;
			case 11: type = 11; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 11; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(reject); type=1;}
		void select_id_SgNB_UE_X2AP_ID() { set(reject); type=2;}
		void select_id_Cause() { set(ignore); type=3;}
		void select_id_PDCPChangeIndication() { set(ignore); type=4;}
		void select_id_E_RABs_ToBeReleased_SgNBModReqdList() { set(ignore); type=5;}
		void select_id_SgNBtoMeNBContainer() { set(ignore); type=6;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(reject); type=7;}
		void select_id_E_RABs_ToBeModified_SgNBModReqdList() { set(ignore); type=8;}
		void select_id_SgNBResourceCoordinationInformation() { set(ignore); type=9;}
		void select_id_RRCConfigIndication() { set(reject); type=10;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else if(equal(reject)) { type = 2; return true; }
			else if(equal(ignore)) { type = 3; return true; }
			else if(equal(ignore)) { type = 4; return true; }
			else if(equal(ignore)) { type = 5; return true; }
			else if(equal(ignore)) { type = 6; return true; }
			else if(equal(reject)) { type = 7; return true; }
			else if(equal(ignore)) { type = 8; return true; }
			else if(equal(ignore)) { type = 9; return true; }
			else if(equal(reject)) { type = 10; return true; }
			else { type = 11; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(reject);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(ignore);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(ignore);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(ignore);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(ignore);} return false;
			case 7: type = 7; if(v(ref_nested())) { return equal(reject);} return false;
			case 8: type = 8; if(v(ref_nested())) { return equal(ignore);} return false;
			case 9: type = 9; if(v(ref_nested())) { return equal(ignore);} return false;
			case 10: type = 10; if(v(ref_nested())) { return equal(reject);} return false;
			case 11: type = 11; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		UE_X2AP_ID& select_id_MeNB_UE_X2AP_ID() { return set<UE_X2AP_ID>(1); }
		UE_X2AP_ID const* get_id_MeNB_UE_X2AP_ID() const { return get<UE_X2AP_ID>(1); }
		SgNB_UE_X2AP_ID& select_id_SgNB_UE_X2AP_ID() { return set<SgNB_UE_X2AP_ID>(2); }
		SgNB_UE_X2AP_ID const* get_id_SgNB_UE_X2AP_ID() const { return get<SgNB_UE_X2AP_ID>(2); }
		Cause& select_id_Cause() { return set<Cause>(3); }
		Cause const* get_id_Cause() const { return get<Cause>(3); }
		PDCPChangeIndication& select_id_PDCPChangeIndication() { return set<PDCPChangeIndication>(4); }
		PDCPChangeIndication const* get_id_PDCPChangeIndication() const { return get<PDCPChangeIndication>(4); }
		E_RABs_ToBeReleased_SgNBModReqdList& select_id_E_RABs_ToBeReleased_SgNBModReqdList() { return set<E_RABs_ToBeReleased_SgNBModReqdList>(5); }
		E_RABs_ToBeReleased_SgNBModReqdList const* get_id_E_RABs_ToBeReleased_SgNBModReqdList() const { return get<E_RABs_ToBeReleased_SgNBModReqdList>(5); }
		SgNBtoMeNBContainer& select_id_SgNBtoMeNBContainer() { return set<SgNBtoMeNBContainer>(6); }
		SgNBtoMeNBContainer const* get_id_SgNBtoMeNBContainer() const { return get<SgNBtoMeNBContainer>(6); }
		UE_X2AP_ID_Extension& select_id_MeNB_UE_X2AP_ID_Extension() { return set<UE_X2AP_ID_Extension>(7); }
		UE_X2AP_ID_Extension const* get_id_MeNB_UE_X2AP_ID_Extension() const { return get<UE_X2AP_ID_Extension>(7); }
		E_RABs_ToBeModified_SgNBModReqdList& select_id_E_RABs_ToBeModified_SgNBModReqdList() { return set<E_RABs_ToBeModified_SgNBModReqdList>(8); }
		E_RABs_ToBeModified_SgNBModReqdList const* get_id_E_RABs_ToBeModified_SgNBModReqdList() const { return get<E_RABs_ToBeModified_SgNBModReqdList>(8); }
		SgNBResourceCoordinationInformation& select_id_SgNBResourceCoordinationInformation() { return set<SgNBResourceCoordinationInformation>(9); }
		SgNBResourceCoordinationInformation const* get_id_SgNBResourceCoordinationInformation() const { return get<SgNBResourceCoordinationInformation>(9); }
		RRC_Config_Ind& select_id_RRCConfigIndication() { return set<RRC_Config_Ind>(10); }
		RRC_Config_Ind const* get_id_RRCConfigIndication() const { return get<RRC_Config_Ind>(10); }
		bool is_unknown() const { return type == 11; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<UE_X2AP_ID>(); break;
			case 2: var.destroy<SgNB_UE_X2AP_ID>(); break;
			case 3: var.destroy<Cause>(); break;
			case 4: var.destroy<PDCPChangeIndication>(); break;
			case 5: var.destroy<E_RABs_ToBeReleased_SgNBModReqdList>(); break;
			case 6: var.destroy<SgNBtoMeNBContainer>(); break;
			case 7: var.destroy<UE_X2AP_ID_Extension>(); break;
			case 8: var.destroy<E_RABs_ToBeModified_SgNBModReqdList>(); break;
			case 9: var.destroy<SgNBResourceCoordinationInformation>(); break;
			case 10: var.destroy<RRC_Config_Ind>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<UE_X2AP_ID>(1);
			v.template operator()<SgNB_UE_X2AP_ID>(2);
			v.template operator()<Cause>(3);
			v.template operator()<PDCPChangeIndication>(4);
			v.template operator()<E_RABs_ToBeReleased_SgNBModReqdList>(5);
			v.template operator()<SgNBtoMeNBContainer>(6);
			v.template operator()<UE_X2AP_ID_Extension>(7);
			v.template operator()<E_RABs_ToBeModified_SgNBModReqdList>(8);
			v.template operator()<SgNBResourceCoordinationInformation>(9);
			v.template operator()<RRC_Config_Ind>(10);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_MeNB_UE_X2AP_ID()); return true;
			case 2: v(select_id_SgNB_UE_X2AP_ID()); return true;
			case 3: v(select_id_Cause()); return true;
			case 4: v(select_id_PDCPChangeIndication()); return true;
			case 5: v(select_id_E_RABs_ToBeReleased_SgNBModReqdList()); return true;
			case 6: v(select_id_SgNBtoMeNBContainer()); return true;
			case 7: v(select_id_MeNB_UE_X2AP_ID_Extension()); return true;
			case 8: v(select_id_E_RABs_ToBeModified_SgNBModReqdList()); return true;
			case 9: v(select_id_SgNBResourceCoordinationInformation()); return true;
			case 10: v(select_id_RRCConfigIndication()); return true;
			case 11: if(type != 11) {clear(); asn::base::set();} type = 11; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<UE_X2AP_ID>()); return true;
			case 2: v(var.as<SgNB_UE_X2AP_ID>()); return true;
			case 3: v(var.as<Cause>()); return true;
			case 4: v(var.as<PDCPChangeIndication>()); return true;
			case 5: v(var.as<E_RABs_ToBeReleased_SgNBModReqdList>()); return true;
			case 6: v(var.as<SgNBtoMeNBContainer>()); return true;
			case 7: v(var.as<UE_X2AP_ID_Extension>()); return true;
			case 8: v(var.as<E_RABs_ToBeModified_SgNBModReqdList>()); return true;
			case 9: v(var.as<SgNBResourceCoordinationInformation>()); return true;
			case 10: v(var.as<RRC_Config_Ind>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(Cause)];
			char dummy2[sizeof(E_RABs_ToBeModified_SgNBModReqdList)];
			char dummy3[sizeof(E_RABs_ToBeReleased_SgNBModReqdList)];
			char dummy4[sizeof(PDCPChangeIndication)];
			char dummy5[sizeof(RRC_Config_Ind)];
			char dummy6[sizeof(SgNBResourceCoordinationInformation)];
			char dummy7[sizeof(SgNB_UE_X2AP_ID)];
			char dummy8[sizeof(SgNBtoMeNBContainer)];
			char dummy9[sizeof(UE_X2AP_ID)];
			char dummy10[sizeof(UE_X2AP_ID_Extension)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 11; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(mandatory); type=1;}
		void select_id_SgNB_UE_X2AP_ID() { set(mandatory); type=2;}
		void select_id_Cause() { set(mandatory); type=3;}
		void select_id_PDCPChangeIndication() { set(optional); type=4;}
		void select_id_E_RABs_ToBeReleased_SgNBModReqdList() { set(optional); type=5;}
		void select_id_SgNBtoMeNBContainer() { set(optional); type=6;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(optional); type=7;}
		void select_id_E_RABs_ToBeModified_SgNBModReqdList() { set(optional); type=8;}
		void select_id_SgNBResourceCoordinationInformation() { set(optional); type=9;}
		void select_id_RRCConfigIndication() { set(optional); type=10;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(mandatory)) { type = 2; return true; }
			else if(equal(mandatory)) { type = 3; return true; }
			else if(equal(optional)) { type = 4; return true; }
			else if(equal(optional)) { type = 5; return true; }
			else if(equal(optional)) { type = 6; return true; }
			else if(equal(optional)) { type = 7; return true; }
			else if(equal(optional)) { type = 8; return true; }
			else if(equal(optional)) { type = 9; return true; }
			else if(equal(optional)) { type = 10; return true; }
			else { type = 11; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(optional);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(optional);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(optional);} return false;
			case 7: type = 7; if(v(ref_nested())) { return equal(optional);} return false;
			case 8: type = 8; if(v(ref_nested())) { return equal(optional);} return false;
			case 9: type = 9; if(v(ref_nested())) { return equal(optional);} return false;
			case 10: type = 10; if(v(ref_nested())) { return equal(optional);} return false;
			case 11: type = 11; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
SgNBModificationRequired ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container		{{SgNBModificationRequired-IEs}},
	...
}
*/

struct SgNBModificationRequired : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "SgNBModificationRequired";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<SgNBModificationRequired_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<SgNBModificationRequired_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
SgNBReconfigurationComplete-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-MeNB-UE-X2AP-ID							CRITICALITY reject	TYPE UE-X2AP-ID											PRESENCE mandatory}|
	{ ID id-SgNB-UE-X2AP-ID							CRITICALITY reject	TYPE SgNB-UE-X2AP-ID									PRESENCE mandatory}|
	{ ID id-ResponseInformationSgNBReconfComp		CRITICALITY ignore	TYPE ResponseInformationSgNBReconfComp			PRESENCE mandatory}|
	{ ID id-MeNB-UE-X2AP-ID-Extension				CRITICALITY reject	TYPE UE-X2AP-ID-Extension								PRESENCE optional},
	...
}
*/

struct SgNBReconfigurationComplete_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 5; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(id_MeNB_UE_X2AP_ID); type=1;}
		void select_id_SgNB_UE_X2AP_ID() { set(id_SgNB_UE_X2AP_ID); type=2;}
		void select_id_ResponseInformationSgNBReconfComp() { set(id_ResponseInformationSgNBReconfComp); type=3;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(id_MeNB_UE_X2AP_ID_Extension); type=4;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_MeNB_UE_X2AP_ID)) { type = 1; return true; }
			else if(equal(id_SgNB_UE_X2AP_ID)) { type = 2; return true; }
			else if(equal(id_ResponseInformationSgNBReconfComp)) { type = 3; return true; }
			else if(equal(id_MeNB_UE_X2AP_ID_Extension)) { type = 4; return true; }
			else { type = 5; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_SgNB_UE_X2AP_ID);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_ResponseInformationSgNBReconfComp);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID_Extension);} return false;
			case 5: type = 5; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 5; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(reject); type=1;}
		void select_id_SgNB_UE_X2AP_ID() { set(reject); type=2;}
		void select_id_ResponseInformationSgNBReconfComp() { set(ignore); type=3;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(reject); type=4;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else if(equal(reject)) { type = 2; return true; }
			else if(equal(ignore)) { type = 3; return true; }
			else if(equal(reject)) { type = 4; return true; }
			else { type = 5; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(reject);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(ignore);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(reject);} return false;
			case 5: type = 5; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		UE_X2AP_ID& select_id_MeNB_UE_X2AP_ID() { return set<UE_X2AP_ID>(1); }
		UE_X2AP_ID const* get_id_MeNB_UE_X2AP_ID() const { return get<UE_X2AP_ID>(1); }
		SgNB_UE_X2AP_ID& select_id_SgNB_UE_X2AP_ID() { return set<SgNB_UE_X2AP_ID>(2); }
		SgNB_UE_X2AP_ID const* get_id_SgNB_UE_X2AP_ID() const { return get<SgNB_UE_X2AP_ID>(2); }
		ResponseInformationSgNBReconfComp& select_id_ResponseInformationSgNBReconfComp() { return set<ResponseInformationSgNBReconfComp>(3); }
		ResponseInformationSgNBReconfComp const* get_id_ResponseInformationSgNBReconfComp() const { return get<ResponseInformationSgNBReconfComp>(3); }
		UE_X2AP_ID_Extension& select_id_MeNB_UE_X2AP_ID_Extension() { return set<UE_X2AP_ID_Extension>(4); }
		UE_X2AP_ID_Extension const* get_id_MeNB_UE_X2AP_ID_Extension() const { return get<UE_X2AP_ID_Extension>(4); }
		bool is_unknown() const { return type == 5; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<UE_X2AP_ID>(); break;
			case 2: var.destroy<SgNB_UE_X2AP_ID>(); break;
			case 3: var.destroy<ResponseInformationSgNBReconfComp>(); break;
			case 4: var.destroy<UE_X2AP_ID_Extension>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<UE_X2AP_ID>(1);
			v.template operator()<SgNB_UE_X2AP_ID>(2);
			v.template operator()<ResponseInformationSgNBReconfComp>(3);
			v.template operator()<UE_X2AP_ID_Extension>(4);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_MeNB_UE_X2AP_ID()); return true;
			case 2: v(select_id_SgNB_UE_X2AP_ID()); return true;
			case 3: v(select_id_ResponseInformationSgNBReconfComp()); return true;
			case 4: v(select_id_MeNB_UE_X2AP_ID_Extension()); return true;
			case 5: if(type != 5) {clear(); asn::base::set();} type = 5; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<UE_X2AP_ID>()); return true;
			case 2: v(var.as<SgNB_UE_X2AP_ID>()); return true;
			case 3: v(var.as<ResponseInformationSgNBReconfComp>()); return true;
			case 4: v(var.as<UE_X2AP_ID_Extension>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(ResponseInformationSgNBReconfComp)];
			char dummy2[sizeof(SgNB_UE_X2AP_ID)];
			char dummy3[sizeof(UE_X2AP_ID)];
			char dummy4[sizeof(UE_X2AP_ID_Extension)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 5; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(mandatory); type=1;}
		void select_id_SgNB_UE_X2AP_ID() { set(mandatory); type=2;}
		void select_id_ResponseInformationSgNBReconfComp() { set(mandatory); type=3;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(optional); type=4;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(mandatory)) { type = 2; return true; }
			else if(equal(mandatory)) { type = 3; return true; }
			else if(equal(optional)) { type = 4; return true; }
			else { type = 5; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(optional);} return false;
			case 5: type = 5; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
SgNBReconfigurationComplete ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{SgNBReconfigurationComplete-IEs}},
	...
}
*/

struct SgNBReconfigurationComplete : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "SgNBReconfigurationComplete";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<SgNBReconfigurationComplete_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<SgNBReconfigurationComplete_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
SgNBReleaseConfirm-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-MeNB-UE-X2AP-ID							CRITICALITY ignore	TYPE UE-X2AP-ID										PRESENCE mandatory}|
	{ ID id-SgNB-UE-X2AP-ID							CRITICALITY ignore	TYPE SgNB-UE-X2AP-ID									PRESENCE mandatory}|
	{ ID id-E-RABs-ToBeReleased-SgNBRelConfList		CRITICALITY ignore	TYPE E-RABs-ToBeReleased-SgNBRelConfList		PRESENCE optional}|
	{ ID id-CriticalityDiagnostics					CRITICALITY ignore	TYPE CriticalityDiagnostics						PRESENCE optional}|
	{ ID id-MeNB-UE-X2AP-ID-Extension				CRITICALITY ignore	TYPE UE-X2AP-ID-Extension							PRESENCE optional},
	...
}
*/

struct SgNBReleaseConfirm_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 6; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(id_MeNB_UE_X2AP_ID); type=1;}
		void select_id_SgNB_UE_X2AP_ID() { set(id_SgNB_UE_X2AP_ID); type=2;}
		void select_id_E_RABs_ToBeReleased_SgNBRelConfList() { set(id_E_RABs_ToBeReleased_SgNBRelConfList); type=3;}
		void select_id_CriticalityDiagnostics() { set(id_CriticalityDiagnostics); type=4;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(id_MeNB_UE_X2AP_ID_Extension); type=5;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_MeNB_UE_X2AP_ID)) { type = 1; return true; }
			else if(equal(id_SgNB_UE_X2AP_ID)) { type = 2; return true; }
			else if(equal(id_E_RABs_ToBeReleased_SgNBRelConfList)) { type = 3; return true; }
			else if(equal(id_CriticalityDiagnostics)) { type = 4; return true; }
			else if(equal(id_MeNB_UE_X2AP_ID_Extension)) { type = 5; return true; }
			else { type = 6; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_SgNB_UE_X2AP_ID);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_E_RABs_ToBeReleased_SgNBRelConfList);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(id_CriticalityDiagnostics);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID_Extension);} return false;
			case 6: type = 6; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 6; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(ignore); type=1;}
		void select_id_SgNB_UE_X2AP_ID() { set(ignore); type=2;}
		void select_id_E_RABs_ToBeReleased_SgNBRelConfList() { set(ignore); type=3;}
		void select_id_CriticalityDiagnostics() { set(ignore); type=4;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(ignore); type=5;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else if(equal(ignore)) { type = 2; return true; }
			else if(equal(ignore)) { type = 3; return true; }
			else if(equal(ignore)) { type = 4; return true; }
			else if(equal(ignore)) { type = 5; return true; }
			else { type = 6; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(ignore);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(ignore);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(ignore);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(ignore);} return false;
			case 6: type = 6; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		UE_X2AP_ID& select_id_MeNB_UE_X2AP_ID() { return set<UE_X2AP_ID>(1); }
		UE_X2AP_ID const* get_id_MeNB_UE_X2AP_ID() const { return get<UE_X2AP_ID>(1); }
		SgNB_UE_X2AP_ID& select_id_SgNB_UE_X2AP_ID() { return set<SgNB_UE_X2AP_ID>(2); }
		SgNB_UE_X2AP_ID const* get_id_SgNB_UE_X2AP_ID() const { return get<SgNB_UE_X2AP_ID>(2); }
		E_RABs_ToBeReleased_SgNBRelConfList& select_id_E_RABs_ToBeReleased_SgNBRelConfList() { return set<E_RABs_ToBeReleased_SgNBRelConfList>(3); }
		E_RABs_ToBeReleased_SgNBRelConfList const* get_id_E_RABs_ToBeReleased_SgNBRelConfList() const { return get<E_RABs_ToBeReleased_SgNBRelConfList>(3); }
		CriticalityDiagnostics& select_id_CriticalityDiagnostics() { return set<CriticalityDiagnostics>(4); }
		CriticalityDiagnostics const* get_id_CriticalityDiagnostics() const { return get<CriticalityDiagnostics>(4); }
		UE_X2AP_ID_Extension& select_id_MeNB_UE_X2AP_ID_Extension() { return set<UE_X2AP_ID_Extension>(5); }
		UE_X2AP_ID_Extension const* get_id_MeNB_UE_X2AP_ID_Extension() const { return get<UE_X2AP_ID_Extension>(5); }
		bool is_unknown() const { return type == 6; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<UE_X2AP_ID>(); break;
			case 2: var.destroy<SgNB_UE_X2AP_ID>(); break;
			case 3: var.destroy<E_RABs_ToBeReleased_SgNBRelConfList>(); break;
			case 4: var.destroy<CriticalityDiagnostics>(); break;
			case 5: var.destroy<UE_X2AP_ID_Extension>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<UE_X2AP_ID>(1);
			v.template operator()<SgNB_UE_X2AP_ID>(2);
			v.template operator()<E_RABs_ToBeReleased_SgNBRelConfList>(3);
			v.template operator()<CriticalityDiagnostics>(4);
			v.template operator()<UE_X2AP_ID_Extension>(5);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_MeNB_UE_X2AP_ID()); return true;
			case 2: v(select_id_SgNB_UE_X2AP_ID()); return true;
			case 3: v(select_id_E_RABs_ToBeReleased_SgNBRelConfList()); return true;
			case 4: v(select_id_CriticalityDiagnostics()); return true;
			case 5: v(select_id_MeNB_UE_X2AP_ID_Extension()); return true;
			case 6: if(type != 6) {clear(); asn::base::set();} type = 6; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<UE_X2AP_ID>()); return true;
			case 2: v(var.as<SgNB_UE_X2AP_ID>()); return true;
			case 3: v(var.as<E_RABs_ToBeReleased_SgNBRelConfList>()); return true;
			case 4: v(var.as<CriticalityDiagnostics>()); return true;
			case 5: v(var.as<UE_X2AP_ID_Extension>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(CriticalityDiagnostics)];
			char dummy2[sizeof(E_RABs_ToBeReleased_SgNBRelConfList)];
			char dummy3[sizeof(SgNB_UE_X2AP_ID)];
			char dummy4[sizeof(UE_X2AP_ID)];
			char dummy5[sizeof(UE_X2AP_ID_Extension)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 6; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(mandatory); type=1;}
		void select_id_SgNB_UE_X2AP_ID() { set(mandatory); type=2;}
		void select_id_E_RABs_ToBeReleased_SgNBRelConfList() { set(optional); type=3;}
		void select_id_CriticalityDiagnostics() { set(optional); type=4;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(optional); type=5;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(mandatory)) { type = 2; return true; }
			else if(equal(optional)) { type = 3; return true; }
			else if(equal(optional)) { type = 4; return true; }
			else if(equal(optional)) { type = 5; return true; }
			else { type = 6; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(optional);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(optional);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(optional);} return false;
			case 6: type = 6; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
SgNBReleaseConfirm ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{SgNBReleaseConfirm-IEs}},
	...
}
*/

struct SgNBReleaseConfirm : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "SgNBReleaseConfirm";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<SgNBReleaseConfirm_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<SgNBReleaseConfirm_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
SgNBReleaseRequest-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-MeNB-UE-X2AP-ID							CRITICALITY reject	TYPE UE-X2AP-ID										PRESENCE mandatory}|
	{ ID id-SgNB-UE-X2AP-ID							CRITICALITY reject	TYPE SgNB-UE-X2AP-ID									PRESENCE optional}|
	{ ID id-Cause									CRITICALITY ignore	TYPE Cause											PRESENCE mandatory}|
	{ ID id-E-RABs-ToBeReleased-SgNBRelReqList		CRITICALITY ignore	TYPE E-RABs-ToBeReleased-SgNBRelReqList		PRESENCE optional}|
	{ ID id-UE-ContextKeptIndicator					CRITICALITY ignore	TYPE UE-ContextKeptIndicator						PRESENCE optional}|
	{ ID id-MeNB-UE-X2AP-ID-Extension				CRITICALITY reject	TYPE UE-X2AP-ID-Extension							PRESENCE optional}|
	{ ID id-MeNBtoSgNBContainer						CRITICALITY reject	TYPE MeNBtoSgNBContainer								PRESENCE optional},
	...
}
*/

struct SgNBReleaseRequest_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 8; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(id_MeNB_UE_X2AP_ID); type=1;}
		void select_id_SgNB_UE_X2AP_ID() { set(id_SgNB_UE_X2AP_ID); type=2;}
		void select_id_Cause() { set(id_Cause); type=3;}
		void select_id_E_RABs_ToBeReleased_SgNBRelReqList() { set(id_E_RABs_ToBeReleased_SgNBRelReqList); type=4;}
		void select_id_UE_ContextKeptIndicator() { set(id_UE_ContextKeptIndicator); type=5;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(id_MeNB_UE_X2AP_ID_Extension); type=6;}
		void select_id_MeNBtoSgNBContainer() { set(id_MeNBtoSgNBContainer); type=7;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_MeNB_UE_X2AP_ID)) { type = 1; return true; }
			else if(equal(id_SgNB_UE_X2AP_ID)) { type = 2; return true; }
			else if(equal(id_Cause)) { type = 3; return true; }
			else if(equal(id_E_RABs_ToBeReleased_SgNBRelReqList)) { type = 4; return true; }
			else if(equal(id_UE_ContextKeptIndicator)) { type = 5; return true; }
			else if(equal(id_MeNB_UE_X2AP_ID_Extension)) { type = 6; return true; }
			else if(equal(id_MeNBtoSgNBContainer)) { type = 7; return true; }
			else { type = 8; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_SgNB_UE_X2AP_ID);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_Cause);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(id_E_RABs_ToBeReleased_SgNBRelReqList);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(id_UE_ContextKeptIndicator);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID_Extension);} return false;
			case 7: type = 7; if(v(ref_nested())) { return equal(id_MeNBtoSgNBContainer);} return false;
			case 8: type = 8; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 8; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(reject); type=1;}
		void select_id_SgNB_UE_X2AP_ID() { set(reject); type=2;}
		void select_id_Cause() { set(ignore); type=3;}
		void select_id_E_RABs_ToBeReleased_SgNBRelReqList() { set(ignore); type=4;}
		void select_id_UE_ContextKeptIndicator() { set(ignore); type=5;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(reject); type=6;}
		void select_id_MeNBtoSgNBContainer() { set(reject); type=7;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else if(equal(reject)) { type = 2; return true; }
			else if(equal(ignore)) { type = 3; return true; }
			else if(equal(ignore)) { type = 4; return true; }
			else if(equal(ignore)) { type = 5; return true; }
			else if(equal(reject)) { type = 6; return true; }
			else if(equal(reject)) { type = 7; return true; }
			else { type = 8; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(reject);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(ignore);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(ignore);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(ignore);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(reject);} return false;
			case 7: type = 7; if(v(ref_nested())) { return equal(reject);} return false;
			case 8: type = 8; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		UE_X2AP_ID& select_id_MeNB_UE_X2AP_ID() { return set<UE_X2AP_ID>(1); }
		UE_X2AP_ID const* get_id_MeNB_UE_X2AP_ID() const { return get<UE_X2AP_ID>(1); }
		SgNB_UE_X2AP_ID& select_id_SgNB_UE_X2AP_ID() { return set<SgNB_UE_X2AP_ID>(2); }
		SgNB_UE_X2AP_ID const* get_id_SgNB_UE_X2AP_ID() const { return get<SgNB_UE_X2AP_ID>(2); }
		Cause& select_id_Cause() { return set<Cause>(3); }
		Cause const* get_id_Cause() const { return get<Cause>(3); }
		E_RABs_ToBeReleased_SgNBRelReqList& select_id_E_RABs_ToBeReleased_SgNBRelReqList() { return set<E_RABs_ToBeReleased_SgNBRelReqList>(4); }
		E_RABs_ToBeReleased_SgNBRelReqList const* get_id_E_RABs_ToBeReleased_SgNBRelReqList() const { return get<E_RABs_ToBeReleased_SgNBRelReqList>(4); }
		UE_ContextKeptIndicator& select_id_UE_ContextKeptIndicator() { return set<UE_ContextKeptIndicator>(5); }
		UE_ContextKeptIndicator const* get_id_UE_ContextKeptIndicator() const { return get<UE_ContextKeptIndicator>(5); }
		UE_X2AP_ID_Extension& select_id_MeNB_UE_X2AP_ID_Extension() { return set<UE_X2AP_ID_Extension>(6); }
		UE_X2AP_ID_Extension const* get_id_MeNB_UE_X2AP_ID_Extension() const { return get<UE_X2AP_ID_Extension>(6); }
		MeNBtoSgNBContainer& select_id_MeNBtoSgNBContainer() { return set<MeNBtoSgNBContainer>(7); }
		MeNBtoSgNBContainer const* get_id_MeNBtoSgNBContainer() const { return get<MeNBtoSgNBContainer>(7); }
		bool is_unknown() const { return type == 8; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<UE_X2AP_ID>(); break;
			case 2: var.destroy<SgNB_UE_X2AP_ID>(); break;
			case 3: var.destroy<Cause>(); break;
			case 4: var.destroy<E_RABs_ToBeReleased_SgNBRelReqList>(); break;
			case 5: var.destroy<UE_ContextKeptIndicator>(); break;
			case 6: var.destroy<UE_X2AP_ID_Extension>(); break;
			case 7: var.destroy<MeNBtoSgNBContainer>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<UE_X2AP_ID>(1);
			v.template operator()<SgNB_UE_X2AP_ID>(2);
			v.template operator()<Cause>(3);
			v.template operator()<E_RABs_ToBeReleased_SgNBRelReqList>(4);
			v.template operator()<UE_ContextKeptIndicator>(5);
			v.template operator()<UE_X2AP_ID_Extension>(6);
			v.template operator()<MeNBtoSgNBContainer>(7);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_MeNB_UE_X2AP_ID()); return true;
			case 2: v(select_id_SgNB_UE_X2AP_ID()); return true;
			case 3: v(select_id_Cause()); return true;
			case 4: v(select_id_E_RABs_ToBeReleased_SgNBRelReqList()); return true;
			case 5: v(select_id_UE_ContextKeptIndicator()); return true;
			case 6: v(select_id_MeNB_UE_X2AP_ID_Extension()); return true;
			case 7: v(select_id_MeNBtoSgNBContainer()); return true;
			case 8: if(type != 8) {clear(); asn::base::set();} type = 8; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<UE_X2AP_ID>()); return true;
			case 2: v(var.as<SgNB_UE_X2AP_ID>()); return true;
			case 3: v(var.as<Cause>()); return true;
			case 4: v(var.as<E_RABs_ToBeReleased_SgNBRelReqList>()); return true;
			case 5: v(var.as<UE_ContextKeptIndicator>()); return true;
			case 6: v(var.as<UE_X2AP_ID_Extension>()); return true;
			case 7: v(var.as<MeNBtoSgNBContainer>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(Cause)];
			char dummy2[sizeof(E_RABs_ToBeReleased_SgNBRelReqList)];
			char dummy3[sizeof(MeNBtoSgNBContainer)];
			char dummy4[sizeof(SgNB_UE_X2AP_ID)];
			char dummy5[sizeof(UE_ContextKeptIndicator)];
			char dummy6[sizeof(UE_X2AP_ID)];
			char dummy7[sizeof(UE_X2AP_ID_Extension)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 8; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(mandatory); type=1;}
		void select_id_SgNB_UE_X2AP_ID() { set(optional); type=2;}
		void select_id_Cause() { set(mandatory); type=3;}
		void select_id_E_RABs_ToBeReleased_SgNBRelReqList() { set(optional); type=4;}
		void select_id_UE_ContextKeptIndicator() { set(optional); type=5;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(optional); type=6;}
		void select_id_MeNBtoSgNBContainer() { set(optional); type=7;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(optional)) { type = 2; return true; }
			else if(equal(mandatory)) { type = 3; return true; }
			else if(equal(optional)) { type = 4; return true; }
			else if(equal(optional)) { type = 5; return true; }
			else if(equal(optional)) { type = 6; return true; }
			else if(equal(optional)) { type = 7; return true; }
			else { type = 8; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(optional);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(optional);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(optional);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(optional);} return false;
			case 7: type = 7; if(v(ref_nested())) { return equal(optional);} return false;
			case 8: type = 8; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
SgNBReleaseRequest ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container		{{SgNBReleaseRequest-IEs}},
	...
}
*/

struct SgNBReleaseRequest : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "SgNBReleaseRequest";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<SgNBReleaseRequest_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<SgNBReleaseRequest_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
SgNBReleaseRequestAcknowledge-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-MeNB-UE-X2AP-ID									CRITICALITY ignore	TYPE UE-X2AP-ID											PRESENCE mandatory}|
	{ ID id-SgNB-UE-X2AP-ID									CRITICALITY ignore	TYPE SgNB-UE-X2AP-ID								PRESENCE mandatory}|
	{ ID id-CriticalityDiagnostics							CRITICALITY ignore	TYPE CriticalityDiagnostics						PRESENCE optional }|
	{ ID id-MeNB-UE-X2AP-ID-Extension						CRITICALITY reject	TYPE UE-X2AP-ID-Extension							PRESENCE optional }|
	{ ID id-E-RABs-Admitted-ToBeReleased-SgNBRelReqAckList	CRITICALITY ignore	TYPE E-RABs-Admitted-ToBeReleased-SgNBRelReqAckList	PRESENCE optional },
	...
}
*/

struct SgNBReleaseRequestAcknowledge_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 6; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(id_MeNB_UE_X2AP_ID); type=1;}
		void select_id_SgNB_UE_X2AP_ID() { set(id_SgNB_UE_X2AP_ID); type=2;}
		void select_id_CriticalityDiagnostics() { set(id_CriticalityDiagnostics); type=3;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(id_MeNB_UE_X2AP_ID_Extension); type=4;}
		void select_id_E_RABs_Admitted_ToBeReleased_SgNBRelReqAckList() { set(id_E_RABs_Admitted_ToBeReleased_SgNBRelReqAckList); type=5;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_MeNB_UE_X2AP_ID)) { type = 1; return true; }
			else if(equal(id_SgNB_UE_X2AP_ID)) { type = 2; return true; }
			else if(equal(id_CriticalityDiagnostics)) { type = 3; return true; }
			else if(equal(id_MeNB_UE_X2AP_ID_Extension)) { type = 4; return true; }
			else if(equal(id_E_RABs_Admitted_ToBeReleased_SgNBRelReqAckList)) { type = 5; return true; }
			else { type = 6; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_SgNB_UE_X2AP_ID);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_CriticalityDiagnostics);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID_Extension);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(id_E_RABs_Admitted_ToBeReleased_SgNBRelReqAckList);} return false;
			case 6: type = 6; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 6; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(ignore); type=1;}
		void select_id_SgNB_UE_X2AP_ID() { set(ignore); type=2;}
		void select_id_CriticalityDiagnostics() { set(ignore); type=3;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(reject); type=4;}
		void select_id_E_RABs_Admitted_ToBeReleased_SgNBRelReqAckList() { set(ignore); type=5;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else if(equal(ignore)) { type = 2; return true; }
			else if(equal(ignore)) { type = 3; return true; }
			else if(equal(reject)) { type = 4; return true; }
			else if(equal(ignore)) { type = 5; return true; }
			else { type = 6; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(ignore);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(ignore);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(reject);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(ignore);} return false;
			case 6: type = 6; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		UE_X2AP_ID& select_id_MeNB_UE_X2AP_ID() { return set<UE_X2AP_ID>(1); }
		UE_X2AP_ID const* get_id_MeNB_UE_X2AP_ID() const { return get<UE_X2AP_ID>(1); }
		SgNB_UE_X2AP_ID& select_id_SgNB_UE_X2AP_ID() { return set<SgNB_UE_X2AP_ID>(2); }
		SgNB_UE_X2AP_ID const* get_id_SgNB_UE_X2AP_ID() const { return get<SgNB_UE_X2AP_ID>(2); }
		CriticalityDiagnostics& select_id_CriticalityDiagnostics() { return set<CriticalityDiagnostics>(3); }
		CriticalityDiagnostics const* get_id_CriticalityDiagnostics() const { return get<CriticalityDiagnostics>(3); }
		UE_X2AP_ID_Extension& select_id_MeNB_UE_X2AP_ID_Extension() { return set<UE_X2AP_ID_Extension>(4); }
		UE_X2AP_ID_Extension const* get_id_MeNB_UE_X2AP_ID_Extension() const { return get<UE_X2AP_ID_Extension>(4); }
		E_RABs_Admitted_ToBeReleased_SgNBRelReqAckList& select_id_E_RABs_Admitted_ToBeReleased_SgNBRelReqAckList() { return set<E_RABs_Admitted_ToBeReleased_SgNBRelReqAckList>(5); }
		E_RABs_Admitted_ToBeReleased_SgNBRelReqAckList const* get_id_E_RABs_Admitted_ToBeReleased_SgNBRelReqAckList() const { return get<E_RABs_Admitted_ToBeReleased_SgNBRelReqAckList>(5); }
		bool is_unknown() const { return type == 6; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<UE_X2AP_ID>(); break;
			case 2: var.destroy<SgNB_UE_X2AP_ID>(); break;
			case 3: var.destroy<CriticalityDiagnostics>(); break;
			case 4: var.destroy<UE_X2AP_ID_Extension>(); break;
			case 5: var.destroy<E_RABs_Admitted_ToBeReleased_SgNBRelReqAckList>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<UE_X2AP_ID>(1);
			v.template operator()<SgNB_UE_X2AP_ID>(2);
			v.template operator()<CriticalityDiagnostics>(3);
			v.template operator()<UE_X2AP_ID_Extension>(4);
			v.template operator()<E_RABs_Admitted_ToBeReleased_SgNBRelReqAckList>(5);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_MeNB_UE_X2AP_ID()); return true;
			case 2: v(select_id_SgNB_UE_X2AP_ID()); return true;
			case 3: v(select_id_CriticalityDiagnostics()); return true;
			case 4: v(select_id_MeNB_UE_X2AP_ID_Extension()); return true;
			case 5: v(select_id_E_RABs_Admitted_ToBeReleased_SgNBRelReqAckList()); return true;
			case 6: if(type != 6) {clear(); asn::base::set();} type = 6; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<UE_X2AP_ID>()); return true;
			case 2: v(var.as<SgNB_UE_X2AP_ID>()); return true;
			case 3: v(var.as<CriticalityDiagnostics>()); return true;
			case 4: v(var.as<UE_X2AP_ID_Extension>()); return true;
			case 5: v(var.as<E_RABs_Admitted_ToBeReleased_SgNBRelReqAckList>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(CriticalityDiagnostics)];
			char dummy2[sizeof(E_RABs_Admitted_ToBeReleased_SgNBRelReqAckList)];
			char dummy3[sizeof(SgNB_UE_X2AP_ID)];
			char dummy4[sizeof(UE_X2AP_ID)];
			char dummy5[sizeof(UE_X2AP_ID_Extension)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 6; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(mandatory); type=1;}
		void select_id_SgNB_UE_X2AP_ID() { set(mandatory); type=2;}
		void select_id_CriticalityDiagnostics() { set(optional); type=3;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(optional); type=4;}
		void select_id_E_RABs_Admitted_ToBeReleased_SgNBRelReqAckList() { set(optional); type=5;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(mandatory)) { type = 2; return true; }
			else if(equal(optional)) { type = 3; return true; }
			else if(equal(optional)) { type = 4; return true; }
			else if(equal(optional)) { type = 5; return true; }
			else { type = 6; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(optional);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(optional);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(optional);} return false;
			case 6: type = 6; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
SgNBReleaseRequestAcknowledge ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container		{{SgNBReleaseRequestAcknowledge-IEs}},
	...
}
*/

struct SgNBReleaseRequestAcknowledge : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "SgNBReleaseRequestAcknowledge";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<SgNBReleaseRequestAcknowledge_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<SgNBReleaseRequestAcknowledge_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
SgNBReleaseRequestReject-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-MeNB-UE-X2AP-ID							CRITICALITY ignore	TYPE UE-X2AP-ID										PRESENCE mandatory}|
	{ ID id-SgNB-UE-X2AP-ID							CRITICALITY ignore	TYPE SgNB-UE-X2AP-ID									PRESENCE mandatory}|
	{ ID id-Cause									CRITICALITY ignore	TYPE Cause											PRESENCE mandatory}|
	{ ID id-CriticalityDiagnostics					CRITICALITY ignore	TYPE CriticalityDiagnostics						PRESENCE optional}|
	{ ID id-MeNB-UE-X2AP-ID-Extension				CRITICALITY reject	TYPE UE-X2AP-ID-Extension							PRESENCE optional},
	...
}
*/

struct SgNBReleaseRequestReject_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 6; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(id_MeNB_UE_X2AP_ID); type=1;}
		void select_id_SgNB_UE_X2AP_ID() { set(id_SgNB_UE_X2AP_ID); type=2;}
		void select_id_Cause() { set(id_Cause); type=3;}
		void select_id_CriticalityDiagnostics() { set(id_CriticalityDiagnostics); type=4;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(id_MeNB_UE_X2AP_ID_Extension); type=5;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_MeNB_UE_X2AP_ID)) { type = 1; return true; }
			else if(equal(id_SgNB_UE_X2AP_ID)) { type = 2; return true; }
			else if(equal(id_Cause)) { type = 3; return true; }
			else if(equal(id_CriticalityDiagnostics)) { type = 4; return true; }
			else if(equal(id_MeNB_UE_X2AP_ID_Extension)) { type = 5; return true; }
			else { type = 6; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_SgNB_UE_X2AP_ID);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_Cause);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(id_CriticalityDiagnostics);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID_Extension);} return false;
			case 6: type = 6; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 6; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(ignore); type=1;}
		void select_id_SgNB_UE_X2AP_ID() { set(ignore); type=2;}
		void select_id_Cause() { set(ignore); type=3;}
		void select_id_CriticalityDiagnostics() { set(ignore); type=4;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(reject); type=5;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else if(equal(ignore)) { type = 2; return true; }
			else if(equal(ignore)) { type = 3; return true; }
			else if(equal(ignore)) { type = 4; return true; }
			else if(equal(reject)) { type = 5; return true; }
			else { type = 6; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(ignore);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(ignore);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(ignore);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(reject);} return false;
			case 6: type = 6; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		UE_X2AP_ID& select_id_MeNB_UE_X2AP_ID() { return set<UE_X2AP_ID>(1); }
		UE_X2AP_ID const* get_id_MeNB_UE_X2AP_ID() const { return get<UE_X2AP_ID>(1); }
		SgNB_UE_X2AP_ID& select_id_SgNB_UE_X2AP_ID() { return set<SgNB_UE_X2AP_ID>(2); }
		SgNB_UE_X2AP_ID const* get_id_SgNB_UE_X2AP_ID() const { return get<SgNB_UE_X2AP_ID>(2); }
		Cause& select_id_Cause() { return set<Cause>(3); }
		Cause const* get_id_Cause() const { return get<Cause>(3); }
		CriticalityDiagnostics& select_id_CriticalityDiagnostics() { return set<CriticalityDiagnostics>(4); }
		CriticalityDiagnostics const* get_id_CriticalityDiagnostics() const { return get<CriticalityDiagnostics>(4); }
		UE_X2AP_ID_Extension& select_id_MeNB_UE_X2AP_ID_Extension() { return set<UE_X2AP_ID_Extension>(5); }
		UE_X2AP_ID_Extension const* get_id_MeNB_UE_X2AP_ID_Extension() const { return get<UE_X2AP_ID_Extension>(5); }
		bool is_unknown() const { return type == 6; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<UE_X2AP_ID>(); break;
			case 2: var.destroy<SgNB_UE_X2AP_ID>(); break;
			case 3: var.destroy<Cause>(); break;
			case 4: var.destroy<CriticalityDiagnostics>(); break;
			case 5: var.destroy<UE_X2AP_ID_Extension>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<UE_X2AP_ID>(1);
			v.template operator()<SgNB_UE_X2AP_ID>(2);
			v.template operator()<Cause>(3);
			v.template operator()<CriticalityDiagnostics>(4);
			v.template operator()<UE_X2AP_ID_Extension>(5);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_MeNB_UE_X2AP_ID()); return true;
			case 2: v(select_id_SgNB_UE_X2AP_ID()); return true;
			case 3: v(select_id_Cause()); return true;
			case 4: v(select_id_CriticalityDiagnostics()); return true;
			case 5: v(select_id_MeNB_UE_X2AP_ID_Extension()); return true;
			case 6: if(type != 6) {clear(); asn::base::set();} type = 6; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<UE_X2AP_ID>()); return true;
			case 2: v(var.as<SgNB_UE_X2AP_ID>()); return true;
			case 3: v(var.as<Cause>()); return true;
			case 4: v(var.as<CriticalityDiagnostics>()); return true;
			case 5: v(var.as<UE_X2AP_ID_Extension>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(Cause)];
			char dummy2[sizeof(CriticalityDiagnostics)];
			char dummy3[sizeof(SgNB_UE_X2AP_ID)];
			char dummy4[sizeof(UE_X2AP_ID)];
			char dummy5[sizeof(UE_X2AP_ID_Extension)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 6; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(mandatory); type=1;}
		void select_id_SgNB_UE_X2AP_ID() { set(mandatory); type=2;}
		void select_id_Cause() { set(mandatory); type=3;}
		void select_id_CriticalityDiagnostics() { set(optional); type=4;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(optional); type=5;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(mandatory)) { type = 2; return true; }
			else if(equal(mandatory)) { type = 3; return true; }
			else if(equal(optional)) { type = 4; return true; }
			else if(equal(optional)) { type = 5; return true; }
			else { type = 6; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(optional);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(optional);} return false;
			case 6: type = 6; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
SgNBReleaseRequestReject ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container		{{SgNBReleaseRequestReject-IEs}},
	...
}
*/

struct SgNBReleaseRequestReject : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "SgNBReleaseRequestReject";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<SgNBReleaseRequestReject_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<SgNBReleaseRequestReject_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
SgNBReleaseRequired-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-MeNB-UE-X2AP-ID							CRITICALITY reject	TYPE UE-X2AP-ID											PRESENCE mandatory}|
	{ ID id-SgNB-UE-X2AP-ID							CRITICALITY reject	TYPE SgNB-UE-X2AP-ID										PRESENCE mandatory}|
	{ ID id-Cause									CRITICALITY ignore	TYPE Cause												PRESENCE mandatory}|
	{ ID id-MeNB-UE-X2AP-ID-Extension				CRITICALITY reject	TYPE UE-X2AP-ID-Extension							PRESENCE optional }|
	{ ID id-E-RABs-ToBeReleased-SgNBRelReqdList		CRITICALITY ignore	TYPE E-RABs-ToBeReleased-SgNBRelReqdList		PRESENCE optional },
	...
}
*/

struct SgNBReleaseRequired_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 6; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(id_MeNB_UE_X2AP_ID); type=1;}
		void select_id_SgNB_UE_X2AP_ID() { set(id_SgNB_UE_X2AP_ID); type=2;}
		void select_id_Cause() { set(id_Cause); type=3;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(id_MeNB_UE_X2AP_ID_Extension); type=4;}
		void select_id_E_RABs_ToBeReleased_SgNBRelReqdList() { set(id_E_RABs_ToBeReleased_SgNBRelReqdList); type=5;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_MeNB_UE_X2AP_ID)) { type = 1; return true; }
			else if(equal(id_SgNB_UE_X2AP_ID)) { type = 2; return true; }
			else if(equal(id_Cause)) { type = 3; return true; }
			else if(equal(id_MeNB_UE_X2AP_ID_Extension)) { type = 4; return true; }
			else if(equal(id_E_RABs_ToBeReleased_SgNBRelReqdList)) { type = 5; return true; }
			else { type = 6; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_SgNB_UE_X2AP_ID);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_Cause);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(id_MeNB_UE_X2AP_ID_Extension);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(id_E_RABs_ToBeReleased_SgNBRelReqdList);} return false;
			case 6: type = 6; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 6; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(reject); type=1;}
		void select_id_SgNB_UE_X2AP_ID() { set(reject); type=2;}
		void select_id_Cause() { set(ignore); type=3;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(reject); type=4;}
		void select_id_E_RABs_ToBeReleased_SgNBRelReqdList() { set(ignore); type=5;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else if(equal(reject)) { type = 2; return true; }
			else if(equal(ignore)) { type = 3; return true; }
			else if(equal(reject)) { type = 4; return true; }
			else if(equal(ignore)) { type = 5; return true; }
			else { type = 6; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(reject);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(ignore);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(reject);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(ignore);} return false;
			case 6: type = 6; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		UE_X2AP_ID& select_id_MeNB_UE_X2AP_ID() { return set<UE_X2AP_ID>(1); }
		UE_X2AP_ID const* get_id_MeNB_UE_X2AP_ID() const { return get<UE_X2AP_ID>(1); }
		SgNB_UE_X2AP_ID& select_id_SgNB_UE_X2AP_ID() { return set<SgNB_UE_X2AP_ID>(2); }
		SgNB_UE_X2AP_ID const* get_id_SgNB_UE_X2AP_ID() const { return get<SgNB_UE_X2AP_ID>(2); }
		Cause& select_id_Cause() { return set<Cause>(3); }
		Cause const* get_id_Cause() const { return get<Cause>(3); }
		UE_X2AP_ID_Extension& select_id_MeNB_UE_X2AP_ID_Extension() { return set<UE_X2AP_ID_Extension>(4); }
		UE_X2AP_ID_Extension const* get_id_MeNB_UE_X2AP_ID_Extension() const { return get<UE_X2AP_ID_Extension>(4); }
		E_RABs_ToBeReleased_SgNBRelReqdList& select_id_E_RABs_ToBeReleased_SgNBRelReqdList() { return set<E_RABs_ToBeReleased_SgNBRelReqdList>(5); }
		E_RABs_ToBeReleased_SgNBRelReqdList const* get_id_E_RABs_ToBeReleased_SgNBRelReqdList() const { return get<E_RABs_ToBeReleased_SgNBRelReqdList>(5); }
		bool is_unknown() const { return type == 6; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<UE_X2AP_ID>(); break;
			case 2: var.destroy<SgNB_UE_X2AP_ID>(); break;
			case 3: var.destroy<Cause>(); break;
			case 4: var.destroy<UE_X2AP_ID_Extension>(); break;
			case 5: var.destroy<E_RABs_ToBeReleased_SgNBRelReqdList>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<UE_X2AP_ID>(1);
			v.template operator()<SgNB_UE_X2AP_ID>(2);
			v.template operator()<Cause>(3);
			v.template operator()<UE_X2AP_ID_Extension>(4);
			v.template operator()<E_RABs_ToBeReleased_SgNBRelReqdList>(5);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_MeNB_UE_X2AP_ID()); return true;
			case 2: v(select_id_SgNB_UE_X2AP_ID()); return true;
			case 3: v(select_id_Cause()); return true;
			case 4: v(select_id_MeNB_UE_X2AP_ID_Extension()); return true;
			case 5: v(select_id_E_RABs_ToBeReleased_SgNBRelReqdList()); return true;
			case 6: if(type != 6) {clear(); asn::base::set();} type = 6; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<UE_X2AP_ID>()); return true;
			case 2: v(var.as<SgNB_UE_X2AP_ID>()); return true;
			case 3: v(var.as<Cause>()); return true;
			case 4: v(var.as<UE_X2AP_ID_Extension>()); return true;
			case 5: v(var.as<E_RABs_ToBeReleased_SgNBRelReqdList>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(Cause)];
			char dummy2[sizeof(E_RABs_ToBeReleased_SgNBRelReqdList)];
			char dummy3[sizeof(SgNB_UE_X2AP_ID)];
			char dummy4[sizeof(UE_X2AP_ID)];
			char dummy5[sizeof(UE_X2AP_ID_Extension)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 6; }
		void clear() {type = 0;}
		void select_id_MeNB_UE_X2AP_ID() { set(mandatory); type=1;}
		void select_id_SgNB_UE_X2AP_ID() { set(mandatory); type=2;}
		void select_id_Cause() { set(mandatory); type=3;}
		void select_id_MeNB_UE_X2AP_ID_Extension() { set(optional); type=4;}
		void select_id_E_RABs_ToBeReleased_SgNBRelReqdList() { set(optional); type=5;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(mandatory)) { type = 2; return true; }
			else if(equal(mandatory)) { type = 3; return true; }
			else if(equal(optional)) { type = 4; return true; }
			else if(equal(optional)) { type = 5; return true; }
			else { type = 6; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(optional);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(optional);} return false;
			case 6: type = 6; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
SgNBReleaseRequired ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{SgNBReleaseRequired-IEs}},
	...
}
*/

struct SgNBReleaseRequired : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "SgNBReleaseRequired";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<SgNBReleaseRequired_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<SgNBReleaseRequired_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
UEContextRelease-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-Old-eNB-UE-X2AP-ID					CRITICALITY reject	TYPE UE-X2AP-ID									PRESENCE mandatory}|
	{ ID id-New-eNB-UE-X2AP-ID					CRITICALITY reject	TYPE UE-X2AP-ID									PRESENCE mandatory}|
	{ ID id-Old-eNB-UE-X2AP-ID-Extension		CRITICALITY reject	TYPE UE-X2AP-ID-Extension						PRESENCE optional}|
	{ ID id-New-eNB-UE-X2AP-ID-Extension		CRITICALITY reject	TYPE UE-X2AP-ID-Extension						PRESENCE optional}|
	{ ID id-SIPTO-BearerDeactivationIndication	CRITICALITY ignore	TYPE SIPTOBearerDeactivationIndication		PRESENCE optional}|
	{ ID id-SgNB-UE-X2AP-ID						CRITICALITY ignore	TYPE SgNB-UE-X2AP-ID							PRESENCE optional},
	...
}
*/

struct UEContextRelease_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 7; }
		void clear() {type = 0;}
		void select_id_Old_eNB_UE_X2AP_ID() { set(id_Old_eNB_UE_X2AP_ID); type=1;}
		void select_id_New_eNB_UE_X2AP_ID() { set(id_New_eNB_UE_X2AP_ID); type=2;}
		void select_id_Old_eNB_UE_X2AP_ID_Extension() { set(id_Old_eNB_UE_X2AP_ID_Extension); type=3;}
		void select_id_New_eNB_UE_X2AP_ID_Extension() { set(id_New_eNB_UE_X2AP_ID_Extension); type=4;}
		void select_id_SIPTO_BearerDeactivationIndication() { set(id_SIPTO_BearerDeactivationIndication); type=5;}
		void select_id_SgNB_UE_X2AP_ID() { set(id_SgNB_UE_X2AP_ID); type=6;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_Old_eNB_UE_X2AP_ID)) { type = 1; return true; }
			else if(equal(id_New_eNB_UE_X2AP_ID)) { type = 2; return true; }
			else if(equal(id_Old_eNB_UE_X2AP_ID_Extension)) { type = 3; return true; }
			else if(equal(id_New_eNB_UE_X2AP_ID_Extension)) { type = 4; return true; }
			else if(equal(id_SIPTO_BearerDeactivationIndication)) { type = 5; return true; }
			else if(equal(id_SgNB_UE_X2AP_ID)) { type = 6; return true; }
			else { type = 7; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_Old_eNB_UE_X2AP_ID);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_New_eNB_UE_X2AP_ID);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_Old_eNB_UE_X2AP_ID_Extension);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(id_New_eNB_UE_X2AP_ID_Extension);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(id_SIPTO_BearerDeactivationIndication);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(id_SgNB_UE_X2AP_ID);} return false;
			case 7: type = 7; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 7; }
		void clear() {type = 0;}
		void select_id_Old_eNB_UE_X2AP_ID() { set(reject); type=1;}
		void select_id_New_eNB_UE_X2AP_ID() { set(reject); type=2;}
		void select_id_Old_eNB_UE_X2AP_ID_Extension() { set(reject); type=3;}
		void select_id_New_eNB_UE_X2AP_ID_Extension() { set(reject); type=4;}
		void select_id_SIPTO_BearerDeactivationIndication() { set(ignore); type=5;}
		void select_id_SgNB_UE_X2AP_ID() { set(ignore); type=6;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else if(equal(reject)) { type = 2; return true; }
			else if(equal(reject)) { type = 3; return true; }
			else if(equal(reject)) { type = 4; return true; }
			else if(equal(ignore)) { type = 5; return true; }
			else if(equal(ignore)) { type = 6; return true; }
			else { type = 7; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(reject);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(reject);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(reject);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(ignore);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(ignore);} return false;
			case 7: type = 7; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		UE_X2AP_ID& select_id_Old_eNB_UE_X2AP_ID() { return set<UE_X2AP_ID>(1); }
		UE_X2AP_ID const* get_id_Old_eNB_UE_X2AP_ID() const { return get<UE_X2AP_ID>(1); }
		UE_X2AP_ID& select_id_New_eNB_UE_X2AP_ID() { return set<UE_X2AP_ID>(2); }
		UE_X2AP_ID const* get_id_New_eNB_UE_X2AP_ID() const { return get<UE_X2AP_ID>(2); }
		UE_X2AP_ID_Extension& select_id_Old_eNB_UE_X2AP_ID_Extension() { return set<UE_X2AP_ID_Extension>(3); }
		UE_X2AP_ID_Extension const* get_id_Old_eNB_UE_X2AP_ID_Extension() const { return get<UE_X2AP_ID_Extension>(3); }
		UE_X2AP_ID_Extension& select_id_New_eNB_UE_X2AP_ID_Extension() { return set<UE_X2AP_ID_Extension>(4); }
		UE_X2AP_ID_Extension const* get_id_New_eNB_UE_X2AP_ID_Extension() const { return get<UE_X2AP_ID_Extension>(4); }
		SIPTOBearerDeactivationIndication& select_id_SIPTO_BearerDeactivationIndication() { return set<SIPTOBearerDeactivationIndication>(5); }
		SIPTOBearerDeactivationIndication const* get_id_SIPTO_BearerDeactivationIndication() const { return get<SIPTOBearerDeactivationIndication>(5); }
		SgNB_UE_X2AP_ID& select_id_SgNB_UE_X2AP_ID() { return set<SgNB_UE_X2AP_ID>(6); }
		SgNB_UE_X2AP_ID const* get_id_SgNB_UE_X2AP_ID() const { return get<SgNB_UE_X2AP_ID>(6); }
		bool is_unknown() const { return type == 7; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<UE_X2AP_ID>(); break;
			case 2: var.destroy<UE_X2AP_ID>(); break;
			case 3: var.destroy<UE_X2AP_ID_Extension>(); break;
			case 4: var.destroy<UE_X2AP_ID_Extension>(); break;
			case 5: var.destroy<SIPTOBearerDeactivationIndication>(); break;
			case 6: var.destroy<SgNB_UE_X2AP_ID>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<UE_X2AP_ID>(1);
			v.template operator()<UE_X2AP_ID>(2);
			v.template operator()<UE_X2AP_ID_Extension>(3);
			v.template operator()<UE_X2AP_ID_Extension>(4);
			v.template operator()<SIPTOBearerDeactivationIndication>(5);
			v.template operator()<SgNB_UE_X2AP_ID>(6);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_Old_eNB_UE_X2AP_ID()); return true;
			case 2: v(select_id_New_eNB_UE_X2AP_ID()); return true;
			case 3: v(select_id_Old_eNB_UE_X2AP_ID_Extension()); return true;
			case 4: v(select_id_New_eNB_UE_X2AP_ID_Extension()); return true;
			case 5: v(select_id_SIPTO_BearerDeactivationIndication()); return true;
			case 6: v(select_id_SgNB_UE_X2AP_ID()); return true;
			case 7: if(type != 7) {clear(); asn::base::set();} type = 7; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<UE_X2AP_ID>()); return true;
			case 2: v(var.as<UE_X2AP_ID>()); return true;
			case 3: v(var.as<UE_X2AP_ID_Extension>()); return true;
			case 4: v(var.as<UE_X2AP_ID_Extension>()); return true;
			case 5: v(var.as<SIPTOBearerDeactivationIndication>()); return true;
			case 6: v(var.as<SgNB_UE_X2AP_ID>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(SIPTOBearerDeactivationIndication)];
			char dummy2[sizeof(SgNB_UE_X2AP_ID)];
			char dummy3[sizeof(UE_X2AP_ID)];
			char dummy4[sizeof(UE_X2AP_ID_Extension)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 7; }
		void clear() {type = 0;}
		void select_id_Old_eNB_UE_X2AP_ID() { set(mandatory); type=1;}
		void select_id_New_eNB_UE_X2AP_ID() { set(mandatory); type=2;}
		void select_id_Old_eNB_UE_X2AP_ID_Extension() { set(optional); type=3;}
		void select_id_New_eNB_UE_X2AP_ID_Extension() { set(optional); type=4;}
		void select_id_SIPTO_BearerDeactivationIndication() { set(optional); type=5;}
		void select_id_SgNB_UE_X2AP_ID() { set(optional); type=6;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(mandatory)) { type = 2; return true; }
			else if(equal(optional)) { type = 3; return true; }
			else if(equal(optional)) { type = 4; return true; }
			else if(equal(optional)) { type = 5; return true; }
			else if(equal(optional)) { type = 6; return true; }
			else { type = 7; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(optional);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(optional);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(optional);} return false;
			case 6: type = 6; if(v(ref_nested())) { return equal(optional);} return false;
			case 7: type = 7; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
UEContextRelease ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{UEContextRelease-IEs}},
	...
}
*/

struct UEContextRelease : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "UEContextRelease";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<UEContextRelease_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<UEContextRelease_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
X2AP-Message ::= OCTET STRING
*/

struct X2AP_Message : asn::ostring<>
{
	static constexpr const char* name() {return "X2AP-Message";}
	using parent_t = asn::ostring<>;

};

/*
X2APMessageTransfer-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-RNL-Header	CRITICALITY reject	TYPE RNL-Header				PRESENCE mandatory}|
	{ ID id-x2APMessage	CRITICALITY reject	TYPE X2AP-Message			PRESENCE optional},
	...
}
*/

struct X2APMessageTransfer_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 3; }
		void clear() {type = 0;}
		void select_id_RNL_Header() { set(id_RNL_Header); type=1;}
		void select_id_x2APMessage() { set(id_x2APMessage); type=2;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_RNL_Header)) { type = 1; return true; }
			else if(equal(id_x2APMessage)) { type = 2; return true; }
			else { type = 3; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_RNL_Header);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_x2APMessage);} return false;
			case 3: type = 3; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 3; }
		void clear() {type = 0;}
		void select_id_RNL_Header() { set(reject); type=1;}
		void select_id_x2APMessage() { set(reject); type=2;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else if(equal(reject)) { type = 2; return true; }
			else { type = 3; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(reject);} return false;
			case 3: type = 3; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		RNL_Header& select_id_RNL_Header() { return set<RNL_Header>(1); }
		RNL_Header const* get_id_RNL_Header() const { return get<RNL_Header>(1); }
		X2AP_Message& select_id_x2APMessage() { return set<X2AP_Message>(2); }
		X2AP_Message const* get_id_x2APMessage() const { return get<X2AP_Message>(2); }
		bool is_unknown() const { return type == 3; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<RNL_Header>(); break;
			case 2: var.destroy<X2AP_Message>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<RNL_Header>(1);
			v.template operator()<X2AP_Message>(2);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_RNL_Header()); return true;
			case 2: v(select_id_x2APMessage()); return true;
			case 3: if(type != 3) {clear(); asn::base::set();} type = 3; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<RNL_Header>()); return true;
			case 2: v(var.as<X2AP_Message>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(RNL_Header)];
			char dummy2[sizeof(X2AP_Message)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 3; }
		void clear() {type = 0;}
		void select_id_RNL_Header() { set(mandatory); type=1;}
		void select_id_x2APMessage() { set(optional); type=2;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(optional)) { type = 2; return true; }
			else { type = 3; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(optional);} return false;
			case 3: type = 3; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
X2APMessageTransfer ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{X2APMessageTransfer-IEs}},
	...
}
*/

struct X2APMessageTransfer : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "X2APMessageTransfer";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<X2APMessageTransfer_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<X2APMessageTransfer_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
X2Release-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-GlobalENB-ID			CRITICALITY reject	TYPE GlobalENB-ID			PRESENCE mandatory},
...
}
*/

struct X2Release_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_GlobalENB_ID() { set(id_GlobalENB_ID); type=1;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_GlobalENB_ID)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_GlobalENB_ID);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_GlobalENB_ID() { set(reject); type=1;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		GlobalENB_ID& select_id_GlobalENB_ID() { return set<GlobalENB_ID>(1); }
		GlobalENB_ID const* get_id_GlobalENB_ID() const { return get<GlobalENB_ID>(1); }
		bool is_unknown() const { return type == 2; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<GlobalENB_ID>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<GlobalENB_ID>(1);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_GlobalENB_ID()); return true;
			case 2: if(type != 2) {clear(); asn::base::set();} type = 2; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<GlobalENB_ID>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(GlobalENB_ID)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 2; }
		void clear() {type = 0;}
		void select_id_GlobalENB_ID() { set(mandatory); type=1;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else { type = 2; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
X2Release ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{X2Release-IEs}},
	...
}
*/

struct X2Release : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "X2Release";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<X2Release_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<X2Release_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
X2RemovalFailure-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-Cause						CRITICALITY ignore	TYPE Cause							PRESENCE mandatory}|
	{ ID id-CriticalityDiagnostics		CRITICALITY ignore	TYPE CriticalityDiagnostics			PRESENCE optional},
	...
}
*/

struct X2RemovalFailure_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 3; }
		void clear() {type = 0;}
		void select_id_Cause() { set(id_Cause); type=1;}
		void select_id_CriticalityDiagnostics() { set(id_CriticalityDiagnostics); type=2;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_Cause)) { type = 1; return true; }
			else if(equal(id_CriticalityDiagnostics)) { type = 2; return true; }
			else { type = 3; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_Cause);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_CriticalityDiagnostics);} return false;
			case 3: type = 3; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 3; }
		void clear() {type = 0;}
		void select_id_Cause() { set(ignore); type=1;}
		void select_id_CriticalityDiagnostics() { set(ignore); type=2;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else if(equal(ignore)) { type = 2; return true; }
			else { type = 3; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(ignore);} return false;
			case 3: type = 3; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		Cause& select_id_Cause() { return set<Cause>(1); }
		Cause const* get_id_Cause() const { return get<Cause>(1); }
		CriticalityDiagnostics& select_id_CriticalityDiagnostics() { return set<CriticalityDiagnostics>(2); }
		CriticalityDiagnostics const* get_id_CriticalityDiagnostics() const { return get<CriticalityDiagnostics>(2); }
		bool is_unknown() const { return type == 3; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<Cause>(); break;
			case 2: var.destroy<CriticalityDiagnostics>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<Cause>(1);
			v.template operator()<CriticalityDiagnostics>(2);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_Cause()); return true;
			case 2: v(select_id_CriticalityDiagnostics()); return true;
			case 3: if(type != 3) {clear(); asn::base::set();} type = 3; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<Cause>()); return true;
			case 2: v(var.as<CriticalityDiagnostics>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(Cause)];
			char dummy2[sizeof(CriticalityDiagnostics)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 3; }
		void clear() {type = 0;}
		void select_id_Cause() { set(mandatory); type=1;}
		void select_id_CriticalityDiagnostics() { set(optional); type=2;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(optional)) { type = 2; return true; }
			else { type = 3; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(optional);} return false;
			case 3: type = 3; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
X2RemovalFailure ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{X2RemovalFailure-IEs}},
	...
}
*/

struct X2RemovalFailure : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "X2RemovalFailure";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<X2RemovalFailure_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<X2RemovalFailure_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
X2RemovalRequest-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-GlobalENB-ID				CRITICALITY reject	TYPE GlobalENB-ID			PRESENCE mandatory}|
	{ ID id-X2RemovalThreshold			CRITICALITY reject	TYPE X2BenefitValue			PRESENCE optional},
...
}
*/

struct X2RemovalRequest_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 3; }
		void clear() {type = 0;}
		void select_id_GlobalENB_ID() { set(id_GlobalENB_ID); type=1;}
		void select_id_X2RemovalThreshold() { set(id_X2RemovalThreshold); type=2;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_GlobalENB_ID)) { type = 1; return true; }
			else if(equal(id_X2RemovalThreshold)) { type = 2; return true; }
			else { type = 3; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_GlobalENB_ID);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_X2RemovalThreshold);} return false;
			case 3: type = 3; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 3; }
		void clear() {type = 0;}
		void select_id_GlobalENB_ID() { set(reject); type=1;}
		void select_id_X2RemovalThreshold() { set(reject); type=2;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else if(equal(reject)) { type = 2; return true; }
			else { type = 3; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(reject);} return false;
			case 3: type = 3; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		GlobalENB_ID& select_id_GlobalENB_ID() { return set<GlobalENB_ID>(1); }
		GlobalENB_ID const* get_id_GlobalENB_ID() const { return get<GlobalENB_ID>(1); }
		X2BenefitValue& select_id_X2RemovalThreshold() { return set<X2BenefitValue>(2); }
		X2BenefitValue const* get_id_X2RemovalThreshold() const { return get<X2BenefitValue>(2); }
		bool is_unknown() const { return type == 3; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<GlobalENB_ID>(); break;
			case 2: var.destroy<X2BenefitValue>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<GlobalENB_ID>(1);
			v.template operator()<X2BenefitValue>(2);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_GlobalENB_ID()); return true;
			case 2: v(select_id_X2RemovalThreshold()); return true;
			case 3: if(type != 3) {clear(); asn::base::set();} type = 3; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<GlobalENB_ID>()); return true;
			case 2: v(var.as<X2BenefitValue>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(GlobalENB_ID)];
			char dummy2[sizeof(X2BenefitValue)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 3; }
		void clear() {type = 0;}
		void select_id_GlobalENB_ID() { set(mandatory); type=1;}
		void select_id_X2RemovalThreshold() { set(optional); type=2;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(optional)) { type = 2; return true; }
			else { type = 3; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(optional);} return false;
			case 3: type = 3; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
X2RemovalRequest ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{X2RemovalRequest-IEs}},
	...
}
*/

struct X2RemovalRequest : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "X2RemovalRequest";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<X2RemovalRequest_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<X2RemovalRequest_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
X2RemovalResponse-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-GlobalENB-ID				CRITICALITY reject	TYPE GlobalENB-ID				PRESENCE mandatory}|
	{ ID id-CriticalityDiagnostics		CRITICALITY ignore	TYPE CriticalityDiagnostics		PRESENCE optional},
	...
}
*/

struct X2RemovalResponse_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 3; }
		void clear() {type = 0;}
		void select_id_GlobalENB_ID() { set(id_GlobalENB_ID); type=1;}
		void select_id_CriticalityDiagnostics() { set(id_CriticalityDiagnostics); type=2;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_GlobalENB_ID)) { type = 1; return true; }
			else if(equal(id_CriticalityDiagnostics)) { type = 2; return true; }
			else { type = 3; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_GlobalENB_ID);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_CriticalityDiagnostics);} return false;
			case 3: type = 3; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 3; }
		void clear() {type = 0;}
		void select_id_GlobalENB_ID() { set(reject); type=1;}
		void select_id_CriticalityDiagnostics() { set(ignore); type=2;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else if(equal(ignore)) { type = 2; return true; }
			else { type = 3; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(ignore);} return false;
			case 3: type = 3; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		GlobalENB_ID& select_id_GlobalENB_ID() { return set<GlobalENB_ID>(1); }
		GlobalENB_ID const* get_id_GlobalENB_ID() const { return get<GlobalENB_ID>(1); }
		CriticalityDiagnostics& select_id_CriticalityDiagnostics() { return set<CriticalityDiagnostics>(2); }
		CriticalityDiagnostics const* get_id_CriticalityDiagnostics() const { return get<CriticalityDiagnostics>(2); }
		bool is_unknown() const { return type == 3; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<GlobalENB_ID>(); break;
			case 2: var.destroy<CriticalityDiagnostics>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<GlobalENB_ID>(1);
			v.template operator()<CriticalityDiagnostics>(2);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_GlobalENB_ID()); return true;
			case 2: v(select_id_CriticalityDiagnostics()); return true;
			case 3: if(type != 3) {clear(); asn::base::set();} type = 3; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<GlobalENB_ID>()); return true;
			case 2: v(var.as<CriticalityDiagnostics>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(CriticalityDiagnostics)];
			char dummy2[sizeof(GlobalENB_ID)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 3; }
		void clear() {type = 0;}
		void select_id_GlobalENB_ID() { set(mandatory); type=1;}
		void select_id_CriticalityDiagnostics() { set(optional); type=2;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(optional)) { type = 2; return true; }
			else { type = 3; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(optional);} return false;
			case 3: type = 3; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
X2RemovalResponse ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{X2RemovalResponse-IEs}},
	...
}
*/

struct X2RemovalResponse : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "X2RemovalResponse";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<X2RemovalResponse_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<X2RemovalResponse_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
X2SetupFailure-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-Cause					CRITICALITY ignore		TYPE Cause								PRESENCE mandatory} |
	{ ID id-TimeToWait				CRITICALITY ignore		TYPE TimeToWait							PRESENCE optional} |
	{ ID id-CriticalityDiagnostics	CRITICALITY ignore		TYPE CriticalityDiagnostics				PRESENCE optional },

	...
}
*/

struct X2SetupFailure_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 4; }
		void clear() {type = 0;}
		void select_id_Cause() { set(id_Cause); type=1;}
		void select_id_TimeToWait() { set(id_TimeToWait); type=2;}
		void select_id_CriticalityDiagnostics() { set(id_CriticalityDiagnostics); type=3;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_Cause)) { type = 1; return true; }
			else if(equal(id_TimeToWait)) { type = 2; return true; }
			else if(equal(id_CriticalityDiagnostics)) { type = 3; return true; }
			else { type = 4; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_Cause);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_TimeToWait);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_CriticalityDiagnostics);} return false;
			case 4: type = 4; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 4; }
		void clear() {type = 0;}
		void select_id_Cause() { set(ignore); type=1;}
		void select_id_TimeToWait() { set(ignore); type=2;}
		void select_id_CriticalityDiagnostics() { set(ignore); type=3;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(ignore)) { type = 1; return true; }
			else if(equal(ignore)) { type = 2; return true; }
			else if(equal(ignore)) { type = 3; return true; }
			else { type = 4; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(ignore);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(ignore);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(ignore);} return false;
			case 4: type = 4; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		Cause& select_id_Cause() { return set<Cause>(1); }
		Cause const* get_id_Cause() const { return get<Cause>(1); }
		TimeToWait& select_id_TimeToWait() { return set<TimeToWait>(2); }
		TimeToWait const* get_id_TimeToWait() const { return get<TimeToWait>(2); }
		CriticalityDiagnostics& select_id_CriticalityDiagnostics() { return set<CriticalityDiagnostics>(3); }
		CriticalityDiagnostics const* get_id_CriticalityDiagnostics() const { return get<CriticalityDiagnostics>(3); }
		bool is_unknown() const { return type == 4; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<Cause>(); break;
			case 2: var.destroy<TimeToWait>(); break;
			case 3: var.destroy<CriticalityDiagnostics>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<Cause>(1);
			v.template operator()<TimeToWait>(2);
			v.template operator()<CriticalityDiagnostics>(3);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_Cause()); return true;
			case 2: v(select_id_TimeToWait()); return true;
			case 3: v(select_id_CriticalityDiagnostics()); return true;
			case 4: if(type != 4) {clear(); asn::base::set();} type = 4; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<Cause>()); return true;
			case 2: v(var.as<TimeToWait>()); return true;
			case 3: v(var.as<CriticalityDiagnostics>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(Cause)];
			char dummy2[sizeof(CriticalityDiagnostics)];
			char dummy3[sizeof(TimeToWait)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 4; }
		void clear() {type = 0;}
		void select_id_Cause() { set(mandatory); type=1;}
		void select_id_TimeToWait() { set(optional); type=2;}
		void select_id_CriticalityDiagnostics() { set(optional); type=3;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(optional)) { type = 2; return true; }
			else if(equal(optional)) { type = 3; return true; }
			else { type = 4; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(optional);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(optional);} return false;
			case 4: type = 4; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
X2SetupFailure ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{X2SetupFailure-IEs}},
	...
}
*/

struct X2SetupFailure : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "X2SetupFailure";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<X2SetupFailure_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<X2SetupFailure_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
X2SetupRequest-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-GlobalENB-ID			CRITICALITY reject	TYPE GlobalENB-ID			PRESENCE mandatory}|
	{ ID id-ServedCells				CRITICALITY reject	TYPE ServedCells			PRESENCE mandatory}|
	{ ID id-GUGroupIDList			CRITICALITY reject	TYPE GUGroupIDList			PRESENCE optional}|
	{ ID id-LHN-ID					CRITICALITY ignore	TYPE LHN-ID					PRESENCE optional},
...
}
*/

struct X2SetupRequest_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 5; }
		void clear() {type = 0;}
		void select_id_GlobalENB_ID() { set(id_GlobalENB_ID); type=1;}
		void select_id_ServedCells() { set(id_ServedCells); type=2;}
		void select_id_GUGroupIDList() { set(id_GUGroupIDList); type=3;}
		void select_id_LHN_ID() { set(id_LHN_ID); type=4;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_GlobalENB_ID)) { type = 1; return true; }
			else if(equal(id_ServedCells)) { type = 2; return true; }
			else if(equal(id_GUGroupIDList)) { type = 3; return true; }
			else if(equal(id_LHN_ID)) { type = 4; return true; }
			else { type = 5; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_GlobalENB_ID);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_ServedCells);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_GUGroupIDList);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(id_LHN_ID);} return false;
			case 5: type = 5; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 5; }
		void clear() {type = 0;}
		void select_id_GlobalENB_ID() { set(reject); type=1;}
		void select_id_ServedCells() { set(reject); type=2;}
		void select_id_GUGroupIDList() { set(reject); type=3;}
		void select_id_LHN_ID() { set(ignore); type=4;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else if(equal(reject)) { type = 2; return true; }
			else if(equal(reject)) { type = 3; return true; }
			else if(equal(ignore)) { type = 4; return true; }
			else { type = 5; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(reject);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(reject);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(ignore);} return false;
			case 5: type = 5; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		GlobalENB_ID& select_id_GlobalENB_ID() { return set<GlobalENB_ID>(1); }
		GlobalENB_ID const* get_id_GlobalENB_ID() const { return get<GlobalENB_ID>(1); }
		ServedCells& select_id_ServedCells() { return set<ServedCells>(2); }
		ServedCells const* get_id_ServedCells() const { return get<ServedCells>(2); }
		GUGroupIDList& select_id_GUGroupIDList() { return set<GUGroupIDList>(3); }
		GUGroupIDList const* get_id_GUGroupIDList() const { return get<GUGroupIDList>(3); }
		LHN_ID& select_id_LHN_ID() { return set<LHN_ID>(4); }
		LHN_ID const* get_id_LHN_ID() const { return get<LHN_ID>(4); }
		bool is_unknown() const { return type == 5; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<GlobalENB_ID>(); break;
			case 2: var.destroy<ServedCells>(); break;
			case 3: var.destroy<GUGroupIDList>(); break;
			case 4: var.destroy<LHN_ID>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<GlobalENB_ID>(1);
			v.template operator()<ServedCells>(2);
			v.template operator()<GUGroupIDList>(3);
			v.template operator()<LHN_ID>(4);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_GlobalENB_ID()); return true;
			case 2: v(select_id_ServedCells()); return true;
			case 3: v(select_id_GUGroupIDList()); return true;
			case 4: v(select_id_LHN_ID()); return true;
			case 5: if(type != 5) {clear(); asn::base::set();} type = 5; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<GlobalENB_ID>()); return true;
			case 2: v(var.as<ServedCells>()); return true;
			case 3: v(var.as<GUGroupIDList>()); return true;
			case 4: v(var.as<LHN_ID>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(GUGroupIDList)];
			char dummy2[sizeof(GlobalENB_ID)];
			char dummy3[sizeof(LHN_ID)];
			char dummy4[sizeof(ServedCells)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 5; }
		void clear() {type = 0;}
		void select_id_GlobalENB_ID() { set(mandatory); type=1;}
		void select_id_ServedCells() { set(mandatory); type=2;}
		void select_id_GUGroupIDList() { set(optional); type=3;}
		void select_id_LHN_ID() { set(optional); type=4;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(mandatory)) { type = 2; return true; }
			else if(equal(optional)) { type = 3; return true; }
			else if(equal(optional)) { type = 4; return true; }
			else { type = 5; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(optional);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(optional);} return false;
			case 5: type = 5; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
X2SetupRequest ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{X2SetupRequest-IEs}},
	...
}
*/

struct X2SetupRequest : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "X2SetupRequest";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<X2SetupRequest_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<X2SetupRequest_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
/*
X2SetupResponse-IEs X2AP-PROTOCOL-IES ::= {
	{ ID id-GlobalENB-ID				CRITICALITY reject	TYPE GlobalENB-ID			PRESENCE mandatory}|
	{ ID id-ServedCells					CRITICALITY reject	TYPE ServedCells			PRESENCE mandatory}|
	{ ID id-GUGroupIDList				CRITICALITY reject	TYPE GUGroupIDList			PRESENCE optional}|
	{ ID id-CriticalityDiagnostics		CRITICALITY ignore	TYPE CriticalityDiagnostics	PRESENCE optional}|
	{ ID id-LHN-ID						CRITICALITY ignore	TYPE LHN-ID					PRESENCE optional},
	...
}
*/

struct X2SetupResponse_IEs
{
	struct id_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::id_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 6; }
		void clear() {type = 0;}
		void select_id_GlobalENB_ID() { set(id_GlobalENB_ID); type=1;}
		void select_id_ServedCells() { set(id_ServedCells); type=2;}
		void select_id_GUGroupIDList() { set(id_GUGroupIDList); type=3;}
		void select_id_CriticalityDiagnostics() { set(id_CriticalityDiagnostics); type=4;}
		void select_id_LHN_ID() { set(id_LHN_ID); type=5;}
		X2AP_PROTOCOL_IES::id_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(id_GlobalENB_ID)) { type = 1; return true; }
			else if(equal(id_ServedCells)) { type = 2; return true; }
			else if(equal(id_GUGroupIDList)) { type = 3; return true; }
			else if(equal(id_CriticalityDiagnostics)) { type = 4; return true; }
			else if(equal(id_LHN_ID)) { type = 5; return true; }
			else { type = 6; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(id_GlobalENB_ID);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(id_ServedCells);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(id_GUGroupIDList);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(id_CriticalityDiagnostics);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(id_LHN_ID);} return false;
			case 6: type = 6; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct criticality_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::criticality_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 6; }
		void clear() {type = 0;}
		void select_id_GlobalENB_ID() { set(reject); type=1;}
		void select_id_ServedCells() { set(reject); type=2;}
		void select_id_GUGroupIDList() { set(reject); type=3;}
		void select_id_CriticalityDiagnostics() { set(ignore); type=4;}
		void select_id_LHN_ID() { set(ignore); type=5;}
		X2AP_PROTOCOL_IES::criticality_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(reject)) { type = 1; return true; }
			else if(equal(reject)) { type = 2; return true; }
			else if(equal(reject)) { type = 3; return true; }
			else if(equal(ignore)) { type = 4; return true; }
			else if(equal(ignore)) { type = 5; return true; }
			else { type = 6; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(reject);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(reject);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(reject);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(ignore);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(ignore);} return false;
			case 6: type = 6; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};
	struct Value_t : asn::typefield<true>
	{
		~Value_t()	{clear();}
		size_t get_index() const {return type;}
		GlobalENB_ID& select_id_GlobalENB_ID() { return set<GlobalENB_ID>(1); }
		GlobalENB_ID const* get_id_GlobalENB_ID() const { return get<GlobalENB_ID>(1); }
		ServedCells& select_id_ServedCells() { return set<ServedCells>(2); }
		ServedCells const* get_id_ServedCells() const { return get<ServedCells>(2); }
		GUGroupIDList& select_id_GUGroupIDList() { return set<GUGroupIDList>(3); }
		GUGroupIDList const* get_id_GUGroupIDList() const { return get<GUGroupIDList>(3); }
		CriticalityDiagnostics& select_id_CriticalityDiagnostics() { return set<CriticalityDiagnostics>(4); }
		CriticalityDiagnostics const* get_id_CriticalityDiagnostics() const { return get<CriticalityDiagnostics>(4); }
		LHN_ID& select_id_LHN_ID() { return set<LHN_ID>(5); }
		LHN_ID const* get_id_LHN_ID() const { return get<LHN_ID>(5); }
		bool is_unknown() const { return type == 6; }
		void clear()
		{
			switch(type)
			{
			case 1: var.destroy<GlobalENB_ID>(); break;
			case 2: var.destroy<ServedCells>(); break;
			case 3: var.destroy<GUGroupIDList>(); break;
			case 4: var.destroy<CriticalityDiagnostics>(); break;
			case 5: var.destroy<LHN_ID>(); break;
			}
			type = 0; ref_nested().clear();
		}
		template<typename V> static inline void enumerate(V& v)
		{
			v.template operator()<GlobalENB_ID>(1);
			v.template operator()<ServedCells>(2);
			v.template operator()<GUGroupIDList>(3);
			v.template operator()<CriticalityDiagnostics>(4);
			v.template operator()<LHN_ID>(5);

		}
		protected:
		template<typename V> bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: v(select_id_GlobalENB_ID()); return true;
			case 2: v(select_id_ServedCells()); return true;
			case 3: v(select_id_GUGroupIDList()); return true;
			case 4: v(select_id_CriticalityDiagnostics()); return true;
			case 5: v(select_id_LHN_ID()); return true;
			case 6: if(type != 6) {clear(); asn::base::set();} type = 6; return true;
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) return false;
			switch(type)
			{
			case 1: v(var.as<GlobalENB_ID>()); return true;
			case 2: v(var.as<ServedCells>()); return true;
			case 3: v(var.as<GUGroupIDList>()); return true;
			case 4: v(var.as<CriticalityDiagnostics>()); return true;
			case 5: v(var.as<LHN_ID>()); return true;
			}
			return false;

		}
		private:
		template<class T> T& set(size_t index) {if(type != index) {clear(); type = index; return var.build<T>();} return var.as<T>();}
		template<class T> T const* get(size_t index) const {if(type == index) {return &var.as<T>();} return nullptr;}
		union union_type
		{
			char dummy1[sizeof(CriticalityDiagnostics)];
			char dummy2[sizeof(GUGroupIDList)];
			char dummy3[sizeof(GlobalENB_ID)];
			char dummy4[sizeof(LHN_ID)];
			char dummy5[sizeof(ServedCells)];

		};
		asn::variant<sizeof(union_type)> var;
		size_t type {0};

	};
	struct presence_t : asn::fixedtypefield<X2AP_PROTOCOL_IES::presence_t, true>
	{
		size_t get_index() const {return type;}
		bool is_unknown() const { return type == 6; }
		void clear() {type = 0;}
		void select_id_GlobalENB_ID() { set(mandatory); type=1;}
		void select_id_ServedCells() { set(mandatory); type=2;}
		void select_id_GUGroupIDList() { set(optional); type=3;}
		void select_id_CriticalityDiagnostics() { set(optional); type=4;}
		void select_id_LHN_ID() { set(optional); type=5;}
		X2AP_PROTOCOL_IES::presence_t const& ref_value() const {return ref_nested();}
		template<typename V>  bool decode(V& v)
		{
			clear();
			if(!v(ref_nested())) return false;
			if(equal(mandatory)) { type = 1; return true; }
			else if(equal(mandatory)) { type = 2; return true; }
			else if(equal(optional)) { type = 3; return true; }
			else if(equal(optional)) { type = 4; return true; }
			else if(equal(optional)) { type = 5; return true; }
			else { type = 6; return true;}
			return false;

		}
		template<typename V> bool encode(V& v) const
		{
			return v(ref_nested());

		}
		protected:
		template<typename V>  bool decode(size_t index, V& v)
		{
			clear();
			switch(index)
			{
			case 1: type = 1; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 2: type = 2; if(v(ref_nested())) { return equal(mandatory);} return false;
			case 3: type = 3; if(v(ref_nested())) { return equal(optional);} return false;
			case 4: type = 4; if(v(ref_nested())) { return equal(optional);} return false;
			case 5: type = 5; if(v(ref_nested())) { return equal(optional);} return false;
			case 6: type = 6; return v(ref_nested());
			ref_nested().clear();
			}
			return false;

		}
		template<typename V> bool encode(size_t index, V& v) const
		{
			if(index != type) {return false;} return v(ref_nested());

		}
		private:
		size_t type {0};

	};

};
/*
X2SetupResponse ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container	{{X2SetupResponse-IEs}},
	...
}
*/

struct X2SetupResponse : asn::sequence<1, 0, true, 0>
{
	static constexpr const char* name() {return "X2SetupResponse";}
	using parent_t = asn::sequence<1, 0, true, 0>;
	struct protocolIEs_t : ProtocolIE_Container<X2SetupResponse_IEs>
	{
		static constexpr const char* name() {return "protocolIEs_t";}
		using parent_t = ProtocolIE_Container<X2SetupResponse_IEs>;

	};
	protocolIEs_t& ref_protocolIEs() {return protocolIEs;}
	protocolIEs_t const& ref_protocolIEs() const {return protocolIEs;}
	template<typename V> void decode(V& v)
	{
		v(protocolIEs);

	};
	template<typename V> void encode(V& v) const
	{
		v(protocolIEs);

	};
	void clear()
	{
		protocolIEs.clear();

	};
	private:
	protocolIEs_t	protocolIEs;

};
